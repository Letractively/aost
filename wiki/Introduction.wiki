#labels Phase-Design,Featured
= Tellurium Automated Testing Framework =

== Why Use Tellurium ==

Tellurium is built on top of Selenium and tries to solve the shortcomings for Selenium., i.e., ugly syntax, not robust, "record and reply" style, difficult to refactor and maintain. Tellurium provides you a totally different way to write Selenium tests. 

The following are some of the reasons why you should use Tellurium:

  * Tellurium is not a "record and reply" style testing framework, but UI module centric. That is to say, you should define your UI module first. Based on your Ui module, you can write as many tests as you like just like writing JUnit tests. Tellurium also make it possible for users to write Tellurium tests when they start coding.
 
  * Tellurium uses very expressive way to define Ui Modules and writes tests. For example, in Selenium, you have to write the following ugly expressions (take Google start page as an example):

{{{
selenium.type("//input[@title='Google Search']", input)
selenium.click(""//input[@name='btnG' and @type='submit']")
}}}

In Tellurium, you can first define the UI module as:

{{{
ui.Container(uid: "google_start_page", clocator: [tag: "td"], group: "true"){
    InputBox(uid: "searchbox", clocator: [title: "Google Search"])
    SubmitButton(uid: "googlesearch", clocator: [name: "btnG", value: "Google Search"])
}
}}}

Then in your tests, you simple use

{{{
type "google_start_page.searchbox", input
click "google_start_page.googlesearch"
}}}

  * Tellurium is compatible with Selenium's locators, you still can use XPath like {{{"//input[@title='Google Search']"}}} in your UI module, but Tellurium give you additional advantage to use "google_start_page.searchbox" style syntax to refer the UI object instead of putting the ugly XPath expressions everywhere.

  * Tellurium recommends you use composite locator, i.e., use UI object attributes instead of XPath to define the UI. For example, in the above example, you specify an InputBox object with its attribute title to be "Google Search". Once you define UI attributes, Tellurium will automatically create the runtime XPath for you. In this way, the UI module matches better with your UI markup languages such as JSP and ASP.

  * Tellurium exploits the "Group Locating" concept to treat a group of Ui Object as a whole instead of individual ones, which is the case for Selenium. In the above example, by specifying the "group" attribute to be "true", Tellurium will try to locate the UI objects in the DOM using all information from the Container, InputBox, and SubmitButton. This can help us a lot to find the UI locators. For most case, the information inside the group of UI objects is enough to locate all of them. That is to say,  your Ui module only depends on attributes inside of itself, not any UI outside. As a result, make it very robust.

  * Tellurium provides many predefined UI objects for you to use directly, such as  Button, CheckBox,  InputBox, Selector, TextBox, and Table. In the meanwhile, it also provides you the capability to write your own custom UI objects.

  * Tellurium supports Domain Specific Language (DSL) for Web testing and you can even write all your tests in pure DSL scripts.

  * Tellurium comes with the "Data Driven Testing" feature so that you can use an input file to drive your predefined tests. One example input file is listed as follows:

{{{
##Data for test "checkBookList"
##TEST | CATEGORY | SIZE
checkBookList|Fiction|8
checkBookList|Fiction|3

##Data for test "getGCHStatus"
##TEST | LABEL | Row Number | Column Number
getGCHStatus |Example project labels:| 3 | 6
getGCHStatus |Example project| 3 | 6
}}}

Where the TEST column defines your test name and the rest columns are either input data or expected results.

  * Tellurium provides detailed documents on how to use Tellurium including introduction, tutorials, user guide, and FAQs. We also use Tellurium project website as an example to demonstrate how to write real world Tellurium tests.

== Architecture ==

The Tellurium framework Architecture is shown as in Figure 1.

http://tellurium-users.googlegroups.com/web/tellurium.architecture.png?gda=1NP4x0sAAAAFkHkURP2WlgYU-UhtQDFJganRixm7ZVzXjIzQXs5CXWG1qiJ7UbTIup-M2XPURDThcsDHHqasJHRvnmR6jbzWzHqwysTvAgdPZHbdH4XvXg&gsc=26Y4eBYAAAAkGgIQNXlg3kIha08SEZtI9pmI1qD38G08ONb6YfjJaQ

Figure 1. Tellurium Architecture.

The system diagram of Tellurium consists of three parts, one is the Selenium Server, on which our Tellurium framework builds, the Tellurium framework, and user defined Java test cases or .dsl pure DSL test scripts. 

The Tellurium Framework is based on the DslContext, which defines all DSLs we can use for Tellurium. We can further divide the Tellurium Framework into Four parts.

=== UI Object Parser ===

This parts consists of the DSL Object Parser, Object Builders, and the Object Registry.

Thanks to Groovy’s builder pattern, we can define UI object expressively and in a nested fashion. The DSL object parser will parse the DSL object definition recursively and use object builders to build the objects on the fly. An object builder registry is designed to hold all predefined UI object builders in the Tellurium framework and the DSL object parser will look at the builder registry to find the appropriate builders. Since the registry is a hash map, you can override a builder with a new one using the same UI name. Users can also add their customer builders into the builder registry.
 
The DSL object definition always comes first with a container type object. An object registry (A hash map) is used to stored all top level UI Objects. As a result, for each DSL object definition, the top object ids must be unique in the DslContext. The object registry will be used by the framework to search objects by their ids and fetch objects for different actions.

=== Object Locator Mapping ===

The Object Locator Mapping (OLM) is the core of the Tellurium framework and it includes UI ID mapping, XPath builder, Locator Processor, and Group Locating. The UI ID supports nested object, for example, "menu.wiki" stands for a URL Link "wiki" inside a container called "menu". The UI ID also supports one dimension and two dimension index for table and list. For example, {{{"main.table[2][3]"}}} stands the UI object of the 2nd row and the 3rd column of a table inside the container "main".

XPath builder can build the XPath from relative XPaths or from attributes. The locator processor converts the locator information in the UI object to the XPath. The Group Locating Concept (GLC) is to exploit the group information in side a collection of UI objects to help us find the locator of the collection of UI objects. 

=== Event and Data Handling ===

The Eventhandler in this part will handle all events like "click", "type", "select", and so on. The Data Accessor is used to fetch data or UI status from the DOM. The dispatcher will delegate all calls it receives from the Eventhandler and the data accessor to the Selenium Client, which will connect to the Selenium Server. The dispatcher is designed to decouple the rest of the Tellurium framework with the Selenium framework so that we can simply change the dispatcher logic to delegate all calls to other underneath UI test frameworks if we want to switch Tellurium not to use the Selenium framework someday.  

== HOW Tellurium works ==

Basically, there are two parts for the Tellurium framework. The first part is to define UI objects and the second part is working on the UI objects like firing events and getting data or status from the DOM.

=== The "Define UI" Operation ===

The "Define UI" operation can be demonstrated in the following sequence diagram:

http://tellurium-users.googlegroups.com/web/aost_sequence_defineui.png?gda=ut9Dd0sAAAAFkHkURP2WlgYU-UhtQDFJfFjOBE5aGMxp_hs9PNxhIGG1qiJ7UbTIup-M2XPURDRalx4T6cOZyoocLzTpPNoT-xRs6kTo9_1MlJqhLlX0VQ&gsc=26Y4eBYAAAAkGgIQNXlg3kIha08SEZtI9pmI1qD38G08ONb6YfjJaQ

Figure 2. The sequence diagram for "DefineUI"

When the Test Case calls "DefineUI", the DslContext will call the Dsl Object Parser to parse the UI definition. The Parser will look at each node and call the appropriate builders to build UI objects. The top level object will be stored in the UI Object registry so that we can search for the UI object by UI Id.
 

Note that the processing of the pure DSL script is the same.
 
=== The Action Operation ===

The processing of actions such as clicking on an UI object is illustrated in Figure 3:

http://tellurium-users.googlegroups.com/web/aost_sequence_click.png?gda=EuRP9kgAAAAFkHkURP2WlgYU-UhtQDFJfFjOBE5aGMxp_hs9PNxhIGG1qiJ7UbTIup-M2XPURDSpnGSpq9shp5Nom0pUQ_VQjwc8kMSHiCJV0Te5P6rKfA&gsc=26Y4eBYAAAAkGgIQNXlg3kIha08SEZtI9pmI1qD38G08ONb6YfjJaQ

Figure 3. The sequence diagram for the "click" action

The action processing includes following two parts. 

==== Search For the UI Object ===
First, the DslContext will create a WorkflowContext so that we can pass meta data such the relative xpath inside it. Then, we start to look at the UI object registry by calling the walkTo method. Remember, the UI object registry hold all the top level UI objects. If we can find the top level UI object, we can recursively call the WalkTo method on the next UI object until we find the UI Object matching the UI id, or we cannot find the UI object by UI Id. 

During the walkTo method calls, we also start to aggregate relative xpaths into the reference xpath to the next UI object.

==== Construct the Locator and Fire the Event ====

If the UI Object is found, we fire the action such as "click" on the UI object and pass in a closure which can access the eventhandler, the WorkflowContext, and the LocatorProcessor. The WorkflowContext includes the reference xpath to the UI object and the LocatorProcessor can generate the xpath of the UI object itself. In this way, the runtime locator is constructed. 

Then, the UI object will call the Eventhandler to fire the click event. The event will pass all the way down from the dispatcher and Selenium Client to the Selenium Server.
 
=== The Data Access Operation ===

The data access operation is very much like the action operation shown in Figure 3 and the only difference is that the Data Accessor will replace the Eventhandler. But be aware, for some data access, there is no UI locator associated with it. For example, you want to get the current DOM html presentation. In this case, you just call the Data Accessor directly.


== UI Object ==

=== UI Object Attributes ===

The UI Object includes
  * uid: should be unique in a UI module
  * namespace: for future extension
  * locator: the locator of the UI object, could be a base locator or a composite locator
  * Features: the inherent feature of the UI component, for example, the selection UI component normally comes with “label=?” or “value=?”. Table always has the “table”, “tr”, “td”, “th” tags.
  * useGroupInfo: this option only applies to a collection type of UI object such as Container, Table, List, Form and so on. By default, this option is off and it can be turned on by specifying the "group" attribute to be true, i.e., {{{group: "true"}}}. If it is on, the container type object will use the inside UI objects' attributes to help locating its locator.

Regular UI objects include Button, CheckBox, Icon, InputBox, Selector, TextBox, Table and so on, The list of predefined Tellurium Ui objects can be found on [http://code.google.com/p/aost/wiki/UserGuide the User Guide page]. 

A container is a special UI object and it could be a pure abstract object to hold and group different UI objects together. The container will make the objects inside searchable since it uses a list to hold them.

Users can also define custom UI objects. They need to create a UI builder for each new UI 
object and add it to the UiObjectBuilderRegistry. Be aware that each UI object only has predefined set of events or actions. For example, the InputBox has the _type_ action, but the Selector does not have that. 

=== UI Object Locators ===

There are two type of UI object locators:
  * Base Locator: the actual locator at run time. Denoted by "locator".
  * Composite Locator: User specifies a set of parameters for the object and the actual locator will be derived automatically by Tellurium. Denoted by "clocator".

The Basic Locator is only a String that you can specify the run time locator, be aware that the basic locator can be a partial locator, Tellurium will construct the actual run time locator starting from the top level object and all the way to the current object. 

The Composite Locator is more complicated and its definition is as follows:
{{{
class CompositeLocator {
    String header
    String tag
    String text
    String trailer
    def position
    boolean direct
    Map<String, String> attributes = [:]
}
}}}

To use composite locator, you need to use "clocator" and its value is a map, i.e.,
{{{
clocator: [key1: value1, key2: value2, ...]
}}}
format in Groovy. The defined keys include "header", "tag", "text", "trailer", "position", and "direct". They are all optional. For most UI object, the html tag is fixed, for example, a Table's tag is always "table". If a UI object has fixed tag and it is defined in object class, you do not need to include "tag". The "direct" key specifies whether this UI object is a direct child of the header or its parent UI and the default value is "false".

You may have additional attributes, define them in the same way as the predefined keys. For example:
 
{{{
value: "Tellurium home"
}}} 

If the attribute is a String, you can put "%%" at the begin of the String to indicate that it is a partial matching. For example, in the following clocator, the text attribute is a partial matching and the "%%" indicate that the text should contain "PageName".

{{{
UrlLink(uid: "header", clocator: [text: "%%PageName"])
}}}

 
Header and Trailer are used to specify addition xpath related to this UI object and the final xpath is 
{{{
XPath = header + derived xpath for object + trailer
}}}

=== The Group Locating Concept (GLC) ===

The Group Locating Concept (GLC) concept comes from the simple observation, i.e., it is much easier to locate a collection of UI objects than a single UI object. The reason is multiple UI objects provide more search criteria to help you to locate the UIs. This concept is implemented in Tellurium. All collection type object, i.e., Container and its extended classes have an option to use the group locating concept. 

Let's see the differences between regular locating and group locating. Still take the google start page as an example:

{{{
ui.Container(uid: "google_start_page", clocator: [tag: "td"], group: "true"){
  InputBox(uid: "searchbox", clocator: [title: "Google Search"])
  SubmitButton(uid: "googlesearch", clocator: [name: "btnG", value: "Google Search"])
  SubmitButton(uid: "Imfeelinglucky", clocator: [value: "I'm Feeling Lucky"])
}

}}}

Here, clocator stands for composite locator. Without group locating, I can only use the given criteria 

{{{
tag = "td" 
}}}

to find the container locator, i.e., 
{{{
I am looking for a td html tag in the DOM
}}} 
which is quite difficult. If we use the group locating, the Container can use the group information provided by its children. Now, the problem becomes: 
{{{
  I am looking for a td html tag in the DOM and its children including an input box with
  title "Google Search", a submit button with name "btnG" and value "Google Search", and
  another submit button with value "I'm Feeling Lucky"
}}}
Woo! I have a lot of information to help me to locate the container. Once the container is found, all its children can be found very easily.

The direct result of group locating is that for most case, the information defined in the UI module itself is enough for you to locate all UI objects in that UI module. That is to say, your test code only depends on your own UI module, not its location and its outside. Even we change the UI, the test may still work.  

Another advantage is that you may be able to map your JSP, PHP, ASP,..., file directly to the UI module in Tellurium. This could help developers a lot for writing Selenium tests because they do not need to manually find the locator for an UI object. 

== Domain Specific Language ==
 
Domain Specific Language (DSL) indicates a programming language or specification language dedicated to a particular problem domain, a particular problem representation technique, and/or a particular solution technique. Here the domain refers to UI testing. DSL is specified in the class *DslContext*, which defines the basic DSLs. 

=== Define UI objects ===

_ui.Container_ is used to define the UI objects on the web and map them to objects.
For example, the search module in the google start page can be defined by 
the following DSL.

{{{
ui.Container(uid: "google_search"){
   InputBox(uid: "inputbox1", locator: "//input[@title='Google Search']")
   Button(uid: "button1", locator: "//input[@name='btnG' and @type='submit']")
}
}}}

The definition can be nested, for example
{{{
ui.Container(uid: "parent_ui"){
   InputBox(uid: "inputbox1", locator: "...")
   Button(uid: "button1", locator: "...")
   Container(uid: "child_ui){
     Selector(uid: "selector1", locator: "...")
     ...
     Container(uid: "grand_child"){
       TextBox(uid: "textbox1", locator: "...")
       ...
     }
   }
}
}}}

=== UiID ===

In DSL, the Ui object is referred by the UiID. For nested Ui objects, the UiID of the Ui Object is a concatenated of the Ui objects' uids along its path to the Ui Object. For example, in the above nested Ui Module, the TextBox is referred as "parent_ui.child_ui.grand_child.textbox1". The exceptions are tables and lists, which use {{{[x][y]}}} or {{{[x]}}} to reference its elements inside. For example, {{{labels_table[2][1]}}} and {{{GoogleBooksList.subcategory[2]}}}. Table header can be referred in the format of {{{issueResult.header[2]}}}.

For menu, you need to define an alias name for each item. For instance, the Tellurium issues page includes the following menu,

{{{
//items is a map in the format of "alias name" : menu_item
ui.SimpleMenu(uid: "IdMenu", clocator:[class: "popup", id: "pop_0"],
      items: ["SortUp":"Sort Up", "SortDown":"Sort Down", "HideColumn":"Hide Column"])
}}} 

You need to use the alias name to refer the menu item, for example, "IdMenu.SortUp".

For the option object, the option uid must be the same as the UI objects it represent
and in this way, you do not need to include it in the DSL. For example, in the following Ui Module,

{{{
//The selector to choose the data grid layout as List or Grid
ui.Option(uid: "layoutSelector"){
   Container(uid: "layoutSelector", clocator: [tag: "div"], group: "true") {
      TextBox(uid: "List", clocator: [tag: "b", text: "List", direct: "true"])
      UrlLink(uid: "Grid", clocator: [text: "Grid", direct: "true"])
   }
   Container(uid: "layoutSelector", clocator: [tag: "div"], group: "true") {
      UrlLink(uid: "List", clocator: [text: "List", direct: "true"])
      TextBox(uid: "Grid", clocator: [tag: "b", text: "Grid", direct: "true"])
   }
}
}}}

you just use

{{{
click "layoutSelector.List"
}}}

instead of

{{{
click "layoutSelector.layoutSelector.List"
}}}

=== Extended DSLs ===

Because of the Groovy Syntax, each method in the DslContext can be written using DSL syntax. Take the following mouseOver method as an example,

  * mouseOver(String id): Simulates a user hovering a mouse over the specified element. Its DSL format is:

  {{{
    mouseOver id
  }}}

  In your test script, you can write as follows,

  {{{
    mouseOver "IdMenu.SortDown"
  }}}

The complete list of methods in DslContext can be found on [http://code.google.com/p/aost/wiki/UserGuide the User Guide page].


The DslContext can be extended to include more DSLs. Tellurium also defined a set of DSLs to support Tellurium tests. The most often used ones includes

  * openUrl(String url): establish a new connection to Selenium server for the given url. The DSL format is:

  {{{
    openUrl url
  }}}

  Example: 

  {{{
    openUrl "http://code.google.com/p/aost/"
  }}}

  * connectUrl(String url): use existing connect for the given url. The DSL format is:

  {{{
    connectUrl "http://code.google.com/p/aost/" 
  }}}

In addition, you can also write assertions in JUnit in DSL synatx, for example:
 
  {{{
    assertEquals rowNum, 8
  }}}

=== Tellurium Data Driven Testing ===

In Tellurium Data Driven Testing, more DSLs are defined. The first one is the way to define input data format using FieldSet, which represents the format of a line in the input file. 

{{{
//define file data format
fs.FieldSet(name: "GoogleBookList", description: "Google Book List") {
    Test(value: "checkBookList")
    Field(name: "category", description: "book category")
    Field(name: "size", type: "int", description: "google book list size ")
}
}}}

The above FieldSet includes multiple Fields and Test is special Field indicate the test name. To handle custom input data type, Tellurium provide the "typeHandler" DSL for the users to define a custom data type handler.

{{{
typeHandler "phoneNumber", "org.tellurium.test.PhoneNumberTypeHandler"
}}}

In addition to that, Tellurium defined the following DSLs to control the testing flow and compare the results:
  
  * includeModule: load a user defined Data Driven Module. For example,

  {{{
    includeModule  example.test.ddt.GoogleBookListModule.class
  }}}

  * loadData: load input data file. For example,

  {{{
    loadData "src/test/example/test/ddt/GoogleBookListCodeHostInput.txt"
  }}}

  * compareResult: compare the expected value with the actual result, for example:

  {{{
    compareResult "Java", category
  }}}

  * stepToEnd(): read each line from the input data stream and run the corresponding test until it reaches the end of the stream.

  * closeData(): close the input data stream and output the test results.

More details for Data Driven Testing DSLs can be found on [http://code.google.com/p/aost/wiki/DataDrivenTesting the Tellurium Data Driven Testing page]

== Testing Support ==

In the package org.tellurium.test, Tellurium provides three different ways to write Tellurium tests:

  * BaseTelluriumJavaTestCase and TelluriumJavaTestCase: They are both JUnit 4 test cases, i.e., they support the following JUnit 4 annotations:

    # @BeforeClass
    # @AfterClass
    # @Before
    # @After
    # @Test
    # @Ignore 

The only difference between the two is that the _TelluriumJavaTestCase_ comes with predefined @BeforeClass and @AfterClass methods to set up and tear down the connection to the Selenium server before tests begin and after all tests are done, respectively. If users want to include multiple test cases in one test suite, they should use _BaseTelluriumJavaTestCase_ so that all the test cases can share the same Selenium connection and do not need to set up and tear down connection for each class.  
  * Groovy Test Cases, i.e., to write Tellurium tests in groovy. Users can use _TelluriumGroovyTestCase_ for a single test and _TelluriumSuiteGroovyTestCase_ for a test suite.
  * Data Driven Testing. Tellurium provides the class _TelluriumDataDrivenModule_ for users to define data driven testing modules and the class _TelluriumDataDrivenTest_ to drive the actual tests. The details can be found on [http://code.google.com/p/aost/wiki/DataDrivenTesting the Data Driven Testing Wiki page].

Apart from the above, Tellurium also provides users the capability to write Tellurium tests and Tellurium data driven tests in pure DSL scripts. The _DslScriptExecutor_ is used to run the .dsl files. To make things easier for user, Tellurium comes with a shell script rundsl.sh for Unix or Linux systems and rundsl.bat for windows.


== Future Directions ==

Tellurium will continue evolving and more new features will be developed to make it more powerful and easier to use. We are considering the following new features for the next or future releases:

  # Add full _Maven_ 2 support for project building, testing, and artifact publishing.
  # Enhance _Data Driven Testing_ to add data readers for database, XML files, and CSV format files. Also need to consider testing multiple tests in a group and how to pass variables among them.
  # A _Firefox plugin_ will be developed to automatically generate UI modules for users. The idea is to provide the "select UI by click" capability in the plugin to select an area of UI. Then the plugin will extract the html source and use a special algorithm to generate Tellurium style UI modules using composite locators and group locating concept.  After that, the plugin will validate the generated UI module to make sure it is unique in the current DOM and output the results. 
  # Tellurium will provide a _Locator Query Language_ to get the locators of Ui objects by some search criteria such as their attributes and their relationship to each other, i.e., parent, child, and sibling. That is to say, Tellurium will be interactive with the DOM in runtime so as to be adaptive to dynamic web page. 
  # Provide _widget components_ for some popular JavaScript libraries or frameworks such as Extjs and Dojo.   
  # Add the _Automated Acceptance Testing_ feature to Tellurium. The basic idea is to setup a server and the user can use web browser to browse all available tests defined in the server registry. The user can select any test to run by typing in parameters required by the test and see the actual test result. 