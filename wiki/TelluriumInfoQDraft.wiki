#summary Tellurium InfoQ Article Draft.
#labels Phase-Design

<wiki:toc max_depth="5" />

= Background =

== Overview ==

Automated web testing has always been one of the hottest and most important topics in the software testing arena. With the rising popularity of Rich Internet applications (RIA) and Ajax-based web applications, the demand for automated web test tools has increased. With the advent of new web techniques such as RIA and Ajax, automated web testing tools must keep up with these changes in technology.

==Challenges==

As the ongoing trend of new web technologies is speeding up, the upcoming automated web testing tools need to be able to address the following challenges:

  * *Ajax for Dynamic Web Content*: Web applications have many benefits over desktop applications; For example, they have no installation and the application updates are instantaneous and easier to support. Ajax is a convenient way to update a part of the web page without refreshing the whole page. AJAX makes web applications richer and more user-friendly. The web context for an Ajax application is usually dynamic. For example, in a data grid, the data and number of rows keep changing at runtime. 
  * *Robust/Responsive to Changes*: A good automated web testing tool should be able to address the changes in the web context to some degree so that users do not need to keep updating the test code frequently.
  * *Easy to Maintain*: In an agile world, software development is based on iterations, and new features are added on in each sprint. The functional tests or user acceptance tests must be refactored and updated for the new features. The testing framework should provide the flexibility for users to maintain the test code very easily.
  * *Re-usability*: Many web applications use the same UI module for different parts of the application. The adoption of JavaScript frameworks such as Dojo and ExtJS increases the chance of using the same UI module for different web applications. A good testing framework should also be able to provide the re-usability of test modules.
  * *Expressiveness*: The testing framework should be able to provide users without much coding experience the ability to easily write test code or scripts in a familiar way, like by using a domain specific language (DSL).
  * *JavaScript Events*: JavaScript is everywhere on the web today. Many web applications are JavaScript heavy. To test JavaScript, the automated testing framework should be able to trigger JavaScript events in a very convenient way.

== Existing Open Source Automated Web Testing Frameworks ==

=== Selenium ===

The *Selenium* web testing framework is one of the most popular open source automated web testing framework. It's a ground-breaking framework that offers many unique features and advantages such as browser based testing, Selenium Grid, and "record and replay" of user interactions with the Selenium IDE. As a pioneer framework, it inevitably has its shortcomings.

*Drawback* <br>
One major drawback is that it only focus on individual UI elements such as links and buttons. As a result, it is difficult to address dynamic web content in Selenium. "Record and replay" does make it much easier for users, especially non-developers, to create test cases. However, it has the drawback of being difficult to refactor and maintain. Other downsides include the coupling of UI elements and test code, being overly verbose, and being fragile and unresponsive to dynamic web changes. 

Take the following Selenium test code as an example:

{{{
   setUp("http://www.google.com/", "*chrome");
   selenium.open("/");
   selenium.type("q", "Selenium test");
   selenium.click("//input[@value='Google Search' and @type='button']");
}}}

*  Do you know what UI module the above code is testing?<br>
*  What does the locator _q_ mean here?<br>
*  What if the XPath {{{//input[@value='Google Search' and @type='button']}}} becomes  invalid due to changes on the web?<br>

Most likely, you have to go through the test code to locate the lines you need to update. What if you have tens or hundreds of locators in your test code? Creating the test code using Selenium IDE is easy, but it is difficult to generalize and refactor. Refactoring is a much more tedious and painful procedure than regenerating new test code from scratch because of the use of hard-coded locators and the coupling of locators with test code. Maintaining the code is a hassle because the test code is not structured. Since Selenium only focuses on individual UI elements, it is difficult to adjust to changes on the web and to address a dynamic web context. 

=== Canoo ===

*Canoo* web test is another popular open source tool for automated testing of web applications. However, it also focuses on individual UI elements and thus it suffers shortcomings similar to those of Selenium, such as coupling the test code with the UI. Here is some sample test code:

{{{
    webtest("check that WebTest is Google's top 'WebTest' result"){
       invoke "http://www.google.com", description: "Go to Google"
       verifyTitle "Google"
       setInputField name: "q", value: "WebTest"
       clickButton "I'm Feeling Lucky"
       verifyTitle "Canoo WebTest"
    }
}}}

=== Twill ===

*Twill* is a simple scripting language that allows users to browse the Web from a command-line interface. It uses links, forms, cookies, and most standard Web features. It also deals with individual UI elements but does not support javascript, and HTML needs to be parsed interactively. Twill only supports Python, which makes it fairly inconvenient for practical web applications.


= A New Approach for Web Testing =

== Motivations ==

Since the existing automated testing frameworks do not address the challenges and problems very well, there has been an real need for new automated testing framework to address them with the following motivations:

  * Robust/responsive to changes; allow changes to be localized
  * Address dynamic web contexts such as JavaScript events and Ajax 
  * Easy to refactor and maintain
  * Modular; test modules are reusable 
  * Expressive and easy to use

Our proposal is the *Tellurium Automated Testing Framework*, or _Tellurium_ for short. 

== Tellurium Overview ==
 
The Tellurium Automated Testing Framework (Tellurium) is an open source automated testing framework for web applications that addresses the challenges and problems in web testing. 

The majority of existing web testing tools/frameworks focus on individual UI elements such as links and buttons. Tellurium takes a new approach for automated web testing using the concept of the _UI module_.  The UI module is a collection of UI elements grouped together. Usually, the UI module represents a composite UI object in the format of nested basic UI elements. For example, the Google search UI module can be expressed as follows:

{{{
ui.Container(uid: "GoogleSearchModule", clocator: [tag: "td"], group: "true"){
   InputBox(uid: "Input", clocator: [title: "Google Search"])
   SubmitButton(uid: "Search", clocator: [name: "btnG", value: "Google Search"])
   SubmitButton(uid: "ImFeelingLucky", clocator: [value: "I'm Feeling Lucky"])
}
}}}
 
To understand the above definition, we need to introduce couple Tellurium concepts first.

The first concept is Tellurium UI Object. Tellurium defines a set of Java UI objects, such as InputButton, Selector, List, Table, and Frame, which users can use directly. The basic UI Object works as the base class for all UI objects and it includes the following attributes:

  # uid: UI object's identifier
  # namespace: for future extension
  # locator: the locator of the UI object, could be a base locator or a composite locator
  # respond: the JavaScript events the UI object can respond to. The value is a list.

All UI Objects inherit the above attributes and methods and many UI objects have their extra attributes and methods. For example, the List object has one special attribute "separator", which is used to indicate the tag used to separate different List child UI elements. 
 
Tellurium supports two types of locators: _base locator_ and _composite locator_. The _base locator_ is a relative XPath. The _composite locator_, denoted by "clocator", specifies a set of attributes for the UI object and the actual locator will be derived automatically by Tellurium at runtime.   

The Composite Locator is defined as follows:

{{{
class CompositeLocator {
    String header
    String tag
    String text
    String trailer
    def position
    boolean direct
    Map<String, String> attributes = [:]
}
}}}

To use the composite locator, you need to use "clocator" with a map as its value. For example:

{{{
clocator: [key1: value1, key2: value2, ...]
}}}

The default attributes include "header", "tag", "text", "trailer", "position", and "direct". They are all optional. The "direct" attribute specifies whether this UI object is a direct child of its parent UI, and the default value is "false".

If you have additional attributes, you can define them in the same way as the default attributes, for example:

{{{
clocator: [tag: "div", value: "Tellurium home"]
}}}

In the above Tellurium UI module, the "GoogleSearchModule" Container includes a "group" attribute. What does the attribute _group_ mean? The group attribute is a flag for the Group Locating Concept. Usually, the XPath generated by Selenium IDE, XPather, or other tools is a single path to the target node such as:

{{{
//div/table[@id='something']/div[2]/div[3]/div[1]/div[6]
}}}

No sibling node's information is used here. What is wrong with this? The XPath depends too much on information from nodes far away from the target node. In Tellurium, we try to localize the information and reduce this dependency by using sibling information or local information. For example, in the above google UI module, the group locating concept will try to find the "td" tag with its children as "Input", "Search" button, and
"ImFeelingLucky" button. In this way, we can reduce the dependencies of the UI elements inside a UI module on external UI elements to make the UI definition more robust. 
  
The Tellurium framework architecture is shown as in Figure 1.

http://tellurium-users.googlegroups.com/web/TelluriumUMLSystemDiagram.png?gda=0H5Erk8AAAD5mhXrH3CK0rVx4StVj0LYqZdbCnRI6ajcTiPCMsvamYLLytm0aso8Q_xG6LhygcwA_EMlVsbw_MCr_P40NSWJnHMhSp_qzSgvndaTPyHVdA&gsc=cq8RLwsAAADwIKTw30t0VbWQq6vz0Jcq

Figure 1. Tellurium Architecture.

The DSL parser consists of the DSL Object Parser, Object Builders, and the Object Registry. The DSL object parser will parse the DSL object definition recursively and use object builders to build the objects on the fly. An object builder registry is designed to hold all predefined UI object builders in the Tellurium framework, and the DSL object parser will look at the builder registry to find the appropriate builders. Since the registry is a hash map, you can override a builder with a new one using the same UI name. Users can also add their customer builders into the builder registry.
 
The DSL object definition always comes first with a container type object. An object registry (a hash map) is used to store all top level UI Objects. As a result, for each DSL object definition, the top object ids must be unique in the DslContext. The object registry will be used by the framework to search objects by their ids and fetch objects for different actions.

The Object Locator Mapping (OLM) is the core of the Tellurium framework and it includes UI ID mapping, XPath builder, jQuery selector builder, and Group Locating. 

The UI ID supports nested objects. For example, "menu.wiki" stands for a URL Link "wiki" inside a container called "menu". The UI ID also supports one-dimensional and two-dimensional indices for table and list. For example, {{{"main.table[2][3]"}}} stands for the UI object of the 2nd row and the 3rd column of a table inside the container "main".

XPath builder can build the XPath from the composite locator, i.e., a set of attributes. Starting with version 0.6.0, Tellurium supports jQuery selectors to address the problem of poor performance of XPath in Internet Explorer. jQuery selector builders are used to automatically generate jQuery selectors instead of XPath with the following advantages:
  * Faster performance in IE.
  * Leverage the power of jQuery to retrieve bulk data from the web by testing with one method call.
  * New features provided by jQuery attribute selectors.
 
The Group Locating Concept (GLC) exploits the group information inside a collection of UI objects to help us find the locator of the collection of UI objects. 

The Eventhandler will handle all events like "click", "type", "select", and so on. The Data Accessor is used to fetch data or UI status from the DOM. The dispatcher will delegate all calls it receives from the Eventhandler and the data accessor to the connector, which connects to the Tellurium engine. The dispatcher is designed to decouple the rest of the Tellurium framework from the base test driving engine so that we can switch to a different test driving engine by simply changing the dispatcher logic.

Tellurium evolved out of Selenium, but the UI testing approach is completely different. For example, Tellurium is not a "record and replay" style framework, and it enforces the separation of UI modules from test code, making refactoring easy. For example, once you defined the Google Search UI module shown above, you can write your test code as follows:

{{{
type "GoogleSearchModule.Input", "Tellurium test"
click "GoogleSearchModule.Search"
}}} 

== How Challenges and Problems are addressed in Tellurium ? ==
 
First of all, Tellurium does not use "record and replay." Instead, it uses the Tellurium Firefox plugin Trump to generate the UI module (not test code) for you. Then you need to create your test code based on the UI module. In this way, the UI and the test code are decoupled. The structured test code in Tellurium makes it much easier to refactor and maintain the code.

The composite locator uses UI element attributes to define the UI, and the actual locator (e.g. xpath or jQuery selector) will be generated at runtime. Any updates to the composite locator will lead to different runtime locators, and the changes inside the UI module are localized. The Group locating is used to remove the dependency of the UI objects from external UI elements (i.e. external UI changes will not affect the current UI module for most cases) so that your test code is robust and responsive to changes up to a certain level.

Tellurium uses the _respond_ attribute in a UI object for you to specify JavaScript events, and the rest will be handled automatically by the framework itself. UI templates are a powerful feature in Tellurium used to represent many identical UI elements or a dynamic size of different UI elements at runtime, which are extremely useful in testing dynamic web contexts such as a data grid. The _Option_ UI object is designed to automatically address dynamic web contexts with multiple possible UI patterns.

Re-usability is achieved by the UI module when working within one application and by Tellurium Widgets when working across different web applications. With the Domain Specific Language (DSL) in Tellurium you can define UI modules and write test code in a very expressive way. Tellurium also provides you the flexibility to write test code in Java, Groovy, or pure DSL scripts.

In the subsequent sections, we will give a brief introduction of Tellurium, including its architecture and main concepts. Then we will introduce the Tellurium sub-projects and how to obtain and use Tellurium. This will be followed by a detailed tutorial on how to create Tellurium test cases with code samples. Finally, we will summarize and conclude this article with our plans for the future.

= Summary =

Tellurium introduces a new approach to test web applications based on UI modules. The UI module makes it possible to build locators for UI elements at runtime.  First, this makes Tellurium robust and responsive to changes from internal UI elements.  Second, the UI module makes Tellurium expressive.  A UI element can be referred to simply by appending the names (uid) along the path to the specific element. This also enables Tellurium's _Group Locating_ feature, making composite objects reusable, and addressing dynamic web pages.

Tellurium does _Object to Locator Mapping (OLM)_ automatically at run time so that UI objects can be defined simply by their attributes using _Composite Locators_. Tellurium uses the Group Locating Concept (GLC) to exploit information inside a collection of UI components so that locators can find their elements.  It also defines a set of DSLs for web testing.  Furthermore, Tellurium uses UI templates to define sets of dynamic UI elements at runtime.  As a result, Tellurium is robust, expressive, flexible, reusable, and easy to maintain.


= Acknowledgments =

Thanks to Ramesh Ramamurthy for editing this article.

= Resources =

  * [http://code.google.com/p/aost/ Tellurium Project website] 
  * [http://groups.google.com/group/tellurium-users Tellurium User Group]
  * [http://code.google.com/p/aost/wiki/UserGuide Tellurium User Guide]
  * [http://telluriumdoc.googlecode.com/files/TelluriumUserGuide.Draft.pdf Tellurium User Guide PDF draft].
  * [http://code.google.com/p/aost/wiki/TrUMP Tellurium UI Model Firefox Plugin (TrUMP) 0.1.0]
  * [http://seleniumhq.org/ Selenium]
  * [http://webtest.canoo.com Canoo WebTest]
  * [http://twill.idyll.org/ Twill]  
  * [http://groovy.codehaus.org/ Groovy]
  * [http://jquery.com/ JQuery]
  * [http://www.junit.org/ JUnit] 
  * [http://testng.org/doc/documentation-main.html TestNG]
  * [http://htmlunit.sourceforge.net HtmlUnit]