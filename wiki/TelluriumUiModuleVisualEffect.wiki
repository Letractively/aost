#summary Tellurium UI Module Visual Effect.
#labels Phase-Implementation,Phase-Support

= Introduction =

Have you ever thought of seeing the actual UI on the web page under testing? Tellurium 0.7.0 provides a cool feature to show this visual effect. 

Tellurium provides a _show_ command to display the UI module that you defined on the actual web page.

{{{
    public show(String uid, int delay);
}}}

where delay is in milliseconds. In the meanwhile, Tellurium Core exposes the following two methods for users to start showing UI and clean up UI.

{{{
   public void startShow(String uid);

   public void endShow(String uid);
}}}


= How it Works ? =

Under the hood, Tellurium Engine does the following steps.

== Build a Snapshot Tree ==

The Snapshot Tree, or STree in short, is different from the UI module. The UI module defines how the UI looks like. Even [http://code.google.com/p/aost/wiki/SantaUiModuleGroupLocatingAlgorithm the UI module group locating algorithm - Santa] only locates the cachable UI elements and leaves out the dynamic elements. The snapshot tree, however, needs to include every UI elements inside the UI module. For example, the following Google Book List UI module is very simple.

{{{
    ui.Container(uid: "GoogleBooksList", clocator: [tag: "table", id: "hp_table"]) {
      List(uid: "subcategory", clocator: [tag: "td", class: "sidebar"], separator: "div") {
        Container(uid: "all") {
          TextBox(uid: "title", clocator: [tag: "div", class: "sub_cat_title"])
          List(uid: "links", separator: "p") {
            UrlLink(uid: "all", clocator: [:])
          }
        }
      }
    }
}}} 

But its STree may include many book categories and books.

A snapshot tree includes the following different types of nodes.

=== SNode ===

SNode can present a non-container type UI object, i.e., UI element without chidlren.

{{{
var UiSNode = Class.extend({
    init: function() {

        //parent's rid
        this.pid = null;

        //rid, runtime id
        this.rid = null;

        //point to its parent in the UI SNAPSHOT tree
        this.parent = null;

        //UI object, which is defined in the UI module, reference
        this.objRef = null;

        //DOM reference
        this.domRef = null;
    },
...
}
}}}

=== CNode ===  

CNode is a container type node and it has children.

{{{

var UiCNode = UiSNode.extend({
    init: function(){
        this._super();
        //children nodes, regular UI Nodes
        this.components = new Hashtable();
    },

...
}
}}}

=== TNode ===

The TNode stands for a table with headers, footers, and bodies. 
{{{
var UiTNode = UiSNode.extend({
    init: function(){
        this._super();

        //header nodes with key as the template UID and value as the UI template Avatar
        this.headers = new Hashtable();

        //footer node with key as the template UID and value as the UI template Avatar
        this.footers = new Hashtable();

        //body nodes with key as the template UID and value as the UI template Avatar
        this.components = new Hashtable();
    },
...
}}}

Finally, the Snapshot tree is defined as

{{{
function UiSTree(){
    //the root node
    this.root = null;

    //the reference point to the UI module that the UI Snapshot tree is derived
    this.uimRef = null;
}
}}}

The STree build process is quite complicated. The basic idea is to use the cached DOM references in a cached UI module and use some Santa algorithm functionalities to find dynamic UI elements. 

== STree Visitors ==

The STree defines a traverse method, so that we can pass in different visitor to work on each individual UI element for different purpose.

{{{
UiSTree.prototype.traverse = function(context, visitor){
    if(this.root != null){
        this.root.traverse(context, visitor);
    }
};

var UiSNode = Class.extend({
...
    traverse: function(context, visitor){
        visitor.visit(context, this);
    },
...
}

}}}

The STree Visitor class is defined as

{{{
var STreeVisitor = Class.extend({
    init: function(){

    },

    visit: function(context, snode){

    }
});
}}}
  
Tellurium Engine also defines a Visitor Chain to pass in multiple visitors.

{{{
var STreeChainVisitor = Class.extend({
    init: function(){
        this.chain = new Array();
    },

    removeAll: function(){
        this.chain = new Array();
    },

    addVisitor: function(visitor){
        this.chain.push(visitor);
    },

    size: function(){
        return this.chain.length;
    },

    visit: function(context, snode){
        for(var i=0; i<this.chain.length; i++){
            this.chain[i].visit(context, snode);
        }
    }
});
}}}

For the show UI method, the following two Visitors are designed.

=== Outline Visitor ===

The outline visitor is used to mark the UI elements inside a UI module to differentiate the UI elements in the UI module from other UI elements.

The outline visitor include a visitor to outline an element.

{{{

var UiOutlineVisitor = STreeVisitor.extend({
    
    visit: function(context, snode){
        var elem = snode.domRef;
        teJQuery(elem).data("originalOutline", elem.style.outline);
        elem.style.outline = tellurium.outlines.getDefaultOutline();
    }
});
}}}

and a cleaner to restore the UI to the original one.

{{{
var UiOutlineCleaner = STreeVisitor.extend({
    visit: function(context, snode){
        var elem = snode.domRef;
        var $elem = teJQuery(elem);
        var outline = $elem.data("originalOutline");
        elem.style.outline = outline;
        $elem.removeData("originalOutline");
    } 
});

}}}

=== Tooltip Visitor ===

The Tooltip visitor is used to show the full UID of an element in a tooltip fasion. Tellurium exploited [http://craigsworks.com/projects/simpletip/ jQuery Simpletip plugin] to achieve this visual effect. In additional to that, the tooltip visitor also changes the outlines of the selected UI elements.

Like the outline visitor, the tooltip visitor include a visitor to set up the visual effects,

{{{
var UiSimpleTipVisitor = STreeVisitor.extend({

    visit: function(context, snode) {
        var elem = snode.domRef;
        var frid = snode.getFullRid();

        var $elem = teJQuery(elem);
        $elem.data("level", snode.getLevel());
        $elem.simpletip({
            // Configuration properties
            onShow: function() {
                var $parent = this.getParent();
                var parent = $parent.get(0);
                var level = $parent.data("level");

                var outline = $parent.data("outline");
                if(outline == undefined || outline == null){
                    $parent.data("outline", parent.style.outline);
                }

                parent.style.outline = tellurium.outlines.getOutline(level);
            },
            onHide: function() {
                var $parent = this.getParent();
                var parent = $parent.get(0);

                parent.style.outline = $parent.data("outline");
            },

            content: convertRidToUid(frid),
            fixed: false
        });
    }
});
}}}

and a cleaner to remove the visual effects.

{{{
var UiSimpleTipCleaner = STreeVisitor.extend({
    visit: function(context, snode){
        var elem = snode.domRef;
        var frid = snode.getFullRid();

        var $elem = teJQuery(elem);
        $elem.removeData("outline");
        $elem.removeData("level");
        $elem.find("~ div.teengine.tooltip").remove();
    }
});
}}}
