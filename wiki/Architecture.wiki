#labels Featured,Phase-Design,Phase-Implementation
= Tellurium Architecture =

The Tellurium framework Architecture is shown as in Figure 1.

http://tellurium-users.googlegroups.com/web/tellurium.architecture.png?gda=1NP4x0sAAAAFkHkURP2WlgYU-UhtQDFJganRixm7ZVzXjIzQXs5CXWG1qiJ7UbTIup-M2XPURDThcsDHHqasJHRvnmR6jbzWzHqwysTvAgdPZHbdH4XvXg&gsc=26Y4eBYAAAAkGgIQNXlg3kIha08SEZtI9pmI1qD38G08ONb6YfjJaQ

Figure 1. Tellurium Architecture.

The architecture consists of three parts, one is the Selenium Server, on which our Tellurium framework builds, the Tellurium framework, and user defined Java test cases or .dsl pure DSL test scripts. Since Java Test cases and pure DSL test scripts have been described in [http://code.google.com/p/aost/wiki/Introduction Introduction] and [http://code.google.com/p/aost/wiki/Tutorial Tutorial], we only focus on the Tellurium framework.

== The Tellurium Framework ==

The Tellurium Framework is based on the DslContext, which defines all DSLs we can use for Tellurium. We can further divide the Tellurium Framework into Four parts.

=== UI Object Parser ===

This parts consists of the DSL Object Parser, Object Builders, and the Object Registry.

Thanks to Groovyâ€™s builder pattern, we can define UI object expressively and in a nested fashion. The DSL object parser will parse the DSL object definition recursively and use object builders to build the objects on the fly. An object builder registry is designed to hold all predefined UI object builders in the Tellurium framework and the DSL object parser will look at the builder registry to find the appropriate builders. Since the registry is a hash map, you can override a builder with a new one using the same UI name. Users can also add their customer builders into the builder registry.
 
The DSL object definition always comes first with a container type object. An object registry (A hash map) is used to stored all top level UI Objects. As a result, for each DSL object definition, the top object ids must be unique in the DslContext. The object registry will be used by the framework to search objects by their ids and fetch objects for different actions.

=== Object Locator Mapping ===

The Object Locator Mapping (OLM) is the core of the Tellurium framework and it includes UI ID mapping, XPath builder, Locator Processor, and Group Locating. The UI ID supports nested object, for example, "menu.wiki" stands for a URL Link "wiki" inside a container called "menu". The UI ID also supports one dimension and two dimension index for table and list. For example, {{{"main.table[2][3]"}}} stands the UI object of the 2nd row and the 3rd column of a table inside the container "main".

XPath builder can build the XPath from relative XPaths or from attributes. The locator processor converts the locator information in the UI object to the XPath. The Group Locating Concept (GLC) is to exploit the group information in side a collection of UI objects to help us find the locator of the collection of UI objects. 

=== Event and Data Handling ===

The Eventhandler in this part will handle all events like "click", "type", "select", and so on. The Data Accessor is used to fetch data or UI status from the DOM. The dispatcher will delegate all calls it receives from the Eventhandler and the data accessor to the Selenium Client, which will connect to the Selenium Server. The dispatcher is designed to decouple the rest of the Tellurium framework with the Selenium framework so that we can simply change the dispatcher logic to delegate all calls to other underneath UI test frameworks if we want to switch Tellurium not to use the Selenium framework someday.  

=== Test Support ===

The Test includes DSL script executor, Tellurium Java Test Case or Test Suite, and Tools that can help us to create Tellurium tests.

== HOW Tellurium works ==

Basically, there are two parts for the Tellurium framework. The first part is to define UI objects and the second part is working on the UI objects like firing events and getting data or status from the DOM.

=== The "Define UI" Operation ===

The "Define UI" operation can be demonstrated in the following sequence diagram:

http://tellurium-users.googlegroups.com/web/aost_sequence_defineui.png?gda=ut9Dd0sAAAAFkHkURP2WlgYU-UhtQDFJfFjOBE5aGMxp_hs9PNxhIGG1qiJ7UbTIup-M2XPURDRalx4T6cOZyoocLzTpPNoT-xRs6kTo9_1MlJqhLlX0VQ&gsc=26Y4eBYAAAAkGgIQNXlg3kIha08SEZtI9pmI1qD38G08ONb6YfjJaQ

Figure 2. The sequence diagram for "DefineUI"

When the Test Case calls "DefineUI", the DslContext will call the Dsl Object Parser to parse the UI definition. The Parser will look at each node and call the appropriate builders to build UI objects. The top level object will be stored in the UI Object registry so that we can search for the UI object by UI Id.
 

Note that the processing of the pure DSL script is the same.
 
=== The Action Operation ===

The processing of actions such as clicking on an UI object is illustrated in Figure 3:

http://tellurium-users.googlegroups.com/web/aost_sequence_click.png?gda=EuRP9kgAAAAFkHkURP2WlgYU-UhtQDFJfFjOBE5aGMxp_hs9PNxhIGG1qiJ7UbTIup-M2XPURDSpnGSpq9shp5Nom0pUQ_VQjwc8kMSHiCJV0Te5P6rKfA&gsc=26Y4eBYAAAAkGgIQNXlg3kIha08SEZtI9pmI1qD38G08ONb6YfjJaQ

Figure 3. The sequence diagram for the "click" action

The action processing includes following two parts. 

==== Search For the UI Object ===
First, the DslContext will create a WorkflowContext so that we can pass meta data such the relative xpath inside it. Then, we start to look at the UI object registry by calling the walkTo method. Remember, the UI object registry hold all the top level UI objects. If we can find the top level UI object, we can recursively call the WalkTo method on the next UI object until we find the UI Object matching the UI id, or we cannot find the UI object by UI Id. 

During the walkTo method calls, we also start to aggregate relative xpaths into the reference xpath to the next UI object.

==== Construct the Locator and Fire the Event ====

If the UI Object is found, we fire the action such as "click" on the UI object and pass in a closure which can access the eventhandler, the WorkflowContext, and the LocatorProcessor. The WorkflowContext includes the reference xpath to the UI object and the LocatorProcessor can generate the xpath of the UI object itself. In this way, the runtime locator is constructed. 

Then, the UI object will call the Eventhandler to fire the click event. The event will pass all the way down from the dispatcher and Selenium Client to the Selenium Server.
 
=== The Data Access Operation ===

The data access operation is very much like the action operation shown in Figure 3 and the only difference is that the Data Accessor will replace the Eventhandler. But be aware, for some data access, there is no UI locator associated with it. For example, you want to get the current DOM html presentation. In this case, you just call the Data Accessor directly.

== Tellurium Data Driven Testing ==

Data driven testing is a new feature in Tellurium 0.4.0. The system diagram is shown in Figure 4. 

http://tellurium-users.googlegroups.com/web/tellurium.data.driven.jpg?gda=_1pLcEsAAACjbvY1r0rMz6MRbvC-tSqoysMSW8LOE1CninSxbdL8I2ArWKkWH9uGyxs8H0RkPsAdq11J_EY5XIrmvbkBlJwJBkXa90K8pT5MNmkW1w_4BQ&gsc=httiOwsAAAAISLBF63vg48UkWer0gDjz

Figure 4. System Diagram for Tellurium Data Driven Testing

The tellurium data driven test consists of three main parts, i.e., Data Provider, TelluriumDataDrivenModule, and TelluriumDataDrivenTest. 

=== Data Provider ===

The data provider is the responsible for reading data from input stream and converting data to Java variables in data driven tests. As shown in Figure 4, the data reader reads data from the input stream line by line and turns the results to the FieldSet-to-Object mapper, which maps the data to the appropriate FieldSet. Then, the varaiable binder binds the data to variables defined in the test according to the FieldSet defintion. 

=== TelluriumDataDrivenModule ===

TelluriumDataDrivenModule is used to define modules, where users can define Ui Modules, FieldSets, and tests as shown in Figure 5.

http://tellurium-users.googlegroups.com/web/tellurium.ddt.sequence.module.jpg?gda=JfGNJFMAAACjbvY1r0rMz6MRbvC-tSqoysMSW8LOE1CninSxbdL8I2vnDwbH8gszdz4ehPdDgG9Ob8FqU5PL6F5asAt-s2HZMrYifh3RmGHD4v9PaZfDexVi73jmlo822J6Z5KZsXFo&gsc=httiOwsAAAAISLBF63vg48UkWer0gDjz

Figure 5. The Sequence Diagram of defineModule in TelluriumDataDrivenModule

=== TelluriumDataDrivenTest ===
 
TelluriumDataDrivenTest is where users actually run the data driven test. Users can define different test modules and use the "loadModule" command to include the modules in. Then, users can use "loadData" to read in data from input stream, for example, from a file. Users can also use "useData" to read in data from a String defined in the test file. After that, use the "stepToEnd" command to automatically read in data line by line and run the appropriate test specified in the data file. Finally, the test results are recorded and converted to output. The process is shown in Figure 6.
 
http://tellurium-users.googlegroups.com/web/ddt_test_sequence.jpg?gda=M_GJLEcAAACjbvY1r0rMz6MRbvC-tSqoOiEqD7Mi6G5cLzJ9CIeLB-TPT63Q-1cxaIO0tQmR15XiNflBnS90ecEO3zvz3dEqeV4duv6pDMGhhhZdjQlNAw&gsc=httiOwsAAAAISLBF63vg48UkWer0gDjz

Figure 6. The Sequence Diagram of testDataDriven in TelluriumDataDrivenTest