#summary Top Ten Cool Features in Tellurium.
#labels Phase-Implementation,Phase-Support
<wiki:toc max_depth="3" />

== UI Module ==

UI Module is the key concept of Tellurium. What is UI module? UI module is a collection of UI elements you group them together. Usually, the UI module represents a composite UI object in the format of nested basic UI elements. For example, the download search module in Tellurium project site is defined as follows,

{{{
ui.Form(uid: "downloadSearch", clocator: [action: "list", method: "get"], group: "true") {
   Selector(uid: "downloadType", clocator: [name: "can", id: "can"])
   InputBox(uid: "searchBox", clocator: [name: "q"])
   SubmitButton(uid: "searchButton", clocator: [value: "Search"])
}
}}}

Be aware that in most case the UI elements inside the composite UI object have relationship to each other. In the DOM structure, they should be on the same sub-tree with the top UI element as the parent. The exception is the [http://code.google.com/p/aost/wiki/LogicalContainer Logical Container].

[http://code.google.com/p/aost/wiki/Tellurium_A_New_Approach_for_Web_Test Why UI module concept is so important]? It is the foundation that Tellurium built on. First, UI module makes it possible to build UI elements' locator at runtime, which also makes Tellurium robust to changes in internal UI elements. Second, UI module makes Tellurium expressive. You can refer a UI element by simply appending the names along the path to the specific element. For example, in the Tellurium download search module, you can refer the Selector element as "downloadSearch.downloadType". Other reasons include 
  * UI module makes Group Locating possible. 
  * UI module makes composite objects reusable in term of widget objects. 
  * UI module will make Tellurium move to a different future path from Selenium to more efficiently support UI Module.

== jQuery Selector ==

Starting with version 0.6.0, Tellurium will support a [http://code.google.com/p/aost/wiki/TelluriumjQuerySelector jQuery selector] to address the problem of poor performance of xpath in Internet Explorer. Auto-generating jQuery instead of xpath has the following advantages:
  * Faster performance in IE.
  * We are able to use the power of jQuery to call methods on jQuery collections to retrieve bulk data.
  * Tellurium jQuery selector supports the jQuery attribute selectors such as _[attribute!=value]_, _[attribute^=value]_, _[attribute$=value]_, and _[attribute*=value]_.

To use jQuery selector, simply call 

{{{
useJQuerySelector()
}}} 

in you code. To switch back to XPath locator, you should call

{{{
disableJQuerySelector()
}}}

Be aware that the UI module is agnostic to the locate strategy you choose and thus, you do not need to change anything in your test code. 

Our Benchmark test results show that:

  # jQuery selector is as fast as Ajaxslt XPath and Javascript XPath in Firefox 3.
  # jQuery selector is much faster in IE 7 than the two XPath libraries
  # jQuery selector uses only one method call to get back data for all table cells and thus it is the fastest one for bulk data access.

[http://code.google.com/p/aost/wiki/jQuerySelectorCache jQuery cache] is a mechanism to further improve the speed by reusing the found DOM reference for a given jQuery selector. Our benchmark results show that the jQuery cache could improve the speed by up to 14% over the regular jQuery selector and over 27% for some extreme cases.

== Group Locating ==

In Tellurium UI module, you often see the "group" attribute, for example,

{{{
ui.Container(uid: "google_start_page", clocator: [tag: "td"], group: "true"){
  InputBox(uid: "searchbox", clocator: [title: "Google Search"])
  SubmitButton(uid: "googlesearch", clocator: [name: "btnG", value: "Google Search"])
  SubmitButton(uid: "Imfeelinglucky", clocator: [value: "I'm Feeling Lucky"])
}
}}}

What does the attribute "group" mean? The group attribute is a flag for the Group Locating Concept. Usually, the XPath generated by Selenium IDE, XPather, or other tools is a single
path to the target node such as

{{{
//div/table[@id='something']/div[2]/div[3]/div[1]/div[6]
}}}

No sibling node's information is used here. What is wrong with this? The xpath depends on too much information on nodes away from the target node. In Tellurium, we try to localize the information and reduce the dependency by using sibling information or local information. For example, in the above google UI module, the group locating concept will try to find the "td" tag with its children as "InputBox", "googlesearch" button, and
"Imfellingluck" button. In this way, we can reduce the dependencies of the UI elements inside a UI module on external UI elements to make the UI definition more robust. 

== UI Templates ==

Tellurium UI templates are used for two purposes:

  # There are many identical UI elements, you can use one template to represent them
  # There are variable/dynamic size of UI elements at runtime, you know the patterns, but not the size. Here, template is also a perfect fit for it.

More specifically, Table and List are two Tellurium objects that can define UI templates. Table defines two dimensional UI template and List is for one dimensional. Template has
special UIDs such as "2", "all", or "row: 1, column: 2". 
Let us look at use case (1), we have the following HTML source

{{{
      <ul class="a">
        <li>
            <A HREF="site?tcid=a"
               class="b">AA
            </A>
        </li>
        <li>
            <A HREF="site?tcid=b"
               class="b">BB
            </A>
        </li>
        <li>
            <A HREF="site?;tcid=c"
               class="b">CC
            </A>
        </li>
        <li>
            <A HREF="site?tcid=d"
               class="b">DD
            </A>
        </li>
        <li>
            <A HREF="site?tcid=e"
               class="b">EE
            </A>
        </li>
        <li>
            <A HREF="site?tcid=f"
               class="b">FF
            </A>
        </li>
    </ul>
}}}

You have six links there. Without templates, you have to put six UrlLink objects in the UI module. Look at how simple by using the template

{{{
ui.List(uid: "list", clocator: [tag: "ul", class: "a"], separator:"li")
{
    UrlLink(uid: "all", clocator: [class: "b"])
}
}}}


For use case (2), the common application is data grid. Look at the "issueResult" data grid at our Tellurium Issues page,

{{{
ui.Table(uid: "issueResult", clocator: [id: "resultstable", class: "results"], group: "true") {
    TextBox(uid: "header: 1",  clocator: [:])
    UrlLink(uid: "header: 2",  clocator: [text: "%%ID"])
    UrlLink(uid: "header: 3",  clocator: [text: "%%Type"])
    UrlLink(uid: "header: 4",  clocator: [text: "%%Status"])
    UrlLink(uid: "header: 5",  clocator: [text: "%%Priority"])
    UrlLink(uid: "header: 6",  clocator: [text: "%%Milestone"])
    UrlLink(uid: "header: 7",  clocator: [text: "%%Owner"])
    UrlLink(uid: "header: 9",  clocator: [text: "%%Summary + Labels"])
    UrlLink(uid: "header: 10", clocator: [text: "%%..."])

    //define table elements
    //for the border column
    TextBox(uid: "row: *, column: 1", clocator: [:])
    //For the rest, just UrlLink
    UrlLink(uid: "all", clocator: [:])
}
}}}

Aren't the definitions very simple and cool? 

You may wonder how to use the templates if you have multiple templates such the "issueResult" table as shown above. The rule to apply the templates is "specific one first, general one later". More details can be found at [http://groups.google.com/group/tellurium-users/browse_thread/thread/8e011ff9f1f71393#  The power of Tellurium UI templates].

== Javascript Events ==

Most web applications include Javascripts and thus, the web testing framework must be able to handle the Javascript events. What we really care is to fire the appropriate events to trigger the event handlers.

Selenium has already provided methods to generate events such as

{{{
fireEvent(locator, "blur")
fireEvent(locator, "focus")
mouseOut(locator)
mouseOver(locator)
}}}

Tellurium was born with Javascript events in mind since it was initially designed to test applications written using the DOJO javascript framework. For example, we have the following radio button,

{{{
<input type='radio' name='mas_address_key' value='5779' onClick='SetAddress_5779()'>
}}}

Although we can define the radio button as follows,

{{{
RadioButton(uid: "billing", clocator: [name: 'mas_address_key', value: '5779'])
}}}

but it will not be able to respond to the click event since the Tellurium RadioButton only have the "check" and "uncheck" actions, which is enough for the normal case. As a result, no "click" event/action will be generated during the testing. How to address this problem then?

Tellurium added the [http://groups.google.com/group/tellurium-users/browse_thread/thread/93fbae75a6d88624 "respond" attribute] to Tellurium UI objects and the "respond" attribute could be used to define whatever events you want the UI object to respond to. Still take the above radio button as an example, the new Radio Button can be defined as,

{{{
 ui.Container(uid: "form", clocator: [whatever]){
     RadioButton(uid: "billing", clocator: [name: 'mas_address_key', value: '5779'], respond: ["click"])
 }
}}}

That is to say, you can issue the following command: 

{{{
  click "form.billing"
}}}

Even the RadioButton does not have the _click_ method defined by default, it is still able to dynamically add the _click_ method at runtime and call it.

A more general example is as follows,

{{{
 InputBox(uid: "searchbox", clocator: [title: "Google Search"], respond: ["click", "focus", "mouseOver", "mouseOut", "blur"])
}}}

Do not worry about the event order for the respond attribute, Tellurium will automatically re-order the events and then process them appropriately for you.
 
== Tellurium Widgets ==



== Reconfigurable ==

== Built-in Support for JUnit and TestNG ==

== Data Driven Test ==

== The Dump Method ==