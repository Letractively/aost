<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
    <title>Overview of Tellurium</title>
    
    <section>
        <title>What is Tellurium</title>
        <para>
            <link xlink:href="http://code.google.com/p/aost/">The Tellurium Automated Testing Framework
            </link>
            (Tellurium) is an automated testing framework for web applications. Tellurium grew up from
            <link xlink:href="http://seleniumhq.org/">the Selenium framework</link>, but with a different
            testing concept. Starting from Tellurium 0.7.0, Tellurium added Tellurium Engine to replace
            the Selenium Core to better support Tellurium.
        </para>

        <para>For most existing web testing frameworks like Selenium, they mainly focus on individual UI elements as
            follows.
            For most existing web testing frameworks like Selenium, they mainly focus on individual UI elements as
            follows.
        </para>

        <mediaobject>
            <imageobject>
                <imagedata fileref="./media/tellurium3.png" scalefit="1" width="100%"></imagedata>
            </imageobject>
        </mediaobject>

        <para>For example:</para>
        <programlisting language="java"><?db-font-size 75% ?>
<![CDATA[
    selenium.click("//div[3]/input[@value='Create']");
]]>
        </programlisting>

        <para>For Tellurium, we treated the whole UI elements as a widget and we call it a UI module.</para>

        <mediaobject>
            <imageobject>
                <imagedata fileref="./media/tellurium4.png" scalefit="1" width="100%"></imagedata>
            </imageobject>
        </mediaobject>

        <para>We define the UI module as follows.</para>
        <programlisting language="java"><?db-font-size 75% ?>
<![CDATA[
ui.Form(uid: "Form", clocator: [tag: "form"]){
   Div(uid: "User", clocator: [:]){
      Selector(uid: "Sex", clocator: [:])
      InputBox(uid: "Input", clocator: [tag: "input", type: "text",
                name: "j_username"])
   }
   Container(uid: "Finish", clocator: [tag: "tr"]){
      SubmitButton(uid: "Submit", clocator: [tag: "input", type: "submit",
                value: "Login", name: "submit"])
   }
}
]]>
        </programlisting>

        <para>If we think Selenium as the &quot;C&quot; language, Tellurium
            is like the &quot;C++&quot; language, which uses a different testing concept. There are
            couple advantages to describe the UI elements as a UI module.
        </para>
        <para>
            <emphasis>Expressive</emphasis>
            is obvious. For example, you can see clearly what the UI you are testing against. For the
            test code, you have DSL style test code such as:
        </para>

        <programlisting language="java"><?db-font-size 75% ?>
<![CDATA[
    type "Form.User.Input", "TelluriumSource"
]]>
        </programlisting>
        <para>
            <emphasis>Robust to Changes</emphasis>
            Test robust is always a big issue for Selenium. To
            solve this problem is one of the main motivations that Tellurium was created for. Tellurium
            uses UI attributes to describe UI instead of fixed locators. If we change the attributes,
            new runtime locators will be generated by the framework so that Tellurium can self-adapt to
            UI changes to some degree.
            <link linkend='engineSantaAlgorithm'>The Santa algorithm
            </link>
            in Tellurium new engine further improves the test robust by using UI partial matching.
        </para>
        <para>
            <emphasis>Represent Dynamic Web Content Easily</emphasis>
            The
            <link linkend='basicsUiTemplates'>Tellurium UI templates
            </link>
            are used to represent dynamic web content very easily. For example,
            <link xlink:href="http://code.google.com/p/aost/issues/list">Tellurium issue search result
                widget
            </link>
            can be easily represented as follows.
        </para>

        <programlisting language="java"><?db-font-size 75% ?>
<![CDATA[
ui.Table(uid: "issueResult", clocator: [id: "resultstable", class: "results"],
   group: "true") {
   //Define the header elements
   UrlLink(uid: "{header: any} as ID", clocator: [text: "*ID"])
   UrlLink(uid: "{header: any} as Type", clocator: [text: "*Type"])
   UrlLink(uid: "{header: any} as Status", clocator: [text: "*Status"])
   UrlLink(uid: "{header: any} as Priority", clocator: [text: "*Priority"])
   UrlLink(uid: "{header: any} as Milestone", clocator: [text: "*Milestone"])
   UrlLink(uid: "{header: any} as Owner", clocator: [text: "*Owner"])
   UrlLink(uid: "{header: any} as Summary",
         clocator: [text: "*Summary + Labels"])
   UrlLink(uid: "{header: any} as Extra", clocator: [text: "*..."])

   //Define table body elements
   //Column "Extra" are TextBoxes
   TextBox(uid: "{row: all, column -> Extra}", clocator: [:])
   //For the rest, they are UrlLinks
   UrlLink(uid: "{row: all, column: all}", clocator: [:])
}    
]]>
        </programlisting>

        <para>
            <emphasis>Easy to Maintain</emphasis>
            Tellurium emphasizes the decoupling of UI from test code. The structured test code makes Tellurium easier to
            maintain and refactor.
        </para>

        <para>
            <emphasis>Motivation</emphasis>
            Automated web testing has always been one of the hottest
            and most important topics in the software testing arena when it comes to the rising
            popularity of Rich Internet applications (RIA) and Ajax-based web applications. With the
            advent of new web techniques such as RIA and Ajax, automated web testing tools must keep
            current with changes in technology and be able to address the following challenges:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    <emphasis role="bold">JavaScript Events</emphasis>: JavaScript is everywhere on the
                    web today. Many web applications are JavaScript heavy. To test JavaScript, the
                    automated testing framework should be able to trigger JavaScript events in a
                    convenient way.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">Ajax for Dynamic Web Content</emphasis>: Web applications have
                    many benefits over desktop applications. For example, these applications have no
                    installation and updates are instantaneous and easier to support. Ajax is a
                    convenient way to update a part of the web page without refreshing the whole page.
                    AJAX makes web applications richer and more user-friendly. The web context for an
                    Ajax application is usually dynamic. For example, in a data grid, the data and
                    number of rows keeps changing at runtime.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">Robust/Responsive to Changes</emphasis>: A good automated
                    web-testing tool should be able to address the changes in the web context to some
                    degree so that users do not need to keep updating the test code.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">Easy to Maintain</emphasis>: In an agile testing world,
                    software development is based on iterations, and new features are added on in each
                    sprint. The functional tests or user acceptance tests must be refactored and updated
                    for the new features. The testing framework should provide the flexibility for users
                    to maintain the test code easily.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">Re-usability</emphasis>: Many web applications use the same UI
                    module for different parts of the application. The adoption of JavaScript frameworks
                    such as Dojo and ExtJS increases the chance of using the same UI module for
                    different web applications. A good testing framework should also be able to provide
                    the re-usability of test modules.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">Expressiveness</emphasis>: The testing framework provides
                    users without much coding experience the ability to easily write test code or
                    scripts in a familiar way, such as using a domain specific language (DSL).
                </para>
            </listitem>
        </itemizedlist>
        <para>The Tellurium Automated Testing Framework
            (Tellurium) is designed around these considerations and has defined as its focus the
            following goals:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Robust/responsive to changes; allow changes to be localized
                </para>
            </listitem>
            <listitem>
                <para>
                    Addresses dynamic web contexts such as JavaScript events and Ajax
                </para>
            </listitem>
            <listitem>
                <para>Easy to refactor and maintain
                </para>
            </listitem>
            <listitem>
                <para>
                    Modular; test modules are reusable
                </para>
            </listitem>
            <listitem>
                <para>Expressive and easy to use
                </para>
            </listitem>
        </itemizedlist>
    </section>

    <section>
        <title>Tellurium, the New Approach for Web Testing</title>
        <para>The Tellurium Automated Testing Framework (Tellurium) is an open
            source automated testing framework for web applications that addresses the challenges and
            problems of todayâ€™s web testing.
        </para>
        <para>Most existing web testing tools/frameworks focus on individual UI
            elements such as links and buttons. Tellurium takes a new approach for automated web testing
            by using the concept of the UI module.
        </para>
        <para>The
            <emphasis>UI module</emphasis>
            is a collection of UI elements grouped together. Usually, the UI module represents a
            composite UI object in the format of nested basic UI elements. For example, the Google
            search UI module can be expressed as follows:
        </para>

        <programlisting language="java"><?db-font-size 75% ?>
<![CDATA[
ui.Container(uid: "GoogleSearchModule", clocator: [tag: "td"], group: "true"){
  InputBox(uid: "Input", clocator: [title: "Google Search"])
  SubmitButton(uid: "Search", clocator: [name: "btnG", value: "Google Search"])
  SubmitButton(uid: "ImFeelingLucky", clocator: [value: "I'm Feeling Lucky"])
}
]]>
        </programlisting>

    <para>Tellurium is built on the foundation of the UI module. The UI module makes it possible to
                            build locators for UI elements at runtime. First, this makes Tellurium robust and responsive
                            to changes from internal UI elements. Second, the UI module makes Tellurium expressive. UI
                            elements can be referred to simply by appending the names (uid) along the path to the
                            specific element. This also enables
                            <emphasis>Tellurium&apos;s Group Locating</emphasis>
                            feature, making composite objects reusable, and addressing dynamic web pages.
                        </para>
     <para>Tellurium is implemented in Groovy and Java. The test cases can be written in Java, Groovy, or pure
                            Domain Specific Language (DSL) scripts. Tellurium evolved out of Selenium. However, the UI
                            testing approach is completely different. Tellurium is not a &quot;record and replay&quot;
                            style framework, and it enforces the separation of UI modules from test code, making
                            refactoring easy.
                        </para>
      <para>For example, once the Google Search UI module is defined as previously shown, the test code
                            is written as follows:
                        </para>
        <programlisting language="java"><?db-font-size 75% ?>
<![CDATA[
type "GoogleSearchModule.Input", "Tellurium test"
click "GoogleSearchModule.Search"
]]>
        </programlisting>
        <para>Tellurium sets the Object to Locator Mapping (OLM) automatically at runtime so that
            UI objects can be defined simply by their attributes using Composite Locators. Tellurium
            uses the Group Locating Concept (GLC) to exploit information inside a collection of UI
            components so that locators can find their elements.
        </para>

        <para>Tellurium also defines a set of DSLs for web testing. Furthermore, Tellurium uses UI templates to define
            sets of dynamic UI elements at runtime. As a result, Tellurium is robust, expressive,
            flexible, reusable, and easy to maintain.
        </para>
        <para>The main features of Tellurium include:</para>
        <itemizedlist>
            <listitem>
                <para>Abstract UI objects to encapsulate web UI elements
                </para>
            </listitem>
            <listitem>
                <para>UI module for structured test code and re-usability
                </para>
            </listitem>
            <listitem>
                <para>DSL for UI definition, actions, and testing
                </para>
            </listitem>
            <listitem>
                <para>
                    Composite Locator to use a set of attributes to describe a UI element
                </para>
            </listitem>
            <listitem>
                <para>
                    Group locating to exploit information inside a collection of UI components
                </para>
            </listitem>
            <listitem>
                <para>
                    Dynamically generate runtime locators to localize changes
                </para>
            </listitem>
            <listitem>
                <para>UI templates for dynamic web content
                </para>
            </listitem>
            <listitem>
                <para>XPath support
                </para>
            </listitem>
            <listitem>
                <para>jQuery selector support to improve test speed in IE
                </para>
            </listitem>
            <listitem>
                <para>Locator caching to improve speed
                </para>
            </listitem>
            <listitem>
                <para>Javascript event support
                </para>
            </listitem>
            <listitem>
                <para>
                    Use Tellurium Firefox plugin, Trump, to automatically generate UI modules
                </para>
            </listitem>
            <listitem>
                <para>Dojo and ExtJS widget extensions
                </para>
            </listitem>
            <listitem>
                <para>Data driven test support
                </para>
            </listitem>
            <listitem>
                <para>Selenium Grid support
                </para>
            </listitem>
            <listitem>
                <para>JUnit and TestNG support
                </para>
            </listitem>
            <listitem>
                <para>Ant and Maven support
                </para>
            </listitem>
        </itemizedlist>
        <para>How Challenges and Problems Are Addressed in Tellurium?</para>
        <para>First, Tellurium does not use &quot;record and
            replay&quot;. Instead, it uses the Tellurium Firefox plugin TrUMP to generate the UI module
            (not test code) for you. Then test code based on the UI module is created.
        </para>
        <para>In this way, the UI and the test code are decoupled. The structured test code in Tellurium makes it much
            easier
            to refactor and maintain the code.
        </para>
        <para>The composite locator uses UI element attributes to
            define the UI, and the actual locator (for example, XPath or jQuery selector), is generated
            at runtime. Any updates to the composite locator lead to different runtime locators, and the
            changes inside the UI module are localized.
        </para>
        <para>The Group locating is used to remove the dependency of the UI objects
            from external UI elements (for example, external UI changes do not affect the current UI
            module for most cases), so that test code is robust and responsive to changes up to a
            certain level.
        </para>
        <para>Tellurium uses the
            <emphasis>respond</emphasis>
            attribute in a UI object to specify JavaScript events, and the rest is handled automatically
            by the framework itself.
        </para>

        <para>UI templates are a powerful feature in Tellurium used to represent many identical UI elements or a
            dynamic size of different UI elements at runtime. This is extremely useful in testing
            dynamic web contexts such as a data grid.
        </para>
        <para>The
            <emphasis>Option</emphasis>
            UI object is designed to automatically address dynamic web contexts with multiple possible
            UI patterns.
        </para>
        <para>Re-usability is achieved by the UI module when working within
            one application and by Tellurium Widgets when working across different web applications.
            With the Domain Specific Language (DSL) in Tellurium, UI modules can be defined and test
            code written in a very expressive way.
        </para>
        <para>Tellurium also provides flexibility to write test code in Java, Groovy, or pure DSL scripts.
        </para>
    </section>

    <section>
        <title>Tellurium Architecture</title>
        <para>Tellurium architecture is shown in the following diagram.</para>

        <mediaobject>
            <imageobject>
                <imagedata fileref="./media/telluriumnewarchitecture070.png" scalefit="1" width="100%"></imagedata>
            </imageobject>
        </mediaobject>

        <para>There are two major parts, i.e., the Tellurium Core, which does Java/Groovy object to runtime locator
            mapping, event handling, and command bundling. The Tellurium Engine is embedded inside the
            Selenium server and is a test driving engine for Tellurium. The two are connected by
            Selenium RC.
        </para>
        <para>The DSL parser consists of the DSL Object Parser, Object Builders, and the Object Registry.
        </para>
        <para>Using Groovy builder pattern, UI objects are defined
            expressively and in a nested fashion. The DSL object parser parses the DSL object definition
            recursively and uses object builders to build the objects on the fly. An object builder
            registry is designed to hold all predefined UI object builders in the Tellurium framework,
            and the DSL object parser looks at the builder registry to find the appropriate builders.
        </para>

        <para>Since the registry is a hash map, you can override a builder with a new
            one using the same UI name. Users can also add their customer builders into the builder
            registry. The DSL object definition always comes first with a container type object. An
            object registry (a hash map) is used to store all top level UI Objects. As a result, for
            each DSL object definition, the top object IDs must be unique in the DslContext. The object
            registry is used by the framework to search for objects by their IDs and fetch objects for
            different actions.
        </para>
        <para>The Object Locator Mapping (OLM) is the core of the Tellurium framework and it includes UI ID
            mapping, XPath builder, jQuery selector builder, and Group Locating.
        </para>
        <para>The UI ID supports nested objects. For example, &quot;menu.wiki&quot; stands for a URL Link
            &quot;wiki&quot; inside a container called &quot;menu&quot;.
        </para>
        <para>The UI ID also supports one-dimensional and two-dimensional indices for tables and lists.
            For example,
            <literal>&quot;main.table[2][3]&quot;</literal>
            stands for the UI object of the 2nd row and the 3rd column of a table inside the container
            &quot;main&quot;.
        </para>
        <para>XPath builder builds the XPath from the composite locator. For example, a set of attributes.
            Starting with version 0.6.0, Tellurium supports jQuery selectors to address the problem of
            poor performance of XPath in Internet Explorer.
        </para>
        <para>jQuery selector builders are used to automatically generate jQuery selectors instead of
            XPath with the following advantages:
        </para>
        <itemizedlist>
            <listitem>
                <para>Provides faster performance in IE
                </para>
            </listitem>
            <listitem>
                <para>
                    Leverages the power of jQuery to retrieve bulk data from the web by testing with one
                    method call
                </para>
            </listitem>
            <listitem>
                <para>
                    Provides new features using jQuery attribute selectors
                </para>
            </listitem>
        </itemizedlist>

        <para>The Group Locating Concept (GLC) exploits the group information inside a collection of UI objects
            to assist in finding the locator of the UI objects collection.
        </para>
        <para>The Eventhandler handles all events such as &quot;click&quot;, &quot;type&quot;, &quot;select&quot;,
            etc.
        </para>

        <para>The Data Accessor fetches data or UI status from the DOM. The dispatcher delegates all calls it receives
            from
            the Eventhandler and the data accessor attached to the connector is also connected to the
            Tellurium engine.
        </para>
        <para>The dispatcher is designed to decouple the rest of the
            Tellurium framework from the base test driving engine so that it can be switched to a
            different test driving engine by simply changing the dispatcher logic.
        </para>
        <para>Tellurium works in two mode. The first one is to work as a wrap of the Selenium framework.
        </para>

        <mediaobject>
            <imageobject>
                <imagedata fileref="./media/TelluriumRunningMode1.png" scalefit="1" width="100%"></imagedata>
            </imageobject>
        </mediaobject>

        <para>That is to say, Tellurium core generates the runtime locator based on the attributes
            in a UI module and then pass the selenium calls to Selenium core with Tellurium extensions.
        </para>
        <para>Tellurium is evolving to its own test driving Engine and the work mode is different as shown
            in the following sequence diagram.
        </para>

        <mediaobject>
            <imageobject>
                <imagedata fileref="./media/TelluriumRunningMode2.png" scalefit="1" width="100%"></imagedata>
            </imageobject>
        </mediaobject>

        <para>The Tellurium Core will convert the UI module into a JSON representation and
            pass it to Tellurium Engine for the first time when the UI module is used. The Tellurium
            Engine uses the Santa algorithm to locate the whole UI module and put it into a cache. For
            the sequent calls, the cached UI module will be used instead of locating them again. Another
            new features in Tellurium 0.7.0 is the <link linkend='advancedMacroCommand'>Macro
                Command</link>, which combine multiple commands into one batch and then send them to
            Tellurium engine in one call to reduce the round trip latency. For more new features in
            0.7.0, please read <link linkend='whatsnewIntroduction'>What&apos;s
                New in Tellurium 0.7.0</link>.
        </para>
    </section>

    <section>
        <title>History of Tellurium</title>
        <para>Tellurium was started in June 2007 as an internal project and became
            <link xlink:href="http://code.google.com/p/aost">an open source project on Google Code</link>
            in June 2008. We release on a regular basis and the latest release 0.7.0 will be out next
            month.
        </para>

        <mediaobject>
            <imageobject>
                <imagedata fileref="./media/telluriumhistory.png" scalefit="1" width="100%"></imagedata>
            </imageobject>
        </mediaobject>

    </section>

    <section>
        <title>Tellurium Team and Community</title>
        <para>
            <link xlink:href="http://code.google.com/p/aost/wiki/ContributorList">Tellurium Team</link>
            consists of 4-5 active team members and couple more contributors. We have
            <link xlink:href="http://groups.google.com/group/tellurium-users">Tellurium user group</link>
            and<link xlink:href="http://groups.google.com/group/tellurium-developers">Tellurium developer
            group</link>. Latest update information are available on<link xlink:href="">
            http://twitter.com/TelluriumSource twitter</link>. Tellurium also provides a community
            repository on
            <link xlink:href="http://github.com/telluriumsource/tellurium">GitHub</link>
            so that anyone can fork Tellurium and contribute back to us. Tellurium wiki documents will
            be migrated to<link xlink:href="http://telluriumsource.org/display/TE/Home">
            TelluriumSource.org</link>, a domain owned by us.
        </para>

    </section>

    <section>
        <title>Tellurium Sub-projects</title>
        <para>Tellurium began as a small core project and
                            quickly generated multiple sub-projects including: UDL, Core, Engine, Widget extensions,
                            Maven Archetypes, and Trump sub-projects as shown in the following diagram.
                        </para>

         <mediaobject>
            <imageobject>
                <imagedata fileref="./media/NewTelluriumSubProjects.png" scalefit="1" width="80%"></imagedata>
            </imageobject>
        </mediaobject>

        <itemizedlist>
            <listitem>
                <para>Tellurium UDL:
                    <link linkend='udlIntroduction'>
                        Tellurium UID Description Language
                    </link>
                    (UDL) Parser.
                </para>
            </listitem>
            <listitem>
                <para>Tellurium Engine: Based on Selenium Core with UI module, CSS selector, command
                    bundle, and exception hierarchy support.
                </para>
            </listitem>
            <listitem>
                <para>Tellurium Core: UI module, APIs, DSL, Object to Runtime Locator mapping (OLM), and
                    test support.
                </para>
            </listitem>
            <listitem>
                <para>Tellurium Extensions: Dojo Javascript widgets and ExtJS Javascript widgets.</para>
            </listitem>
            <listitem>
                <para>Tellurium UI Module Plugin (Trump):
                    <link linkend='trumpInstall'>A Firefox plugin</link>
                    to automatically generate the UI module after users select the UI elements from the
                    web under testing.
                </para>
            </listitem>
            <listitem>
                <para>Tellurium Maven Archetypes:
                    <link linkend='mavenArchetypeChapter'>
                        Maven archetypes
                    </link>
                    to generate skeleton Tellurium JUnit and Tellurium TestNG projects using one Maven
                    command.
                </para>
            </listitem>
            <listitem>
                <para>Tellurium Reference Projects: Use Tellurium project site as examples to illustrate
                    how to use different features in Tellurium and how to create Tellurium test cases.
                </para>
            </listitem>
        </itemizedlist>
    </section>
</chapter>