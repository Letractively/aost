#summary Tellurium User Guide: Appendix B

(A PDF version of the user guide is available [http://aost.googlecode.com/files/TelluriumUserGuide.0.6.0.pdf here])

<wiki:toc max_depth="5" />

= Appendix B Tellurium Frequently Asked Questions (FAQs)=

== When Did Tellurium Start? ==

Tellurium was over one year old in June 2009 if we count the date from the day it became an open source project. But actually, Tellurium had been through two phases of prototyping before that. The first prototype was created in 2007 to test our company's Dojo web applications, which was basically a Java framework based on Spring XML wiring and no UI modules. You have to use factories to create all UI objects. 

As a result, it was not convenient to use. The second prototype was created in early 2008 to improve the usability of the first prototype. The UI module was introduced in the second prototype. Both prototypes had been used for a few internal projects before it was re-written in Groovy and became an open source project in June 2008. Notice that prototype framework is called AOST and it was officially renamed to the Tellurium Automated Testing framework (Tellurium) in July 2008 when it moved out of the prototyping phase and became a team project.

== What Are the Main Differences Between Tellurium and Selenium? ==

Tellurium was created when I was a Selenium user and tried to address some of the shortcomings of the Selenium framework such as verbosity and fragility to changes. Selenium is a great web testing framework and up to 0.6.0, Tellurium uses Selenium core as the test driving engine. From Tellurium 0.7.0, we will gradually replace the Selenium core with our own Engine.

Although Tellurium was born from Selenium, there are some fundamental differences between Tellurium and Selenium, which mainly come from the fact that Tellurium is a UI module-based testing framework. For example, Tellurium focuses on a set of UI elements instead of individual ones. The UI module represents a composite UI object in the format of nested basic UI elements. For example, the download search module in Tellurium project site is defined as follows:

{{{
ui.Form(uid: "downloadSearch", clocator: [action: "list", method: "get"], group: "true") {
   Selector(uid: "downloadType", clocator: [name: "can", id: "can"])
   InputBox(uid: "searchBox", clocator: [name: "q"])
   SubmitButton(uid: "searchButton", clocator: [value: "Search"])
}
}}}

With the UI module, Tellurium automatically generates runtime locators for you and there is no need to define XPaths or other types of locators by yourself. Tellurium is robust, expressive, flexible, and reusable.

== Do I Need to Know Groovy Before I Use Tellurium? ==

Tellurium Core is implemented in Groovy and Java to achieve expressiveness. But that does not mean you have to be familiar with Groovy before you start to use Tellurium. Tellurium creates DSL expressions for UI module, actions, and testing. Use a Groovy class to implement the UI module by extending the DslContext Groovy class. Then the user can write the rest using Java syntax. The test cases can be created in Java, Groovy, or Dsl scripts. However, we do encourage geting familiar with Groovy to leverage its meta programming features.

To create a Tellurium project, install a Groovy plugin for your IDE. There are Groovy plugins for commonly used IDEs such as Eclipse, Netbeans, and IntelliJ. Refer to the following WIKI pages on how to set up Groovy and use Tellurium in different IDEs,

[http://code.google.com/p/aost/wiki/TelluriumReferenceProjectEclipseSetup http://code.google.com/p/aost/wiki/TelluriumReferenceProjectEclipseSetup]

[http://code.google.com/p/aost/wiki/TelluriumReferenceProjectNetBeansSetup http://code.google.com/p/aost/wiki/TelluriumReferenceProjectNetBeansSetup]

[http://code.google.com/p/aost/wiki/TelluriumReferenceProjectIntelliJSetup http://code.google.com/p/aost/wiki/TelluriumReferenceProjectIntelliJSetup]

== What Unit Test and Functional Test Frameworks Does Tellurium Support? ==

Tellurium supports both JUnit and TestNG frameworks. Extend TelluriumJavaTestCase for JUnit and TelluriumTestNGTestCase for TestNG. For more details, please check the following WIKI pages:

[http://code.google.com/p/aost/wiki/BasicExample http://code.google.com/p/aost/wiki/BasicExample]

[http://code.google.com/p/aost/wiki/Introduction http://code.google.com/p/aost/wiki/Introduction]

Tellurium also provides data driven testing. Data Driven Testing is a different way to write tests. For example, test data are separated from the test scripts and the test flow is not controlled by the test scripts, but by the input file instead. In the input file, users can specify which test to run, what the input parameters are, and what the expected results are. More details can be found from "Tellurium Data Driven Testing" WIKI page,

[http://code.google.com/p/aost/wiki/DataDrivenTesting http://code.google.com/p/aost/wiki/DataDrivenTesting]

== Does Tellurium Provide Any Tools to Automatically Generate UI Modules? ==

Tellurium UI Model Plugin (TrUMP) is a Firefox Plugin used to automatically generate UI modules simply by clicking on the web page under testing. A user can download it from the Tellurium download page at:

[http://code.google.com/p/aost/downloads/list http://code.google.com/p/aost/downloads/list]

or from Firefox Addons site at:

[https://addons.mozilla.org/en-US/firefox/addon/11035 https://addons.mozilla.org/en-US/firefox/addon/11035]

The detailed user guide for TrUMP 0.1.0 is at:

[http://code.google.com/p/aost/wiki/TrUMP http://code.google.com/p/aost/wiki/TrUMP]

To understand more about how TrUMP works, please read "How does TrUMP work?" at:

[http://code.google.com/p/aost/wiki/HowTrUMPWorks http://code.google.com/p/aost/wiki/HowTrUMPWorks]

== What Build System Does Tellurium Use? ==

Tellurium supports both Ant and Maven build systems. The ant build scripts are provided in Tellurium core and Tellurium reference projects. For Maven, please check out the Tellurium Maven guide at:

[http://code.google.com/p/aost/wiki/MavenHowTo http://code.google.com/p/aost/wiki/MavenHowTo]

== What is the Best Way to Create a Tellurium Project? ==

Tellurium provides two reference projects for JUnit and TestNG project, respectively. Use one of them as a template project. Please see the reference project guide at:

[http://code.google.com/p/aost/wiki/ReferenceProjectGuide http://code.google.com/p/aost/wiki/ReferenceProjectGuide]

However, the best and easiest way to create a Tellurium project is to use Tellurium Maven archetypes. Tellurium provides two Maven archetypes. For example, tellurium-junit-archetype and tellurium-testng-archetype for Tellurium JUnit test project and Tellurium TestNG test project, respectively. 

As a result, you can create a Tellurium project using one Maven command. For a Tellurium JUnit project, use:

{{{
mvn archetype:create -DgroupId =your_group_id -DartifactId=your_artifact_id \
-DarchetypeArtifactId=tellurium-junit-archetype -DarchetypeGroupId=tellurium\ -DarchetypeVersion=0.7.0-SNAPSHOT \ -DarchetypeRepository
= [http://kungfuters.org/nexus/content/repositories/snapshots http://kungfuters.org/nexus/content/repositories/snapshots]
}}}

and for a Tellurium TestNG project, use

{{{
mvn archetype:create -DgroupId=your_group_id -DartifactId=your_artifact_id \
-DarchetypeArtifactId=tellurium-testng-archetype -DarchetypeGroupId=tellurium \ -DarchetypeVersion=0.7.0-SNAPSHOT \ -DarchetypeRepository=[http://kungfuters.org/nexus/content/repositories/snapshots http://kungfuters.org/nexus/content/repositories/snapshots]
}}}
For more details, please read "Tellurium Maven archetypes",

[http://code.google.com/p/aost/wiki/TelluriumMavenArchetypes http://code.google.com/p/aost/wiki/TelluriumMavenArchetypes]

== Where Can I Find API Documents for Tellurium? ==

The user guide for Tellurium DSLs, other APIs, and default UI objects could be found at:

[http://code.google.com/p/aost/wiki/UserGuide http://code.google.com/p/aost/wiki/UserGuide]

== Is There a Tellurium Tutorial Available? ==

Tellurium provides very detailed tutorials including basic examples, advanced examples, data driven testing examples, and Dsl script examples. We also provide Tellurium Tutorial Series. Please use Tellurium tutorial WIKI page as your starting point,

[http://code.google.com/p/aost/wiki/Tutorial http://code.google.com/p/aost/wiki/Tutorial]

We also provide a quick start, "Ten Minutes To Tellurium", at

[http://code.google.com/p/aost/wiki/TenMinutesToTellurium http://code.google.com/p/aost/wiki/TenMinutesToTellurium]

== Tellurium Dependencies ==

Tellurium is built on top of Selenium at the current stage and it uses Selenium 1.0.1 and Selenium Grid tool 1.0.2. Tellurium 0.6.0 was tested with Grooy 1.6.0 and Maven 2.0.9.

You can go to Tellurium core and run the following Maven command to check the dependencies:

{{{
$ mvn dependency:tree

[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'dependency'.
[INFO] ------------------------------------------------------------------------
[INFO] Building Tellurium Core
[INFO]    task-segment: [dependency:tree]
[INFO] ------------------------------------------------------------------------
[INFO] [dependency:tree]
[INFO] tellurium:tellurium-core:jar:0.6.0
[INFO] +- junit:junit:jar:4.4:compile
[INFO] +- org.testng:testng:jar:jdk15:5.8:compile
[INFO] +- caja:json_simple:jar:r1:compile
[INFO] +- org.stringtree:stringtree-json:jar:2.0.10:compile
[INFO] +- org.seleniumhq.selenium.server:selenium-server:jar:1.0.1-te:compile
[INFO] +- org.seleniumhq.selenium.client-drivers:selenium-java-client-driver:jar:1.0.1:compile
[INFO] +- org.openqa.selenium.grid:selenium-grid-tools:jar:1.0.2:compile
[INFO] +- org.codehaus.groovy:groovy-all:jar:1.6.0:compile
[INFO] |  +- org.apache.ant:ant:jar:1.7.1:compile
[INFO] |  |  \- org.apache.ant:ant-launcher:jar:1.7.1:compile
[INFO] |  \- jline:jline:jar:0.9.94:compile
[INFO] +- org.codehaus.groovy.maven.runtime:gmaven-runtime-1.6:jar:1.0-rc-5:compile
[INFO] |  +- org.slf4j:slf4j-api:jar:1.5.6:compile
[INFO] |  +- org.codehaus.groovy.maven.feature:gmaven-feature-support:jar:1.0-rc-5:compile
[INFO] |  |  \- org.codehaus.groovy.maven.feature:gmaven-feature-api:jar:1.0-rc-5:compile
[INFO] |  \- org.codehaus.groovy.maven.runtime:gmaven-runtime-support:jar:1.0-rc-5:compile
[INFO] |     +- org.codehaus.groovy.maven.runtime:gmaven-runtime-api:jar:1.0-rc-5:compile
[INFO] |     +- org.codehaus.groovy.maven:gmaven-common:jar:1.0-rc-5:compile
[INFO] |     +- org.codehaus.plexus:plexus-utils:jar:1.5.5:compile
[INFO] |     \- com.thoughtworks.qdox:qdox:jar:1.8:compile
[INFO] \- bouncycastle:bcprov-jdk15:jar:140:compile
[INFO] ------------------------------------------------------------------------
}}}

But be aware that some of the dependencies are required ONLY for Maven itself, for example, gmaven-runtime, bouncycastle, and plexus.

== What Is the ui. in UI Module? ==

Very often, you will see the ui. symbol when you define Tellurium UI modules. For instance, look at the following GoogleSearchModule UI module:

{{{
ui.Container(uid: "GoogleSearchModule", clocator: [tag: "td"], group: "true"){
   InputBox(uid: "Input", clocator: [title: "Google Search"])
   SubmitButton(uid: "Search", clocator: [name: "btnG", value: "Google Search"])
   SubmitButton(uid: "Imfeelinglucky", clocator: [value: "I'm Feeling Lucky"])
}
}}}

If you have read the Tellurium core code, you will find the following line in the BaseDslContext class,

{{{    UiDslParser ui = new UiDslParser()}}}

The ui is actually an instance of UiDslParser. On the above UI module, call the method "Container" on UiDslParser with a map of attributes plus a Closure with the following nested code.

{{{
{
   InputBox(uid: "Input", clocator: [title: "Google Search"])
   SubmitButton(uid: "Search", clocator: [name: "btnG", value: "Google Search"])
   SubmitButton(uid: "Imfeelinglucky", clocator: [value: "I'm Feeling Lucky"])
}
}}}

Look at what the UiDslParser actually does from the source code:
{{{
class UiDslParser extends BuilderSupport{

   def registry = [:]

   def UiObjectBuilderRegistry builderRegistry = new UiObjectBuilderRegistry()

   protected Object createNode(Object name) {
   }

   ....
}
}}}

The UiDslParser extends the Groovy {{{BuilderSupport}}} class and works as a parser for what ever you passed in starting from {{{Container(uid: "GoogleSearchModule", clocator: [tag: "td"], group: "true")}}} in the above example.

You may notice that the {{{BuilderSupport}}} class needs to handle couple call back methods such as:

{{{
protected Object createNode(Object name)

protected Object createNode(Object name, Object value)

protected Object createNode(Object name, Map map)

protected Object createNode(Object name, Map map, Object value)

protected void nodeCompleted(Object parent, Object node)

protected void setParent(Object parent, Object child)
}}}

If you are familiar with XML parser, you will see that this is really similar to the XML PUSH style parser. Define call back methods and the parser will parse the message to the end automatically.

The above callback methods are doing the similar thing. For example, to create a UI object when it sees the name like "Container", "InputBox", and "SubmitButton". The different createNode methods are used for different use cases.

Basically, what the UiDslParser does is to get the object name such as "Container" and then look at the UI builder registry to find the builder for that object, then use the builder to build that UI object. The UI builder registry is a hash map and you can find the Container builder by the object name "Container".

Also the UiDslParser will keep the parse results. For example, UI objects in a registry so that you can refer to them by UID such as "GoogleSearchModule.Search", The object hierarchy is handled by the setParent method.

== How Do I Add My Own UI Object to Tellurium? ==

First, create your UI object groovy class by extending class UiObject or Container if it is a container type object. Then, create your UI object builder by extending class UiObjectBuilder. Finally, register your ui builder for your ui object by call method in class TelluriumFramework:

{{{
public void registerBuilder(String uiObjectName, UiObjectBuilder builder)
}}}

You can also register your builder in class UiObjectBuilderRegistry if you work on Tellurium source code directly.

From Tellurium 0.4.0, a global configuration file TelluriumConfig.groovy is used to customize Tellurium. You can also define your own UI object in this file as follows,

{{{
    uiobject{
        builder{
           Icon="org.tellurium.builder.IconBuilder"
        }
    }
}}}

That is to say, create the UI object and its builder and then in the configuration file specify the UI object name and its builder full class name. '''Note''': this feature is included in Tellurium 0.5.0. Please check the SVN trunk for details.

== How to Build Tellurium from Source ==

If you want to build Tellurium from source, you can check out the trunk code using the subversion command:

{{{
svn checkout http://aost.googlecode.com/svn/trunk/ tellurium
}}}

or using the Maven ({{{mvn}}}) command:

{{{
mvn scm:checkout -DconnectionUrl=scm:svn:http://aost.googlecode.com/svn/trunk -DcheckoutDirectory=tellurium
}}}

Be aware that the Maven command calls the subversion client to do the job and you must have the client installed in your system.

To build the whole project, use:

{{{
mvn clean install
}}}

and Maven compiles source code and resources, compiles test code and test resources, runs all tests, and then installs all artifacts to your local repository under YOUR_HOME/.m2/repository.

Sometimes, tests may break and if you still want to proceed, please use the ignore flag:

{{{
mvn clean install -Dmaven.test.failure.ignore=true
}}}

To build an individual project, go to that project directory and run the same command as above.

To run the tests, use the command:

{{{
mvn test
}}}

The sub-projects under the tools directory include Tellurium Maven archetypes and TrUMP code, you may not really want to build them by yourself. For TrUMP, the artifacts include a .xpi file.

The assembly project just creates a set of tar files and you may not need to build it either.

Tellurium also provides ant build scripts. You may need to change some of the settings in the build.properties file so that it matches your environment. For example, the settings for javahome and javac.compiler. Then in the project root directory, run command:

{{{
ant clean
}}}

to clean up old build and run:

{{{
ant dist
}}}

to generate a new artifact, which can be found in the dist directory.

Run the following to compile test code:

{{{
ant compile-test
}}}

== What is the Issue with Selenium XPath Expressions and Why is There a Need to Create a UI Module? ==

The problem is not in XPath itself, but the way you use it. If the following XPath locator is:

{{{
"//div/table[@id='something']/div[2]/div[3]/div[1]/div[6]"
}}}

then the problem is easily seen. It is not robust. Along the path 

{{{
div -> table -> div -> div ->div -> div
}}}

if anything is changed there, your XPath is no longer valid. For example, if you add additional UI elements and the new XPath was changed to:

{{{
"//div[2]/table[@id='something']/div[3]/div[3]/div[1]/div[6]"
}}}

you would have to keep updating the XPath. For Tellurium, it focuses on element attributes, not the XPath, and it can be adaptive to the changes to some degree.

More importantly, Tellurium uses the group locating concept to use information from a group of UI elements to locate them in the DOM. In most cases, the group of elements are enough to decide their locations in the DOM, that is to say, your UI element's location does not depend on any parent or grandparent elements. 

For instance, in the example above, if you use the group locating concept to find locators for the following part of UI elements directly:

{{{

"div[3]/div[1]/div[6]"

}}}

then they do not depend on the portion certainly.

{{{

"div[2]/table[@id='something']/div[3]" 

}}}

1) The UI elements can address any changes in the portion of :

{{{

"div[2]/table[@id='something']/div[3]"

}}}

*Note:* In Tellurium, the user will not use a locator in the format of: 

{{{"div[3]/div[1]/div[6]" }}}
directly.

2) The syntax of:
{{{
selenium.type("//input[@title='Google Search']", input)
selenium.click("//input[@name='btnG' and @type='submit']")

...

selenium.type("//input[@title='Google Search']", input)
selenium.click("//input[@name='btnG' and @type='submit']")

...

selenium.type("//input[@title='Google Search']", input)
selenium.click("//input[@name='btnG' and @type='submit']")

...
}}}

everywhere is really ugly to users. Especially if someone needs to take over your code. In Tellurium, the UiID is used and it is very clear to users what you are acting upon.

{{{click "google_start_page.googlesearch"}}}

3) The test script created by Selenium IDE is a mess of actions, not modularized. Other people may take quite some time to figure out what the script actually does. And it is quite difficult to refactor and reuse them. Even the UI is not changed, there are data dependence there and for most cases, you simply cannot just "record and replay" in practical tests.

In Tellurium, once you defined the UI module, for example, the Google search module, you can always reuse them and write as many test cases as possible.

4) Selenium is cool and the idea is brilliant. But it is really for low level testing only, focusing on one element at a time and it does not have the whole UI module in mind. That is why another tier on top of it is needed so that you can have a UI module-oriented testing script and not the locator-oriented one. Tellurium is one of the frameworks designed for this purpose.

5) As mentioned in 4), Selenium is quite a low level process and it is really difficult to handle more complicated UI components like a data grid. Tellurium can handle them easily. Please see the test scripts for the Tellurium project web site.