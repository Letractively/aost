#summary Advanced Topics in Tellurium.
#labels Phase-Support

(A PDF version of the user guide is available [http://aost.googlecode.com/files/TelluriumUserGuide.0.6.0.pdf here])

<wiki:toc max_depth="5" />

= Advanced Topics in Tellurium =

== Data Driven Testing ==

Data Driven Testing is a different way to write tests. For example, separate test data from the test scripts and the test flow is not controlled by the test scripts, but by the input file instead. In the input file, users can specify which tests to run, what are input parameters, and what are expected results. Data driven testing in Tellurium is illustrated in Figure 2-5 with the following system diagram:

*Figure 2-5 Data Driven Testing in Tellurium System Diagram*

http://tellurium-users.googlegroups.com/web/TelluriumDataDrivenSmall.jpg?gda=WePTVk4AAAD5mhXrH3CK0rVx4StVj0LYYQ-a0sZzxEmmZWlHbP2MWzTrErMgjh_s8-a7FfMpsGsNL5bu5vgQy2xsA01CuO9M47Cl1bPl-23V2XOW7kn5sQ&gsc=ODykzgsAAACEc2FtJPGdXe_7CHb1VB6Z

The Tellurium Data Driven Test consists of three main parts: 

  # Data Provider
  # TelluriumDataDrivenModule
  # TelluriumDataDrivenTest

=== Data Provider ===

The Data Provider is responsible for reading data from input stream and converting data to Java variables. 

Tellurium includes the following Data Provider methods:

  # loadData file_name, load input data from a file
  # useData String_name, load input data from a String in the test script
  # bind(field_name), bind a variable to a field in a field set
  # closeData, close the input data stream and report the test results
  # cacheVariable(name, variable), put variable into cache
  # getCachedVariable(name, variable), get variable from cache where the file_name includes the file path. For example:

{{{loadData "src/test/example/test/ddt/GoogleBookListCodeHostInput.txt"}}}

Tellurium supports pipe format and CSV format input file. 

=== loadData ===

To change the file reader for different formats, change the following settings in the configuration file {{{TelluriumConfig.groovy:}}}

{{{
datadriven{
  dataprovider{
    //specify which data reader you like the data provider to use
    //the valid options include "PipeFileReader", "CSVFileReader" at this point
    reader = "PipeFileReader"
  }
}
}}}

=== useData ===

Tellurium's useData is designed to specify test data in the test scripts directly. It loads input from a String. The String is usually defined in Groovy style using triple quota, for example:

{{{
protected String data = """
  google_search | true | 865-692-6000 | tellurium
  google_search | false| 865-123-4444 | tellurium selenium test
  google_search | true | 755-452-4444 | tellurium groovy
  google_search | false| 666-784-1233 | tellurium user group
  google_search | true | 865-123-5555 | tellurium data driven
  """
  ...

  useData data
}}}

=== bind ===

{{{bind}}} is the command used to bind a variable to an input Field Set field at runtime. {{{FieldSet}}} is the format of a line of data. For example:

{{{def row = bind("GCHLabel.row")}}}

is used to bind the row variable to the "row" field in the FieldSet "GCHLabel". Tellurium does not explicitly differentiate input parameters from the expected results in the input data. To bind variables to the input data then use any of them as the expected results for result comparison.

=== cacheVariable and getCachedVariable === 

cacheVariable and getCachedVariable are used to pass intermediate variables among tests. 

  * cacheVariable is used to put a variable into a cache 
  * getCachedVariable is used to get back the variable 

For example:

{{{
int headernum = getTableHeaderNum()
cacheVariable("headernum", headernum)

...

int headernum = getCachedVariable("headernum")
...
}}}

=== closeData ===

When testing is completed, use "closeData" to close the input data stream. In the meantime, the result reporter outputs the test results in the format specified in the configuration file. 

For example: the XML file as shown in the TelluriumConfig.groovy file:

{{{
test{
  result{
    //specify what result reporter used for the test result
    //valid options include "SimpleResultReporter", "XMLResultReporter", 
    //and "StreamXMLResultReporter"
    reporter = "XMLResultReporter"
   
    //the output of the result
    //valid options include "Console", "File" at this point
    //if the option is "File", you need to specify the file name, 
    //other wise it will use the default
    //file name "TestResults.output"
    output = "Console"

    //test result output file name
    filename = "TestResult.output"
  }
}
}}}

=== TelluriumDataDrivenModule ===

{{{TelluriumDataDrivenModule}}} is used to define modules, where users can define UI Modules, FieldSets, and tests as shown in the following Figure 2-6 sequence diagram. Users should extend this class to define their own test modules.

*Figure 2-6 TelluriumDataDrivenModule Sequence Diagram*

http://tellurium-users.googlegroups.com/web/TelluriumDDTModule.png?gda=oIfzLkgAAAD5mhXrH3CK0rVx4StVj0LY6r7Fxo4RaVZ2InRIkvRUPW9wwFNWzBcwQWJJR7cmP5glzhb83kORdLwM2moY-MeuGjVgdwNi-BwrUzBGT2hOzg&gsc=x3TBYwsAAAAeXMPG6HH-B1VXA1h0gdTp

{{{TelluriumDataDrivenModule}}} provides one method "defineModule" for users to implement. Since it extends the DslContext class, users define UI modules as in regular Tellurium UI Modules. For example:

{{{
ui.Table(uid: "labels_table", clocator: [:], group: "true"){
   TextBox(uid: "row: 1, column: 1", clocator: [tag: "div", 
           text: "Example project labels:"])
   Table(uid: "row: 2, column: 1", clocator: [header: "/div[@id=\"popular\"]"]){
        UrlLink(uid: "all", locator: "/a")
   }
}
}}}

=== FieldSet ===

FieldSet defines the format of one line of input data. FieldSet consists of fields such as columns, in the input data. There is a special field "test", where users can specify what tests this line of data applies to. For example:


{{{
fs.FieldSet(name: "GCHStatus", description: "Google Code Hosting input") {
    Test(value: "getGCHStatus")
    Field(name: "label")
    Field(name: "rowNum", type: "int")
    Field(name: "columNum", type: "int")
}  
}}}

FieldSet defines the input data format for testing Google code hosting web page. 

*Note:* The Test field must be the first column of the input data. 

The default name of the test field is "test" and does not need to be specified. If the value attribute of the test field is not specified, it implies this same format. For example, FieldSet is used for different tests.

A regular field includes the following attributes:

{{{
class Field {
        //Field name
        private String name

        //Field type, default is String
        private String type = "String"

        //optional description of the Field
        private String description

        //If the value can be null, default is true
        private boolean nullable = true

        //optional null value if the value is null or not specified
        private String nullValue

        //If the length is not specified, it is -1
        private int length = -1

        //optional String pattern for the value
        //if specified, use it for String validation
        private String pattern
   } 
}}}

Tellurium can automatically handle Java primitive types. 

=== typeHandler ===

Another flexibility Tellurium provides is allowing users to define their own custom type handlers to deal with more complicated data types by using "typeHandler". For example:

{{{
//define custom data type and its type handler

typeHandler "phoneNumber", "org.tellurium.test.PhoneNumberTypeHandler"

//define file data format
fs.FieldSet(name: "fs4googlesearch", description: "example field set for google search"){
    Field(name: "regularSearch", type: "boolean", 
          description: "whether we should use regular search or use I'm feeling lucky")
    Field(name: "phoneNumber", type: "phoneNumber", description: "Phone number")
    Field(name: "input", description: "input variable")
}
}}}

The above script defines a custom type "PhoneNumber" and the Tellurium automatically calls this type handler to convert the input data to the "PhoneNumber" Java type.

=== Define Test ===

The "defineTest" method is used to define a test in the TelluriumDataDrivenModule. For example, the following script defines the "clickGCHLabel" test:

{{{
defineTest("clickGCHLabel"){
    def row = bind("GCHLabel.row")
    def column = bind("GCHLabel.column")

    openUrl("http://code.google.com/hosting/")
    click  "labels_table[2][1].[${row}][${column}]"

    waitForPageToLoad 30000
}
}}}

*Note:* The bind command binds variables row, column to the fields "row" and "column" in the FieldSet "GCHLabel".

=== compareResult ===

Tellurium also provides the command "compareResult" for users to compare the actual result with the expected result. For example, the following script compares the expected label, row number, and column number with the acutal ones at runtime:

{{{
defineTest("getGCHStatus"){
    def expectedLabel = bind("GCHStatus.label")
    def expectedRowNum = bind("GCHStatus.rowNum")
    def expectedColumnNum = bind("GCHStatus.columNum")

    openUrl("http://code.google.com/hosting/")
    def label = getText("labels_table[1][1]")
    def rownum = getTableMaxRowNum("labels_table[2][1]")
    def columnum = getTableMaxColumnNum("labels_table[2][1]")
    
    compareResult(expectedLabel, label)
    compareResult(expectedRowNum, rownum) 
    compareResult(expectedColumnNum, columnum)
    pause 1000
}
}}}

Sometimes users may require custom "compareResult" to handle more complicated situations. For example, when users compare two lists, users can override the default "compareResult" behaviour by specifying custom code in the closure:

{{{
compareResult(list1, list2){
    assertTrue(list1.size() == list2.size())
    for(int i=0; i<list1.size();i++){
        //put your custom comparison code here
    }
}
}}}

=== checkResult ===

If users want to check a variable in the test, the "checkResult" method is used coming with a closure where users define the actual assertions inside:

{{{
checkResult(issueTypeLabel) {
    assertTrue(issueTypeLabel != null)
}
}}}

Like "compareResult", "checkResult" captures all assertion errors. The test resumes even when the assertions fail. The result is reported in the output.

=== Log Message ===

In addition, the "logMessage" is used by users to log any messages in the output.

{{{
logMessage "Found ${actual.size()} ${issueTypeLabel} for owner " + issueOwner 
}}}

=== Tellurium Data Driven Test ===

TelluriumDataDrivenTest is the class users should extend to run the actual data driven testing. It is more like a data driven testing engine. There is only one method, "testDataDriven", which users implement. The sequence diagram for the testing process is shown in Figure 2-7:

*Figure 2-7 TelluriumDataDrivenTest System Diagram*

http://tellurium-users.googlegroups.com/web/TelluriumDDTTestSequence.png?gda=Fgy8N04AAAD5mhXrH3CK0rVx4StVj0LY6r7Fxo4RaVZ2InRIkvRUPYEAgewWsw-pfk-JI3kLTQ9omPhdHiHZ5EjvmEnpg6SE47Cl1bPl-23V2XOW7kn5sQ&gsc=x3TBYwsAAAAeXMPG6HH-B1VXA1h0gdTp

Complete the following steps to use TelluriumDataDrivenTest:

  # Use "includeModule" to load defined Modules
  # Use "loadData" or "useData" to load input data stream
  # Use "stepToEnd" to read the input data line by line and pick up the specified test and run it, until reaches the end of the data stream
  # Use "closeData" to close the data stream and output the test results

What the "includeModule" does is to merge in all Ui modules, FieldSets, and tests defined in that module file to the global registry. 

"stepToEnd" looks at each input line, first find the test name and pass in all input parameters to it, and then run the test. The whole process is illustrated in the following example:

{{{
class GoogleBookListCodeHostTest extends TelluriumDataDrivenTest{

    public void testDataDriven() {
        includeModule  example.google.GoogleBookListModule.class
        includeModule  example.google.GoogleCodeHostingModule.class
        //load file
        loadData "src/test/example/test/ddt/GoogleBookListCodeHostInput.txt"

        //read each line and run the test script until the end of the file
        stepToEnd()

        //close file
        closeData()
   }
}
}}}

The input data for this example are as follows:

{{{
##TEST should be always be the first column

##Data for test "checkBookList"
##TEST | CATEGORY | SIZE
checkBookList|Fiction|8
checkBookList|Fiction|3

##Data for test "getGCHStatus"
##TEST | LABEL | Row Number | Column Number
getGCHStatus |Example project labels:| 3 | 6
getGCHStatus |Example project| 3 | 6

##Data for test "clickGCHLabel"
##TEST | row | column
clickGCHLabel | 1 | 1
clickGCHLabel | 2 | 2
clickGCHLabel | 3 | 3
}}}

*Note:* The line starting with "##" is the comment line and the empty line is ignored.

If users want to control the testing execution flow by themselves, Tellurium also provides this capability even though its use is *_not recommended_*.

Tellurium provides two additional commands, "step" and "stepOver". 

  * "step" is used to read one line of input data and run it.
  * "stepOver" is used to skip one line of input data. 

In this meanwhile, Tellurium also allows the user to specify additional test scripts using closure. For example:

{{{
step{
    //bind variables
    boolean regularSearch = bind("regularSearch")
    def phoneNumber = bind("fs4googlesearch.phoneNumber")
    String input = bind("input")
    openUrl "http://www.google.com"
    type "google_start_page.searchbox", input
    pause 500
    click "google_start_page.googlesearch"
    waitForPageToLoad 30000
}
}}}

This usually implies that the input data format is unique or the test script knows about what format the current input data are using.

== Selenium Grid Support ==

Selenium Grid transparently distributes tests on multiple machines so that the tests are run in parallel. Recently support for the Selenium Grid has been added to Tellurium. Now Tellurium tests can be run against different browsers using Selenium Grid. Tellurium core is updated to support Selenium Grid sessions.

For example, assume 3 machines are set up to run Tellurium tests on the Selenium Grid. All the steps can be completed on the userâs local box. To do this locally, remove the machine names with {{{localhost}}}. Each machine in this set up has a defined role as described below:

  # *dev1.tellurium.com* Tellurium test development machine.
  # *hub.tellurium.com* Selenium Grid hub machine that drives the tests.
  # *rc.tellurium.com* Multiple Selenium RC server running and registered to the Selenium Grid HUB. 

The actual test execution is completed on this machine. Register as many Selenium RC servers as required. However, be realistic about the hardware specification.

Download the Selenium Grid from the following URL and extract the contents of the folder on each of these machines.

Tellurium uses Selenium Grid 1.0.3, the current released version. [http://selenium-grid.seleniumhq.org/download.html http://selenium-grid.seleniumhq.org/download.html]. Figure 2-8 shows an illustration of the environment.

*Figure 2-8 Selenium Grid Support Environment*

http://tellurium-users.googlegroups.com/web/TelluriumGridSetup.png?gda=9fgieUgAAAD5mhXrH3CK0rVx4StVj0LYYQ-a0sZzxEmmZWlHbP2MW6uQS0SyLBzYwfM7_kvx7qklzhb83kORdLwM2moY-MeuGjVgdwNi-BwrUzBGT2hOzg&gsc=ODykzgsAAACEc2FtJPGdXe_7CHb1VB6Z

=== Selenium Grid Support Test Procedure ===

1. Launch the Selenium Grid Hub on the hub machine. Open up a terminal on the HUB machine {{{hub.tellurium.com}}} and go to the download directory of the Selenium Grid.

{{{
> cd /Tools/selenium-grid-1.0.3
> ant launch-hub
}}}

*Result:* The Selenium HUB is launched on the machine with different browsers. 

2. Navigate to the following URL location to ensure that the HUB is working properly: 
[http://hub.tellurium.com:4444/console http://hub.tellurium.com:4444/console]

3. View the web page with 3 distinct columns: 
  # a Configured Environments
  # Available Remote Controls
  # Active Remote Controls

4. Have a list of browsers configured by default to run the tests while the list for Available Remote Controls and Active Remote Controls is empty.

5. Launch the Selenium RC servers and register them with the selenium HUB. Open up a terminal on rc.tellurium.com and go to the selenium grid download directory.

{{{
> cd /Tools/selenium-grid-1.0.3
> ant -Dport=5555 -Dhost=rc.tellurium.com -DhubURL=http://hub.tellurium.com:4444 \
      -Denvironment="Firefox on Windows" launch-remote-control
}}}

*Result:* The command starts a Selenium RC server on this machine.

6. Register the Selenium RC server with the Selenium Grid hub machine as specified by the hubURL.

*Note:* To register another Selenium RC server on this machine for internet explorer repeat the step on a different port.

{{{
> cd /Tools/selenium-grid-1.0.3
> ant -Dport=5556 -Dhost=rc.tellurium.com -DhubURL=http://hub.tellurium.com:4444  -Denvironment="IE on Windows" launch-remote-control
}}}
 
  # _port_ the remote control is listening to. Must be unique on the machine the remote control runs from.
  # _hostname_ Hostname or IP address of the machine the remote control runs on. Must be visible from the Hub machine.
  # _hub url_ Which hub the remote control should register/unregister to. As the hub is running on hostname hub.tellurium.com, the URL is [http://hub.tellurium.com:4444/ http://hub.tellurium.com:4444]

7. Point your browser to the Hub console Once you are successful in replicating a setup similar to the one described above, ([http://hub.tellurium.com:4444/console http://hub.tellurium.com:4444/console]). 

8. Verify that all the remote controls registered correctly. Available remote controls list should be updated and have the 2 selenium servers available to run the tests.

9. Run the Tellurium tests against different browsers once the Selenium Hub and the Selenium RC servers on the Grid environment have started.

10. Go to the Tellurium test development machine, the *dev1.tellurium.com*.

11. Open up the TelluriumConfig.groovy. 
 
12. Change the values of the Selenium server and port to ensure the Tellurium requests for the new sessions from the Selenium HUB are received. 
 
13. Verify that the Selenium HUB points to Tellurium tests run on rc.tellurium.com based on the browser of choice.

14. Change the values for the following properties:

  # _runInternally_: ensures that the Selenium Server on the local machine is not launched.
  # _serverHost_: the selenium grid hub machine that has the information about the available selenium rc servers.
  # _port_: port that Selenium HUB is running on. By default, this port is 4444. This can be changed in the grid_configuraton.yml file if this port is not available on your HUB machine.
  # _browser_: the browser that comes under the configured environments list on the selenium HUB machine. These values can be changed to a userâs choice in the grid_configuration.yml file.

{{{
tellurium{

    //embedded selenium server configuration
    embeddedserver {

        //port number
        port = "4444"

        //whether to use multiple windows
        useMultiWindows = false

        //whether to run the embedded selenium server. 
        //If false, you need to manually set up a selenium server
        runInternally = false

        //profile location
        profile = ""

        //user-extension.js file
        userExtension = "target/classes/extension/user-extensions.js"
    }

    //event handler
    eventhandler{

        //whether we should check if the UI element is presented
        checkElement = false

        //wether we add additional events like "mouse over"
        extraEvent = true
    }

    //data accessor
    accessor{
        //whether we should check if the UI element is presented
        checkElement = true
    }

    //the configuration for the connector that connects the selenium client 
    //to the selenium server
    connector{
        //selenium server host
        //please change the host if you run the Selenium server remotely
        serverHost = "hub.tellurium.com"

        //server port number the client needs to connect
        port = "4444"

        //base URL
        baseUrl = "http://localhost:8080"

        //Browser setting, valid options are
        //  *firefox [absolute path]
        //  *iexplore [absolute path]
        //  *chrome
        //  *iehta
        browser = "Firefox on Windows"

        //user's class to hold custom selenium methods associated with user-extensions.js
        //should in full class name, for instance, "com.mycom.CustomSelenium"
        customClass = "org.tellurium.test.MyCommand"
    }
}}}

15. The set up is now complete.

16. Run the tests as usual using either the Maven command or the IDE. Notice that the tests are running on rc.tellurium.com and the list for Active Remote Controls is also updated on the hub URL ([http://hub.tellurium.com:4444/console http://hub.tellurium.com:4444/console]) during the test execution.

== Mock Http Server ==

This feature only exists in Tellurium Core 0.7.0 SNAPSHOT. The MockHttpServer is an embedded http server leveraging the Java 6 http server and it is very convenient method of testing HTML sources directly without running a web server. 

Tellurium defines two classes:

  # MockHttpHandler
  # MockHttpServer

=== Mock Http Handler Class ===

The MockHttpHandler class processes the http request:

{{{
public class MockHttpHandler implements HttpHandler {

  private Map<String, String> contents = new HashMap<String, String>();

  private String contentType = "text/html";

  public void handle(HttpExchange exchange) {
     ......
  }
}
}}}

The MockHttpHandler method is handle (HttpExchange exchange) and its actions are:

  * Reads the request URI
  * Finds the corresponding response HTML source from the hash map contents
  * Sends the response back to the http client

By default, the response is treated as an HTML source. The user can change this by using the following setter:

{{{public void setContentType(String contentType)}}}

MockHttpHandler includes two methods to add URI and its HTML source to the hash map contents:

  # public void registerBody(String url, String body)
  # public void registerHtml(String url, String html)

The MockHttpHandler comes with a default HTML template as follows:

{{{
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
    <head>
        <title>Mock HTTP Server</title>
    </head>

    <body>
        BODY_HTML_SOURCE   
    </body>
</html>
}}}

If {{{registerBody(String url, String body}}} is used, the MockHttpHandler uses the above HTML template to wrap the HTML body. Overwrite the default HTML template by calling {{{registerHtml(String url, String html)}}} directly, which uses the whole HTML source provided in the variable ''html''.

Usually, the MockHttpHandler is encapsulated by the MockHttpServer and the user does not need to work on it directly.

The MockHttpServer includes an embedded http server, a http handler, and a http port:

{{{
public class MockHttpServer {

  //default port
  private int port = 8080;

  private HttpServer server = null;
  private MockHttpHandler handler;

  public MockHttpServer() {
    this.handler = new MockHttpHandler();
    this.server = HttpServer.create();
  }

  public MockHttpServer(int port) {
    this.handler = new MockHttpHandler();
    this.port = port;
    this.server = HttpServer.create();
  }

  public MockHttpServer(int port, HttpHandler handler) {
    this.port = port;
    this.handler = handler;
    this.server = HttpServer.create();
  }

  ......
}
}}}

=== Mock Http Server ===

The MockHttpServer provides three different constructors so the user can overwrite the default values. The MockHttpServer encapsulates the MockHttpHander by providing the following methods:

  # public void setContentType(String contentType)
  # public void registerHtmlBody(String url, String body)
  # public void registerHtml(String url, String html)

The user can stop and start the server with the following methods:

  # public void start()
  # public void stop()

Use a modified version of a HTML source provided by one Tellurium user as an example and create the UI module Groovy class as follows:

{{{
public class ListModule extends DslContext {

  public static String LIST_BODY = """
<div class="thumbnails">
    <ul>
        <li class="thumbnail">
            <img alt="Image 1"
                 src="/images_root/image_pictures/01.jpg"/>
        </li>
        <li class="thumbnail">
            <img alt="Image 2"
                 src="/images_root/image_pictures/02.jpg"/>
        </li>
        <li class="thumbnail">
            <img alt="Image 3"
                 src="/images_root/image_pictures/03.jpg"/>
        </li>
        <li class="thumbnail">
        </li>
        <li class="thumbnail active">
            <img alt="Image 4"
                 src="/images_root/image_pictures/04.jpg"/>
        </li>
        <li class="thumbnail potd">
            <div class="potd-icon png-fix"/>
            <img alt="Image 5"
                 src="/images_root/image_pictures/05.jpg"/>
        </li>
    </ul>
</div>    
  """

  public void defineUi() {
    ui.Container(uid: "rotator", clocator: [tag: "div", class: "thumbnails"]) {
      List(uid: "tnails", clocator: [tag: "ul"], separator: "li") {
        UrlLink(uid: "all", clocator: [:])
      }
    }
  }
}
}}}

The reason the HTML source in a Groovy file is included is that the """ quote in Groovy is very easy to present complicated HTML source as a String variable. In Java, the user must concatenate each line of the HTML Source to make it a String variable.

The {{{defineUi()}}} defines the UI module for the given HTML source. The major part of the UI module is a List, which uses UI templates to represent a list of links. Tellurium makes it easy and concise to use UI templates to represent UI elements.
Based on the ListModule UI module, define a Tellurium JUnit test case as follows:

{{{
public class ListTestCase  extends TelluriumJavaTestCase {
    private static MockHttpServer server;

    @BeforeClass
    public static void setUp(){
        server = new MockHttpServer(8080);
        server.registerHtmlBody("/list.html", ListModule.LIST_BODY);
        server.start();
    }

    @Test
    public void testGetSeparatorAttribute(){
        ListModule lm = new ListModule();
        lm.defineUi();

        connectUrl("http://localhost:8080/list.html");

        attr = (String)lm.getParentAttribute("rotator.tnails[6]", "class");
        assertEquals("thumbnail potd", attr);
    }
    

    @AfterClass
    public static void tearDown(){
        server.stop();    
    }
}
}}}