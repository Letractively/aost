#labels Featured,Phase-Implementation
= Introduction =

*Abstract Object-based Selenium Test* (_AOST_) framework
  * Written in *Groovy*, test cases can be written in *Java* or *Groovy* 
  * Include a *Domain Specific Language* (_DSL_) to define UI objects 
  * Can also use the _DSL_ to describe events, actions, or assertions 
  * include an *Object to Locator Mapping framework* (_OLM_)
  * AOST can automatically generate the UI object locator for you
  * AOST implements the *group locating* concept to utilize a group of UI objects to help locating their locators
  * Make it possible for users to write Selenium tests when they start coding
  * Reusable, easier to refactor and maintain
  * Provide _DSL_ script executor so that non-developers can write Selenium tests in DSL

= Details =

== UI Objects ==

The UI Object includes
  * uid: should be unique in a UI module
  * namespace: for future extension
  * locator: the locator of the UI object, could be XPATH, CSS selector... The easier way to find the locator would be to use firefox XPather plugin.
  * Features: the inherent feature of the UI component, for example, the selection UI component normally comes with “label=?” or “value=?”. Table always has the “table”, “tr”, “td”, “th” tags.
  * useGroupInfo: this option only applies to a collection type of UI object such as Container, Table, List, Form and so on. By default, this option is turned off. If it is on, the object will use the UI objects to help locating its locator.

Regular UI objects include Button, CheckBox, Icon, InputBox, Selector, TextBox, Table... 
A container is a special UI object and it could be a pure abstract object to hold and group different UI objects together. The container will make the objects inside searchable since it uses a list to hold them.

Users can also define custom UI objects. They need to create a UI builder for each new UI 
object and add it to the UiObjectBuilderRegistry.

Be aware that each UI object only has predefined set of events or actions. For example, the InputBox has the _type_ action, but the Selector does not have that.

== DSL ==
 
DSL can only be run in *DslContext*, which defines the basic DSLs. 

=== Define UI objects ===
_ui.Container_ is used to define the UI objects on the web and map them to objects.
For example, the search module in the google start page can be defined by 
the following DSL.

{{{
ui.Container(uid: "google_search"){
   InputBox(uid: "inputbox1", locator: "//input[@title='Google Search']")
   Button(uid: "button1", locator: "//input[@name='btnG' and @type='submit']")
}
}}}

The definition can be nested, for example
{{{
ui.Container(uid: "parent_ui"){
   InputBox(uid: "inputbox1", locator: "...")
   Button(uid: "button1", locator: "...")
   Container(uid: "child_ui){
     Selector(uid: "selector1", locator: "...")
     ...
     Container(uid: "grand_child"){
       TextBox(uid: "textbox1", locator: "...")
       ...
     }
   }
}
}}}

=== Basic DSLs ===

Because of the Groovy Syntax, each method in the DslContext is a DSL expression.
For example, the _click_ method as follows:
{{{
def click(String id){
  ...
}
}}}
is a dsl in the format:
{{{
  click id
}}}

Similarly, we have the following dsls:
{{{
doubleClick id
clickAt id, coordination
check id
uncheck id
type id, input
keyType id, input
typeAndReturn id, input
clearText id
select id, target
selectByLabel  id, target
selectByValue id, target
waitForText id, timeout
isElementPresent id
isVisible id
isChecked id
waitForElementPresent id, timeout
waitForElementPresentid, timeout, step
getText id
getValue id
pause milliseconds
}}}

=== Extended DSLs ===
The DslContext can be extended to include more DSLs. For example, 
the DslScriptEngine extends DslContext to add the following DSL
{{{
openUrl url
}}}
and other assertions defined in GroovyTestCase.

=== UI Object Locators ===
There are two type of UI object locators:
  * Base Locator: the actual locator at run time
  * Composite Locator: User specifies a set of parameters for the object and the actual locator will be derived automatically by AOST.

The Basic Locator is only a String that you can specify the run time locator. But the Composite Locator is more complicated and its definition is as follows:
{{{
class CompositeLocator {
    String header
    String tag
    String text
    String trailer
    def position
    Map<String, String> attributes = [:]
}
}}}

For most UI object, the html tag is fixed, for example, a Table's tag is always "table". Header and Trailer are used to specify addition xpath related to this UI object and the final xpath is 
{{{
XPath = header + derived xpath for object + trailer
}}}

=== The Group Locating Concept (GLC) ===

The Group Locating Concept (GLC) concept comes from the simple observation, i.e., it is much easier to locate a collection of UI objects than a single UI object. The reason is multiple UI objects provide more search criteria to help you to locate the UIs. This concept is implemented in AOST. All collection type object, i.e., Container and its extended classes have an option to use the group locating concept. 

Let's see the differences between regular locating and group locating. Still take the google start page as an example:

{{{
ui.Container(uid: "google_start_page", clocator: [tag: "td"], group: "true"){
  InputBox(uid: "searchbox", clocator: [title: "Google Search"])
  SubmitButton(uid: "googlesearch", clocator: [name: "btnG", value: "Google Search"])
  SubmitButton(uid: "Imfeelinglucky", clocator: [value: "I'm Feeling Lucky"])
}

}}}

Here, clocator stands for composite locator. Without group locating, I can only use the given criteria 

{{{
tag = "td" 
}}}

to find the container locator, i.e., 
{{{
I am looking for a td html tag in the DOM
}}} 
which is quite difficult. If we use the group locating, the Container can use the group information provided by its children. Now, the problem becomes: 
{{{
  I am looking for a td html tag in the DOM and its children including an input box with
  title "Google Search", a submit button with name "btnG" and value "Google Search", and
  another submit button with value "I'm Feeling Lucky"
}}}
Woo! I have a lot of information to help me to locate the container. Once the container is found, all its children can be found very easily.

The direct result of group locating is that for most case, the information defined in the UI module itself is enough for you to locate all UI objects in that UI module. That is to say, your test code only depends on your own UI module, not its location and its outside. Even we change the UI, the test may still work.  

Another advantage is that you may be able to map your JSP, PHP, ASP,..., file directly to the UI module in AOST. This could help developers a lot for writing Selenium tests because they do not need to manually find the locator for an UI object. 

=== Define multiple UI modules in a single file ===
Initially, you can define only one UI module in a file that extends the DslContext class. Now, AOST supports multiple UI modules in a single file. This is extremely important for pure DSL scripts.

For example, you can define multiple UI modules as follows:
{{{
class AostProjectPage extends DslContext{
  public void defineUi() {
     //define the menu
     //It is fine to use Container to abstract Table if you have special table
     ui.Container(uid: "menu", clocator: [tag: "table", id: "mt", trailer: "/tbody/tr/th"], group: "true"){
     //since the actual text is  Project&nbsp;Home, we can use partial match here. Note "%%" stands for partial match
     UrlLink(uid: "project_home", clocator: [text: "%%Home"])
     UrlLink(uid: "downloads", clocator: [text: "Downloads"])
     UrlLink(uid: "wiki", clocator: [text: "Wiki"])
     UrlLink(uid: "issues", clocator: [text: "Issues"])
     UrlLink(uid: "source", clocator: [text: "Source"])
    }

    //define the search module, which includes an input box, two search buttons
    ui.Form(uid: "search", clocator: [:], group: "true"){
     InputBox(uid: "searchbox", clocator: [name: "q"])
     SubmitButton(uid: "search_project_button", clocator: [value: "Search Projects"])
     SubmitButton(uid: "search_web_button", clocator: [value: "Search the Web"])
    }
  }
}
}}}

== How to use ==

There are two ways to use AOST. The first one is first write your UI modules
in different Groovy files, which extends the DslContext class. Then write 
JUnit test cases. You can also include them in a test suite. 

If your test case only includes one file, you should use StandaloneAostSeleneseTestCase, but if you like to create multiple test files and put them in one test suite, you should use GroupAostSeleneseTestCase. The sample test suite is SampleAostSeleneseTestSuite. 
These limitations come from the fact that GroovyTestCase does not support JUnit 4 properly. Hope I can improve it or use TestNG later.

The other way is to write DSL script directly, which is recommended only for non-developers since you cannot create different modules if write in pure DSL. 
The DslScriptExecutor can be used to run the .dsl files.

== Examples ==

=== Google Start Page ===

First, create the google start page module in Groovy
{{{
package example.google

import aost.dsl.DslContext

class GoogleStartPage extends DslContext{

    public void defineUi() {
        ui.Container(uid: "google_start_page"){
            InputBox(uid: "inputbox1", locator: "//input[@title='Google Search']")
            Button(uid: "button1", locator: "//input[@name='btnG' and @type='submit']")
        }
    }

    def type(String input){
        type "inputbox1", input
        pause 500
        click "button1"
        pause 1000        
    }
}
}}}

Then, write the JUnit test case as follows,

{{{
package example.test

import example.google.GoogleStartPage
import aost.test.StandaloneAostSeleneseTestCase

class GoogleStartPageTestCase extends StandaloneAostSeleneseTestCase{

    protected static GoogleStartPage gsp

    public void initUi() {
        gsp = new GoogleStartPage()
        gsp.defineUi()

    }

    public void setUp(){
        setUpForClass()
    }

    public void tearDown(){
        tearDownForClass()
    }

    void testTypeGoogle(){
        connectUrl("http://www.google.com")
        gsp.type("google")
    }
}
}}}

Optionally, you can also write the DSL script file directly:all 

{{{
ui.Container(uid: "google_start_page"){
    InputBox(uid: "inputbox1", locator: "//input[@title='Google Search']")
    Button(uid: "button1", locator: "//input[@name='btnG' and @type='submit']")
}

openUrl "http://www.google.com"
type "inputbox1", "Cobrakai"
pause 500
click "button1"
pause 1000
}}}

Then use DslScriptExecutor to run it.

=== Google Code Hosting Page ===

The google code hosting page includes nested tables to show labels for 
projects. AOST supports nested IDs. For example XXX.YYY.ZZZ represents the fact that
the UI object YYY is inside XXX and it holds the ZZZ Ui object. Usually 
the id of the UI object is the one you specified in the ui.Container block.
The exceptions are tables and lists, which use {{{[x][y] or [x]}}} to reference
its elements inside.

The Ui module for the label tables is defined as

{{{
ui.Container(uid: "googlecodehosting"){
  //Upper level table 
  Table(id: "labels_table", locator: "//table[descendant::div[contains(text(),\"Example project labels:\")]]"){
    //Here we defined templates for the elements of the table
    //id: "row: 1, column: 1" means the TextBox is a template for
    //row 1, column 1.
    TextBox(uid: "row: 1, column: 1", locator: "/div")
    //inner table, which is a template for (row 2, column 1) of the outer table
    Table(uid: "row: 2, column: 1", locator: "/div[@id=\"popular\"]/table"){
       //"all" means this is the template for all table elements
       UrlLink(id: "all", locator: "/a")
    }
  }
}
}}}

The UI objects defined inside a table are actually templates for table elements.
Note the ids of the templates must follow the name convention:

  # Template for (i row, j column), the id should be "row: i, column: j"
  # The wild case (i.e., match all) for row or column is {{{"*"}}}, or you do not specify the row or column. For example, {{{"row : *, column: 3"}}} means template for (the 3rd column, all rows). "column: 3" means the same thing


  # "all" is used for matching all rows and columns

If no template is defined for a (row, column), it is assumed to be a TextBox by default.

When you look for an element's (row i, column j) Object-type in run-time, the following
rules apply:

  # First, the system will try to find the template defined for (row i, column j),return it if found.
  # Otherwise, the system will try the template for (all rows, column j), return it if found.
  # If not, the system will try the template for (row i, all columns), return it if found.
  # If still cannot find, the system will try the template for "all", return it if found.
  # Last, if no template could be found. Return the TextBox as the default template.
  
The module functions are defined as follows,

{{{
    public String getModuleLabel(){
        getText "labels_table[1][1]"
    }

    public int getLabelTableRowNum(){
        getTableMaxRowNum "labels_table[2][1]"
    }

    public int getLabelTableColumnNum(){
        getTableMaxColumnNum "labels_table[2][1]"
    }

    def getTableElement(int row, int column){
        getTableElement "labels_table[2][1].[${row}][${column}]"
    }

    Map getAllLabels(){
        int nrow = getTableMaxRowNum("labels_table[2][1]")
        int ncolumn = getTableMaxColumnNum("labels_table[2][1]")

        def map = [:]
        for(int i=1; i<=nrow; i++){
            for(int j=1; j<=ncolumn; j++){
                String label = getText("labels_table[2][1].[${i}][${j}]")
                map.put(label, [i, j])
            }
        }

        return map
    }

    void clickOnLable(int row, int column){
        click  "labels_table[2][1].[${row}][${column}]"
        pause 5000
    }

}}}

The actual test case is 

{{{
class GoogleCodeHostingTestCase extends StandaloneAostSeleneseTestCase {

    protected static GoogleCodeHosting gch

    public void initUi() {
        gch = new GoogleCodeHosting()
        gch.defineUi()

    }

    public void setUp(){
        setUpForClass()
    }

    public void tearDown(){
        tearDownForClass()
    }

    void testCodeLabelTable(){
        connectUrl("http://code.google.com/hosting/")
        String label = gch.getModuleLabel()
        assertEquals("Example project labels:", label)
        
        int nrow = gch.getLabelTableRowNum()
        assertEquals(3, nrow)

        int ncolumn = gch.getLabelTableColumnNum()
        assertEquals(6, ncolumn)
        
        for(int i=1; i<=nrow; i++){
            for(int j=1; j<=ncolumn; j++){
               def obj = gch.getTableElement(i, j)
               assertTrue(obj instanceof UrlLink)
            }
        }
        Map map = gch.getAllLabels()
        assertEquals(18, map.size())

        int[] index = map.get("Java")
        assertNotNull(index)
        assertEquals(2, index.length)

        //click on "Java" link
        gch.clickOnLable(index[0], index[1])
    }
}
}}}

=== Google Book List Page ===

The Google Book List test case is used to demonstrate the List UI object. 
The List UI object likes the Table, but it is one dimension. For example, you 
need to use {{{list1[2]}}} format to represent the UI object id inside the list.
Also, the List comes with an option "separator", which is used to indicate the delimiter for different elements in the list.

The portion of book category "Fiction" is chosen as our demo, which is defined as:
{{{
ui.Container(uid: "GoogleBooksList", locator: "//table[@id='hp_table']/tbody/tr/td[1]/div/div[1]"){
    TextBox(uid: "category", locator: "/div")
    List(uid: "subcategory", locator: "", separator: "/p"){
      //"all" means it is the template for all elements in the list
      UrlLink(uid: "all", locator: "/a")
    }
  }
}

}}}

Similar to the Table example, the UrlLink inside the List "subcategory" defines a template
for elements in the List. ID "all" means it is for all elements. Otherwise, you should specify the index of the element that template applies for. When the system tries to find the UI object for {{{List[x]}}} in runtime, it first checks if there is a template for index {{{x}}}, if not, it then tries the "all" template. If no template found, it returns a TextBox as the default object.

The actions in the module is defined as
{{{
    String getCategory(){
        getText "GoogleBooksList.category"
    }

    int getListSize(){
        getListSize "GoogleBooksList.subcategory"
    }

    def getAllObjectInList(){
        int size = getListSize()
        List list = new ArrayList()
        for(int i=1; i<=size; i++){
           list.add(getUiElement("GoogleBooksList.subcategory[${i}]"))
        }

        return list
    }

    def clickList(int index){
        click "GoogleBooksList.subcategory[${index}]"
        pause 5000
    }

    String getText(int index){
        getText "GoogleBooksList.subcategory[${index}]"
    }

}}}

And the test case is as follows, 

{{{
class GoogleBooksListTestCase extends StandaloneAostSeleneseTestCase {

    protected GoogleBooksList gbl

    public void initUi() {
        gbl = new GoogleBooksList()
        gbl.defineUi()

    }

    public void setUp(){
        setUpForClass()
    }

    public void tearDown(){
        tearDownForClass()
    }

    void testBookCategory(){
        connectUrl("http://books.google.com/")
        String category = gbl.getCategory()
        assertEquals("Fiction", category)

        int size = gbl.getListSize()
        
        assertEquals(8, size)

        List lst = gbl.getAllObjectInList()

        assertNotNull(lst)

        int index
        String search =  "Poetry"
        int i = 1
        for(UiObject obj : lst){
            assertTrue(obj instanceof UrlLink)
            if(search.equals(gbl.getText(i))){
                index = i
                break
            }
            i++
        }

        gbl.clickList(index)
    }
}
}}}  

Please see the source code on the subversion trunk for details