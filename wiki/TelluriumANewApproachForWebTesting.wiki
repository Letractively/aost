#summary Tellurium: A New Approach for Web Testing.
#labels Phase-Implementation,Phase-Support

= Introduction =

== Challenges and Problems ==

Automated web testing has always been one of the most important and hot topics in software testing arena with web becoming one indispensable part of most people's lives. Web techniques keep moving forward and more and more dynamic web techniques are adopted by web developers. For example, Ajax is one of the most important ones. 

With the advent of new web techniques, automated web testing tools must keep up with the improvement and be able to address the following challenges imposed by the automated web testing nature and new web techniques:

  * *Javascript Events*: Javascript events are the foundation of all Javascript frameworks and are everywhere in today's web. The automated testing framework should be able to trigger the events in a very convenient way.
  * *Ajax for Dynamic Web Content*: Ajax is a convenient way to update the part of the web page without refresh the whole page. The web context for an Ajax application is usually dynamic. For example, in a data grid, the number of rows and data keep changing at runtime. 
  * *Robust to Changes*: A good automated web testing tool should be able to address the changes in the web context to some degree so that users do not need to keep updating the test code.
  * *Easy to Maintain*: In an agile world, the software are developed in multiple scrums with new features added on in each scrum. The functional tests or user acceptance tests must be refactored and updated for new features. The testing framework should provide the flexibility for users to maintain the test code very easily.
  * *Re-usability*: Many web applications use the same UI module for different part of the application. The adoption of Javascript frameworks such as Dojo and ExtJS increases the chance to use the same UI module for difference applications. A good testing framework should also be able to provide re-usability of test modules.
  * *Expressiveness*: The testing framework should be able to provide the users without too much coding experience to write test code/scripts easily in a way that they are familiar with, for example, use a domain specific language (DSL).

== Existing Open source Automated Web Testing Frameworks ==

The Selenium framework is the most popular open source automated web testing framework and it was a ground-breaking framework and it offered many unique features such as browser based testing, Selenium Grid, and "record and replay" testing mode using Selenium IDE. As a pioneer framework, it inevitably comes with some shortcomings. One important one is that it focuses on individual UI elements such as links and buttons, as a result, it is to address dynamic web content in Selenium. The "record and replay" testing mode does make it much easier for users, especially non-developers, to create a test case, however, it also suffers drawbacks such as difficult to refactor and maintain. Other downsides include the coupling of UI elements and test code, verbose, and fragile to changes. 

Take the following Selenium test code as an example,

{{{
   setUp("http://www.google.com/", "*chrome");
   selenium.open("/");
   selenium.click("//input[@value='Google Search' and @type='button']");
   selenium.type("q", "Selenium test");
}}}

Do you know clearly what UI module is under testing? What does the locator â€œq" mean here? And what if the XPath "//input[@value='Google Search' and @type='button']" becomes invalid due to changes on the web? As a result, the Selenium test code is easy to create using Selenium IDE, but hard to generalize and refactor, which proved to be as tedious and painful as to re-generate a new test code from scratch because of the hard-coded locators and the coupling of locator with test code. Maintenance was a headache as well because the test code was not structured. Due to the nature of testing individual UI elements, Selenium is also difficult to address dynamic web context. 

Canoo WebTest is another popular open source tool for automated testing of web applications. But it also focuses on individual UI elements and thus it suffers many similar shortcomings as Selenium, for example, test code couple with UI. Here is a sample test code,

{{{

    webtest("check that WebTest is Google's top 'WebTest' result"){
       invoke "http://www.google.com", description: "Go to Google"
       verifyTitle "Google"
       setInputField name: "q", value: "WebTest"
       clickButton "I'm Feeling Lucky"
       verifyTitle "Canoo WebTest"
    }
}}}

Twill is a simple scripting language that allows users to browse the Web from a command-line interface and it uses link, forms, cookies, and most standard Web features. It also deals with individual UI elements, need to parsing html interactively, and only support Python, which make Twill not really convenient to test practical web applications. Here is a sample Twill test code

{{{
setlocal query "twill Python"
go http://www.google.com/
fv 1 q $query
submit btnI # use the "I'm feeling lucky" button
show
}}}

== Tellurium ==

The Tellurium Automated Testing Framework (Tellurium) is an open source automated testing framework for web applications to address the challenges and problems in web testing. Tellurium is created with the following motivations:

  * Robust to changes and allow changes to be localized
  * Address dynamic web context such as JavaScript events and Ajax 
  * Easy to refactor and maintain
  * Modular and test modules are reusable 
  * Expressive and easy to use

Most web testing tools/frameworks focus on individual UI elements such as links and buttons. Tellurium takes a new approach for automated web testing using the UI module.  The UI module is a collection of UI elements grouped together. Usually, the UI module represents a composite UI object in the format of nested basic UI elements. For example, the Google search UI module can be expressed as follows,

{{{
ui.Container(uid: "GoogleSearchModule", clocator: [tag: "td"], group: "true"){
   InputBox(uid: "Input", clocator: [title: "Google Search"])
   SubmitButton(uid: "Search", clocator: [name: "btnG", value: "Google Search"])
   SubmitButton(uid: "ImFeelingLucky", clocator: [value: "I'm Feeling Lucky"])
}
}}}
 
Tellurium is built on the foundation of the UI module.  The UI module makes it possible to build locators for UI elements at runtime.  First, this makes Tellurium robust and responsive to changes from internal UI elements.  Second, the UI module makes Tellurium expressive.  A UI element can be referred to simply by appending the names (uid) along the path to the specific element. This also enables Tellurium's "Group Locating" feature, making composite objects reusable, and addressing dynamic web pages.

Tellurium is implemented in Groovy and Java.  The test cases can be written in Java, Groovy, or pure "Domain Specific Language (DSL)" scripts.  Tellurium evolved out of Selenium, but the UI testing approach is completely different. For example, Tellurium is not a "record and replay" style framework, and it enforces the separation of UI modules from test code, making refactoring easy. For example, once you defined the Google Search UI module shown above, you can write your test code as follows,

{{{
type "GoogleSearchModule.Input", "Tellurium test"
click "GoogleSearchModule.Search"
}}} 

Tellurium does "Object to Locator Mapping (OLM)" automatically at run time so that UI objects can be defined simply by their attributes using "Composite Locators." Tellurium uses the "Group Locating Concept (GLC)" to exploit information inside a collection of UI components so that locators can find their elements.  It also defines a set of DSLs for web testing.  Furthermore, Tellurium uses UI templates to define sets of dynamic UI elements at runtime.  As a result, Tellurium is robust, expressive, flexible, reusable, and easy to maintain. 
    
The main features of Tellurium include:

  * Abstract UI objects to encapsulate web UI elements
  * DSL for UI definition, actions, and testing
  * Composite Locator to use a set of attributes to describe a UI element
  * Group locating to exploit information inside a collection of UI components
  * Dynamically generate runtime locators to localize changes
  * UI module for structured test code and re-usability
  * UI templates for dynamic web content
  * XPath support
  * jQuery selector support to improve test speed in IE
  * Locator caching to improve speed
  * Javascript event support
  * Use Tellurium Firefox plugin, Trump, to automatically generate UI modules
  * Dojo and ExtJS widget extensions    
  * Data driven test support 
  * Selenium Grid support
  * JUnit and TestNG support
  * Ant and Maven support
 