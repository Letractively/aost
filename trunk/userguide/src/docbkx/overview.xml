<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">

    <title>What is Tellurium</title>
    <para>
        <link xlink:href="http://code.google.com/p/aost/">The Tellurium Automated Testing Framework
        </link>
        (Tellurium) is an automated testing framework for web applications. Tellurium grew up from
        <link xlink:href="http://seleniumhq.org/">the Selenium framework</link>, but with a different
        testing concept. Starting from Tellurium 0.7.0, Tellurium added Tellurium Engine to replace
        the Selenium Core to better support Tellurium.
    </para>

    <para>For most existing web testing frameworks like Selenium, they mainly focus on individual UI elements as
        follows.
        For most existing web testing frameworks like Selenium, they mainly focus on individual UI elements as follows.
    </para>

    <mediaobject>
        <imageobject>
            <imagedata fileref="./media/tellurium3.png" scalefit="1" width="100%"></imagedata>
        </imageobject>
    </mediaobject>

    <para>For example:</para>
    <programlisting>
<![CDATA[
    selenium.click("//div[3]/input[@value='Create']");
]]>
    </programlisting>

    <para>For Tellurium, we treated the whole UI elements as a widget and we call it a UI module.</para>

    <mediaobject>
        <imageobject>
            <imagedata fileref="./media/tellurium4.png" scalefit="1" width="100%"></imagedata>
        </imageobject>
    </mediaobject>

    <para>We define the UI module as follows.</para>
    <programlisting>
<![CDATA[
    ui.Form(uid: "Form", clocator: [tag: "form"]){
        Div(uid: "User", clocator: [:]){
            Selector(uid: "Sex", clocator: [:])
            InputBox(uid: "Input", clocator: [tag: "input", type: "text",
                name: "j_username"])
        }
        Container(uid: "Finish", clocator: [tag: "tr"]){
            SubmitButton(uid: "Submit", clocator: [tag: "input", type: "submit",
                value: "Login", name: "submit"])
        }
    }            
]]>
</programlisting>

    <para>If we think Selenium as the &quot;C&quot; language, Tellurium
        is like the &quot;C++&quot; language, which uses a different testing concept. There are
        couple advantages to describe the UI elements as a UI module.
    </para>
    <para>
        <emphasis>Expressive</emphasis>
        is obvious. For example, you can see clearly what the UI you are testing against. For the
        test code, you have DSL style test code such as:
    </para>

     <programlisting>
<![CDATA[
    type "Form.User.Input", "TelluriumSource"
]]>
    </programlisting>
    <para>
        <emphasis>Robust to Changes</emphasis>
        Test robust is always a big issue for Selenium. To
        solve this problem is one of the main motivations that Tellurium was created for. Tellurium
        uses UI attributes to describe UI instead of fixed locators. If we change the attributes,
        new runtime locators will be generated by the framework so that Tellurium can self-adapt to
        UI changes to some degree.
        <link xlink:href="http://code.google.com/p/aost/wiki/SantaUiModuleGroupLocatingAlgorithm">The Santa algorithm</link>
        in Tellurium new engine further improves the test robust by using UI partial matching.
    </para>
    <para>
        <emphasis>Represent Dynamic Web Content Easily</emphasis>
        The
        <link xlink:href="http://code.google.com/p/aost/wiki/UserGuide070TelluriumBasics#UI_Templates">Tellurium UI
            templates
        </link>
        are used to represent dynamic web content very easily. For example,
        <link xlink:href="http://code.google.com/p/aost/issues/list">Tellurium issue search result
            widget
        </link>
        can be easily represented as follows.
    </para>

     <programlisting>
<![CDATA[
    ui.Table(uid: "issueResult", clocator: [id: "resultstable", class: "results"], group: "true") {
      //Define the header elements
      UrlLink(uid: "{header: any} as ID", clocator: [text: "*ID"])
      UrlLink(uid: "{header: any} as Type", clocator: [text: "*Type"])
      UrlLink(uid: "{header: any} as Status", clocator: [text: "*Status"])
      UrlLink(uid: "{header: any} as Priority", clocator: [text: "*Priority"])
      UrlLink(uid: "{header: any} as Milestone", clocator: [text: "*Milestone"])
      UrlLink(uid: "{header: any} as Owner", clocator: [text: "*Owner"])
      UrlLink(uid: "{header: any} as Summary", clocator: [text: "*Summary + Labels"])
      UrlLink(uid: "{header: any} as Extra", clocator: [text: "*..."])

      //Define table body elements
      //Column "Extra" are TextBoxs
      TextBox(uid: "{row: all, column -> Extra}", clocator: [:])
      //For the rest, they are UrlLinks
      UrlLink(uid: "{row: all, column: all}", clocator: [:])
    }    
]]>
    </programlisting>

    <para>
        <emphasis>Easy to Maintain</emphasis>
        Tellurium emphasizes the decoupling of UI from test code. The structured test code makes Tellurium easier to
        maintain and refactor.
    </para>

    <para>
        <emphasis>Motivation</emphasis>
        Automated web testing has always been one of the hottest
        and most important topics in the software testing arena when it comes to the rising
        popularity of Rich Internet applications (RIA) and Ajax-based web applications. With the
        advent of new web techniques such as RIA and Ajax, automated web testing tools must keep
        current with changes in technology and be able to address the following challenges:
    </para>
    <itemizedlist>
        <listitem>
            <para>
                <emphasis role="bold">JavaScript Events</emphasis>: JavaScript is everywhere on the
                web today. Many web applications are JavaScript heavy. To test JavaScript, the
                automated testing framework should be able to trigger JavaScript events in a
                convenient way.
            </para>
        </listitem>
        <listitem>
            <para>
                <emphasis role="bold">Ajax for Dynamic Web Content</emphasis>: Web applications have
                many benefits over desktop applications. For example, these applications have no
                installation and updates are instantaneous and easier to support. Ajax is a
                convenient way to update a part of the web page without refreshing the whole page.
                AJAX makes web applications richer and more user-friendly. The web context for an
                Ajax application is usually dynamic. For example, in a data grid, the data and
                number of rows keeps changing at runtime.
            </para>
        </listitem>
        <listitem>
            <para>
                <emphasis role="bold">Robust/Responsive to Changes</emphasis>: A good automated
                web-testing tool should be able to address the changes in the web context to some
                degree so that users do not need to keep updating the test code.
            </para>
        </listitem>
        <listitem>
            <para>
                <emphasis role="bold">Easy to Maintain</emphasis>: In an agile testing world,
                software development is based on iterations, and new features are added on in each
                sprint. The functional tests or user acceptance tests must be refactored and updated
                for the new features. The testing framework should provide the flexibility for users
                to maintain the test code easily.
            </para>
        </listitem>
        <listitem>
            <para>
                <emphasis role="bold">Re-usability</emphasis>: Many web applications use the same UI
                module for different parts of the application. The adoption of JavaScript frameworks
                such as Dojo and ExtJS increases the chance of using the same UI module for
                different web applications. A good testing framework should also be able to provide
                the re-usability of test modules.
            </para>
        </listitem>
        <listitem>
            <para>
                <emphasis role="bold">Expressiveness</emphasis>: The testing framework provides
                users without much coding experience the ability to easily write test code or
                scripts in a familiar way, such as using a domain specific language (DSL).
            </para>
        </listitem>
    </itemizedlist>
    <para>The Tellurium Automated Testing Framework
        (Tellurium) is designed around these considerations and has defined as its focus the
        following goals:
    </para>
    <itemizedlist>
        <listitem>
            <para>
                Robust/responsive to changes; allow changes to be localized
            </para>
        </listitem>
        <listitem>
            <para>
                Addresses dynamic web contexts such as JavaScript events and Ajax
            </para>
        </listitem>
        <listitem>
            <para>Easy to refactor and maintain
            </para>
        </listitem>
        <listitem>
            <para>
                Modular; test modules are reusable
            </para>
        </listitem>
        <listitem>
            <para>Expressive and easy to use
            </para>
        </listitem>
    </itemizedlist>

</section>