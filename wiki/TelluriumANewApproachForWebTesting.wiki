#summary Tellurium: A New Approach for Web Testing.
#labels Phase-Implementation,Phase-Support
<wiki:toc max_depth="5" />

= Introduction =

== Challenges and Problems ==

Automated web testing has always been one of the most important and hot topics in software testing arena with web becoming one indispensable part of most people's lives. Web techniques keep moving forward and more and more dynamic web techniques are adopted by web developers. For example, Ajax is one of the most important ones. 

With the advent of new web techniques, automated web testing tools must keep up with the improvement and be able to address the following challenges imposed by the automated web testing nature and new web techniques:

  * *Javascript Events*: Javascript events are the foundation of all Javascript frameworks and are everywhere in today's web. The automated testing framework should be able to trigger the events in a very convenient way.
  * *Ajax for Dynamic Web Content*: Ajax is a convenient way to update the part of the web page without refresh the whole page. The web context for an Ajax application is usually dynamic. For example, in a data grid, the number of rows and data keep changing at runtime. 
  * *Robust to Changes*: A good automated web testing tool should be able to address the changes in the web context to some degree so that users do not need to keep updating the test code.
  * *Easy to Maintain*: In an agile world, the software are developed in multiple scrums with new features added on in each scrum. The functional tests or user acceptance tests must be refactored and updated for new features. The testing framework should provide the flexibility for users to maintain the test code very easily.
  * *Re-usability*: Many web applications use the same UI module for different part of the application. The adoption of Javascript frameworks such as Dojo and ExtJS increases the chance to use the same UI module for difference applications. A good testing framework should also be able to provide re-usability of test modules.
  * *Expressiveness*: The testing framework should be able to provide the users without too much coding experience to write test code/scripts easily in a way that they are familiar with, for example, use a domain specific language (DSL).

== Existing Open source Automated Web Testing Frameworks ==

The Selenium framework is the most popular open source automated web testing framework and it was a ground-breaking framework and it offered many unique features such as browser based testing, Selenium Grid, and "record and replay" testing mode using Selenium IDE. As a pioneer framework, it inevitably comes with some shortcomings. One important one is that it focuses on individual UI elements such as links and buttons, as a result, it is to address dynamic web content in Selenium. The "record and replay" testing mode does make it much easier for users, especially non-developers, to create a test case, however, it also suffers drawbacks such as difficult to refactor and maintain. Other downsides include the coupling of UI elements and test code, verbose, and fragile to changes. 

Take the following Selenium test code as an example,

{{{
   setUp("http://www.google.com/", "*chrome");
   selenium.open("/");
   selenium.click("//input[@value='Google Search' and @type='button']");
   selenium.type("q", "Selenium test");
}}}

Do you know clearly what UI module is under testing? What does the locator “q" mean here? And what if the XPath "//input[@value='Google Search' and @type='button']" becomes invalid due to changes on the web? As a result, the Selenium test code is easy to create using Selenium IDE, but hard to generalize and refactor, which proved to be as tedious and painful as to re-generate a new test code from scratch because of the hard-coded locators and the coupling of locator with test code. Maintenance was a headache as well because the test code was not structured. Due to the nature of testing individual UI elements, Selenium is also difficult to address dynamic web context. 

Canoo WebTest is another popular open source tool for automated testing of web applications. But it also focuses on individual UI elements and thus it suffers many similar shortcomings as Selenium, for example, test code couple with UI. Here is a sample test code,

{{{

    webtest("check that WebTest is Google's top 'WebTest' result"){
       invoke "http://www.google.com", description: "Go to Google"
       verifyTitle "Google"
       setInputField name: "q", value: "WebTest"
       clickButton "I'm Feeling Lucky"
       verifyTitle "Canoo WebTest"
    }
}}}

Twill is a simple scripting language that allows users to browse the Web from a command-line interface and it uses link, forms, cookies, and most standard Web features. It also deals with individual UI elements, need to parsing html interactively, and only support Python, which make Twill not really convenient to test practical web applications. Here is a sample Twill test code

{{{
setlocal query "twill Python"
go http://www.google.com/
fv 1 q $query
submit btnI # use the "I'm feeling lucky" button
show
}}}

== Motivations ==

Since the existing automated testing frameworks cannot address the challenges and problems very well. We really need a new automated testing framework to address them with the following motivations:

  * Robust to changes and allow changes to be localized
  * Address dynamic web context such as JavaScript events and Ajax 
  * Easy to refactor and maintain
  * Modular and test modules are reusable 
  * Expressive and easy to use

Our answer is the Tellurium Automated Testing Framework (Tellurium). In the next sections, we will first give a brief introduction of Tellurium and how it addresses the challenges and problems in web testing, then go over more details about Tellurium including its architecture, new concepts, and how to obtain and use Tellurium followed by detailed tutorials with code samples. Finally, we end this article with future directions.

= A New Approach for Web Testing =

== Why Tellurium is a New Approach for Web Testing ==
 
The Tellurium Automated Testing Framework (Tellurium) is an open source automated testing framework for web applications to address the challenges and problems in web testing. 

Most existing web testing tools/frameworks focus on individual UI elements such as links and buttons. Tellurium takes a new approach for automated web testing using the UI module.  The UI module is a collection of UI elements grouped together. Usually, the UI module represents a composite UI object in the format of nested basic UI elements. For example, the Google search UI module can be expressed as follows,

{{{
ui.Container(uid: "GoogleSearchModule", clocator: [tag: "td"], group: "true"){
   InputBox(uid: "Input", clocator: [title: "Google Search"])
   SubmitButton(uid: "Search", clocator: [name: "btnG", value: "Google Search"])
   SubmitButton(uid: "ImFeelingLucky", clocator: [value: "I'm Feeling Lucky"])
}
}}}
 
Tellurium is built on the foundation of the UI module.  The UI module makes it possible to build locators for UI elements at runtime.  First, this makes Tellurium robust and responsive to changes from internal UI elements.  Second, the UI module makes Tellurium expressive.  A UI element can be referred to simply by appending the names (uid) along the path to the specific element. This also enables Tellurium's "Group Locating" feature, making composite objects reusable, and addressing dynamic web pages.

Tellurium is implemented in Groovy and Java.  The test cases can be written in Java, Groovy, or pure "Domain Specific Language (DSL)" scripts.  Tellurium evolved out of Selenium, but the UI testing approach is completely different. For example, Tellurium is not a "record and replay" style framework, and it enforces the separation of UI modules from test code, making refactoring easy. For example, once you defined the Google Search UI module shown above, you can write your test code as follows,

{{{
type "GoogleSearchModule.Input", "Tellurium test"
click "GoogleSearchModule.Search"
}}} 

Tellurium does "Object to Locator Mapping (OLM)" automatically at run time so that UI objects can be defined simply by their attributes using "Composite Locators." Tellurium uses the "Group Locating Concept (GLC)" to exploit information inside a collection of UI components so that locators can find their elements.  It also defines a set of DSLs for web testing.  Furthermore, Tellurium uses UI templates to define sets of dynamic UI elements at runtime.  As a result, Tellurium is robust, expressive, flexible, reusable, and easy to maintain. 
    
The main features of Tellurium include:

  * Abstract UI objects to encapsulate web UI elements
  * DSL for UI definition, actions, and testing
  * Composite Locator to use a set of attributes to describe a UI element
  * Group locating to exploit information inside a collection of UI components
  * Dynamically generate runtime locators to localize changes
  * UI module for structured test code and re-usability
  * UI templates for dynamic web content
  * XPath support
  * jQuery selector support to improve test speed in IE
  * Locator caching to improve speed
  * Javascript event support
  * Use Tellurium Firefox plugin, Trump, to automatically generate UI modules
  * Dojo and ExtJS widget extensions    
  * Data driven test support 
  * Selenium Grid support
  * JUnit and TestNG support
  * Ant and Maven support

== How Challenges and Problems are addressed in Tellurium ? ==
 
Back to the challenges and problems, how are they addressed in Tellurium? First of all, Tellurium does not use the "record and replay" style. Instead, it uses Tellurium Firefox plugin Trump to generate the UI module, not the test code for you. Then you need to create your test code based on the UI module. In this way, the UI and the test code are decoupled. The structured test code in Tellurium make it much easier to refactor and maintain the code.

The composite locator uses UI element attributes to define UI and the actual locator, i.e., xpath or jQuery selector, will be generated at runtime. Any updates to the composite locator will lead to different runtime locators and the changes inside the UI module are localized. The Group locating is used to remove the dependency of the UI objects from external UI elements, i.e., external UI changes will not affect the current UI module for most cases so that your test code is robust to changes up to certain level.

Tellurium use the “respond” attribute in UI object for you to specify JavaScript events and the rest will be handled automatically by the framework itself. UI templates is a powerful feature in Tellurium to represent many identical UI elements or dynamic size of different UI elements at runtime, which are extremely useful to test dynamic web context such as a data grid. The “Option” UI object is designed to automatically address dynamic web with multiple possible UI patterns.

The re-usability is achieved by UI module for the same application and Tellurium Widgets for different web applications. With the Domain Specific Language (DSL) in Tellurium, you can define UI module and write test code in a very expressive way. Tellurium also provides you the flexibility to write test code in Java, Groovy, or pure DSL scripts.

== Tellurium Architecture ==

he Tellurium framework Architecture is shown as in Figure 1.

http://tellurium-users.googlegroups.com/web/tellurium.architecture.png?gda=1NP4x0sAAAAFkHkURP2WlgYU-UhtQDFJganRixm7ZVzXjIzQXs5CXWG1qiJ7UbTIup-M2XPURDThcsDHHqasJHRvnmR6jbzWzHqwysTvAgdPZHbdH4XvXg&gsc=26Y4eBYAAAAkGgIQNXlg3kIha08SEZtI9pmI1qD38G08ONb6YfjJaQ

Figure 1. Tellurium Architecture.

The system diagram of Tellurium consists of three parts, one is the Selenium Server, on which our Tellurium framework builds, the Tellurium framework, and user defined Java test cases or .dsl pure DSL test scripts. 

The Tellurium Framework is based on the DslContext, which defines all DSLs we can use for Tellurium. We can further divide the Tellurium Framework into Four parts.

=== UI Object Parser ===

This parts consists of the DSL Object Parser, Object Builders, and the Object Registry.

Thanks to Groovy’s builder pattern, we can define UI object expressively and in a nested fashion. The DSL object parser will parse the DSL object definition recursively and use object builders to build the objects on the fly. An object builder registry is designed to hold all predefined UI object builders in the Tellurium framework and the DSL object parser will look at the builder registry to find the appropriate builders. Since the registry is a hash map, you can override a builder with a new one using the same UI name. Users can also add their customer builders into the builder registry.
 
The DSL object definition always comes first with a container type object. An object registry (A hash map) is used to stored all top level UI Objects. As a result, for each DSL object definition, the top object ids must be unique in the DslContext. The object registry will be used by the framework to search objects by their ids and fetch objects for different actions.

=== Object Locator Mapping ===

The Object Locator Mapping (OLM) is the core of the Tellurium framework and it includes UI ID mapping, XPath builder, Locator Processor, and Group Locating. The UI ID supports nested object, for example, "menu.wiki" stands for a URL Link "wiki" inside a container called "menu". The UI ID also supports one dimension and two dimension index for table and list. For example, {{{"main.table[2][3]"}}} stands the UI object of the 2nd row and the 3rd column of a table inside the container "main".

XPath builder can build the XPath from relative XPaths or from attributes. The locator processor converts the locator information in the UI object to the XPath. The Group Locating Concept (GLC) is to exploit the group information in side a collection of UI objects to help us find the locator of the collection of UI objects. 

=== Event and Data Handling ===

The Eventhandler in this part will handle all events like "click", "type", "select", and so on. The Data Accessor is used to fetch data or UI status from the DOM. The dispatcher will delegate all calls it receives from the Eventhandler and the data accessor to the Selenium Client, which will connect to the Selenium Server. The dispatcher is designed to decouple the rest of the Tellurium framework with the Selenium framework so that we can simply change the dispatcher logic to delegate all calls to other underneath UI test frameworks if we want to switch Tellurium not to use the Selenium framework someday.

== Tellurium Subprojects ==

Tellurium began as a small core project over a year ago and quickly spawned multiple sub-projects including: [http://code.google.com/p/aost/wiki/UserGuide Core], [http://code.google.com/p/aost/wiki/ReferenceProjectGuide Reference projects], [http://code.google.com/p/aost/wiki/TelluriumWidget Widget extensions], [http://code.google.com/p/aost/wiki/TrUMP TrUMP], and Engine projects as shown in the following diagram,

http://tellurium-users.googlegroups.com/web/TelluriumSubprojects.png?gda=KOo7BEoAAAD5mhXrH3CK0rVx4StVj0LYlNqOmuvSTE_gHzistV7TYU3GrA4woUylGAUAJF3_rdDbYV_6pXuFBwitfyYTkV3q_e3Wg0GnqfdKOwDqUih1tA&gsc=JDDH5gsAAACcJEKey8RXDXypkrHyWRpX

  * Tellurium Engine: Based on Selenium Core with UI module, jQuery selector, command bundle, and exception hierarchy support.
   * Tellurium Core: UI module, APIs, DSL, Object to Runtime Locator mapping, and test support.
  * Tellurium Extensions: Dojo Javascript widgets and ExtJS Javascript widgets.
  * Tellurium UI Module Plugin (TrUMP): A Firefox plugin to automatically generate the UI module after users select the UI elements from the web under testing.
  * Tellurium Maven Archetypes: Maven archetypes to generate skeleton Tellurium JUnit and Tellurium TestNG projects using one Maven command.
  * Tellurium Reference Projects: Use Tellurium project site as examples to illustrate how to use different features in Tellurium and how to create Tellurium test cases.

== Tellurium Community ==

Tellurium cannot reach today's stage without our users' support. Our users' comments and suggestions have shaped the Tellurium framework in many different ways and various aspects. 

Tellurium is attracting more and more contributors and users. We have over 15,000 pageviews of our project website each month, and the number keeps growing.  With many new contributors joining our project from different parts of the world, we expect Tellurium will grow even more rapidly. 

= Tellurium Concepts =

== Tellurium UI Objects==

Tellurium provides a set of predefined Ui objects, which users can use directly. Here we describe them one by one in details.

=== Basic UI Object ===

The basic UI object is an abstract class and users cannot instantiate it directly. The basic UI Object works as the base class for all Ui objects and it includes the following attributes:

  # uid: UI object's identifier
  # namespace: for future extension
  # locator: the locator of the UI object, could be a base locator or a composite locator
  # respond: the JavaScript events the UI object can respond to. The value is a list.

All UI Objects will inherit the above attributes and methods. But be aware that you usually do not call these methods directly and you should use DSL syntax instead. For example, use

{{{
click "GoogleSearchModule.Search"
}}}

In this way, Tellurium will first map the UiID "GoogleSearchModule.Search" to the actual UI object and then call the _click_ method on it. If that Ui object does not have the _click_ method defined, you will get an error.

=== UI Object Default Attributes ===

Tellurium UI objects have some default attributes as shown in the following table:

|| *Tellurium Object* || *Locator Default Attributes* || *Extra Attributes* || *UI Template* ||
|| Button || tag: "input" || || no ||
|| Container || || group || no ||
|| CheckBox || tag: "input", type: "checkbox" ||  || no ||
|| Div || tag: "div" ||  || no ||
|| Form || tag: "form" || group || no || 
|| Image || tag: "img" || || no ||
|| InputBox || tag: "input" ||  || no ||
|| RadioButton || tag: "input", type: "radio" ||  || no ||
|| Selector || tag: "select" ||  || no ||
|| Span || tag: "span" ||  || no ||
|| SubmitButton || tag: "input", type: "submit" ||  || no ||
|| UrlLink || tag: "a" ||  || no ||
|| List ||  || separator || yes ||
|| Table || tag: "table" || group, header || yes ||
|| StandardTable || tag: "table" || group, header, footer || yes ||
|| Frame ||  || group, id, name, title || no ||
|| Window ||  || group, id, name, title || no ||

== UI Module ==

UI Module is the key concept of Tellurium. What is UI module? UI module is a collection of UI elements that you group them together. Usually, the UI module represents a composite UI object in the format of nested basic UI elements. For example, the download search module in Tellurium project site is defined as follows,

{{{
ui.Form(uid: "downloadSearch", clocator: [action: "list", method: "get"], group: "true") {
   Selector(uid: "downloadType", clocator: [name: "can", id: "can"])
   InputBox(uid: "searchBox", clocator: [name: "q"])
   SubmitButton(uid: "searchButton", clocator: [value: "Search"])
}
}}}

Be aware that in most case the UI elements inside the composite UI object have relationship to each other. In the DOM structure, they should be on the same sub-tree. The exception is the [http://code.google.com/p/aost/wiki/LogicalContainer Logical Container].

[http://code.google.com/p/aost/wiki/Tellurium_A_New_Approach_for_Web_Test Why UI module concept is so important]? It is the foundation that Tellurium built on. First, UI module makes it possible to build UI elements' locator at runtime, which also makes Tellurium robust to changes from internal UI elements. Second, UI module makes Tellurium expressive. You can refer a UI element by simply appending the names along the path to the specific element. For example, you can refer the Selector element in the Tellurium download search module as "downloadSearch.downloadType". Other reasons include 
  * UI module makes Group Locating possible. 
  * UI module makes composite objects reusable in term of widget objects. 
  * UI module requires a new Tellurium Engine to support UI Module more efficiently.

== Composite Locator ==

Tellurium supports two types of locators, i.e., _base locator_ and _composite locator_. The _base locator_ is a relative XPath. The _composite locator_, denoted by "clocator", specifies a set of attributes for the UI object and the actual locator will be derived automatically by Tellurium at runtime.   

The Composite Locator is defined as follows:

{{{
class CompositeLocator {
    String header
    String tag
    String text
    String trailer
    def position
    boolean direct
    Map<String, String> attributes = [:]
}
}}}

To use the composite locator, you need to use "clocator" with a map as its value, i.e.,

{{{
clocator: [key1: value1, key2: value2, ...]
}}}

The default attributes include "header", "tag", "text", "trailer", "position", and "direct". They are all optional. The "direct" attribute specifies whether this UI object is a direct child of its parent UI and the default value is "false".

If you have additional attributes, you can define them in the same way as the default attributes, for example:

{{{
clocator: [tag: "div", value: "Tellurium home"]
}}}

Most Tellurium objects come with default values for certain attributes, for example, the  tag attribute. If these attributes are not specified, the default attribute values will be used. In other words, if you know the default attribute values of a Tellurium UI object, you can omit them in clocator. Take the RadioButton object as an example, its default tag is "input" and its default type is "radio". You can omit them and write the clocator as follows,

{{{
clocator: [:]
}}}

which is equivalent to

{{{
clocator: [tag: "input", type: "radio"]
}}}
 
== jQuery Selector ==

Starting with version 0.6.0, Tellurium will support a [http://code.google.com/p/aost/wiki/TelluriumjQuerySelector jQuery selector] to address the problem of poor performance of xpath in Internet Explorer. Auto-generating jQuery instead of xpath has the following advantages:
  * Faster performance in IE.
  * We are able to use the power of jQuery to call methods on jQuery collections to retrieve bulk data.
  * Tellurium jQuery selector supports the jQuery attribute selectors such as _[attribute!=value]_, _[attribute^=value]_, _[attribute$=value]_, and _[attribute*=value]_.

To use jQuery selector, simply call 

{{{
useJQuerySelector()
}}} 

in you code. To switch back to XPath locator, you should call

{{{
disableJQuerySelector()
}}}

Be aware that the UI module is agnostic to the locate strategy you choose and thus, you do not need to change anything in your test code. 

Our Benchmark test results show that:

  # jQuery selector is as fast as Ajaxslt XPath and Javascript XPath in Firefox 3.
  # jQuery selector is much faster in IE 7 than the two XPath libraries
  # jQuery selector uses only one method call to get back data for all table cells and thus it is the fastest one for bulk data access.

[http://code.google.com/p/aost/wiki/jQuerySelectorCache jQuery cache] is a mechanism to further improve the speed by reusing the found DOM reference for a given jQuery selector. Our benchmark results show that the jQuery cache could improve the speed by up to 14% over the regular jQuery selector and over 27% for some extreme cases.

== Group Locating ==

In Tellurium UI module, you often see the "group" attribute, for example,

{{{
ui.Container(uid: "google_start_page", clocator: [tag: "td"], group: "true"){
  InputBox(uid: "searchbox", clocator: [title: "Google Search"])
  SubmitButton(uid: "googlesearch", clocator: [name: "btnG", value: "Google Search"])
  SubmitButton(uid: "Imfeelinglucky", clocator: [value: "I'm Feeling Lucky"])
}
}}}

What does the attribute "group" mean? The group attribute is a flag for the Group Locating Concept. Usually, the XPath generated by Selenium IDE, XPather, or other tools is a single
path to the target node such as

{{{
//div/table[@id='something']/div[2]/div[3]/div[1]/div[6]
}}}

No sibling node's information is used here. What is wrong with this? The xpath depends on too much information on nodes away from the target node. In Tellurium, we try to localize the information and reduce the dependency by using sibling information or local information. For example, in the above google UI module, the group locating concept will try to find the "td" tag with its children as "InputBox", "googlesearch" button, and
"Imfellingluck" button. In this way, we can reduce the dependencies of the UI elements inside a UI module on external UI elements to make the UI definition more robust. 

== UI Templates ==

Tellurium UI templates are used for two purposes:

  # There are many identical UI elements, you can use one template to represent them
  # There are variable/dynamic size of UI elements at runtime, you know the patterns, but not the size.

More specifically, Table and List are two Tellurium objects that can define UI templates. Table defines two dimensional UI template and List is for one dimensional. Template has
special UIDs such as "2", "all", or "row: 1, column: 2". 
Let us look at use case (1), we have the following HTML source

{{{
      <ul class="a">
        <li>
            <A HREF="site?tcid=a"
               class="b">AA
            </A>
        </li>
        <li>
            <A HREF="site?tcid=b"
               class="b">BB
            </A>
        </li>
        <li>
            <A HREF="site?;tcid=c"
               class="b">CC
            </A>
        </li>
        <li>
            <A HREF="site?tcid=d"
               class="b">DD
            </A>
        </li>
        <li>
            <A HREF="site?tcid=e"
               class="b">EE
            </A>
        </li>
        <li>
            <A HREF="site?tcid=f"
               class="b">FF
            </A>
        </li>
    </ul>
}}}

You have six links there. Without templates, you have to put six UrlLink objects in the UI module. Look at how simple by using the template

{{{
ui.List(uid: "list", clocator: [tag: "ul", class: "a"], separator:"li")
{
    UrlLink(uid: "all", clocator: [class: "b"])
}
}}}


For use case (2), a common application is the data grid. Look at the "issueResult" data grid at our Tellurium Issues page,

{{{
ui.Table(uid: "issueResult", clocator: [id: "resultstable", class: "results"], group: "true") {
    TextBox(uid: "header: 1",  clocator: [:])
    UrlLink(uid: "header: 2",  clocator: [text: "%%ID"])
    UrlLink(uid: "header: 3",  clocator: [text: "%%Type"])
    UrlLink(uid: "header: 4",  clocator: [text: "%%Status"])
    UrlLink(uid: "header: 5",  clocator: [text: "%%Priority"])
    UrlLink(uid: "header: 6",  clocator: [text: "%%Milestone"])
    UrlLink(uid: "header: 7",  clocator: [text: "%%Owner"])
    UrlLink(uid: "header: 9",  clocator: [text: "%%Summary + Labels"])
    UrlLink(uid: "header: 10", clocator: [text: "%%..."])

    //define table elements
    //for the border column
    TextBox(uid: "row: *, column: 1", clocator: [:])
    //For the rest, just UrlLink
    UrlLink(uid: "all", clocator: [:])
}
}}}

Aren't the definitions very simple and cool? 

You may wonder how to use the templates if you have multiple templates such the "issueResult" table as shown above. The rule to apply the templates is "specific one first, general one later".

== Javascript Events ==

Most web applications include Javascripts and thus, the web testing framework must be able to handle the Javascript events. What we really care is to fire the appropriate events to trigger the event handlers.

Selenium has already provided methods to generate events such as

{{{
fireEvent(locator, "blur")
fireEvent(locator, "focus")
mouseOut(locator)
mouseOver(locator)
}}}

Tellurium was born with Javascript events in mind since it was initially designed to test applications written using the DOJO JavaScript framework. For example, we have the following radio button,

{{{
<input type='radio' name='mas_address_key' value='5779' onClick='SetAddress_5779()'>
}}}

Although we can define the radio button as follows,

{{{
RadioButton(uid: "billing", clocator: [name: 'mas_address_key', value: '5779'])
}}}

but it will not be able to respond to the click event since the Tellurium RadioButton only have the "check" and "uncheck" actions, which is enough for the normal case. As a result, no "click" event/action will be generated during the testing. How to address this problem then?

Tellurium added the "respond" attribute to Tellurium UI objects and the "respond" attribute could be used to define whatever events you want the UI object to respond to. Still take the above radio button as an example, the new Radio Button can be defined as,

{{{
 ui.Container(uid: "form", clocator: [whatever]){
     RadioButton(uid: "billing", clocator: [name: 'mas_address_key', value: '5779'], respond: ["click"])
 }
}}}

That is to say, you can issue the following command: 

{{{
  click "form.billing"
}}}

Even the RadioButton does not have the _click_ method defined by default, it is still able to dynamically add the _click_ method at runtime and call it.

A more general example is as follows,

{{{
 InputBox(uid: "searchbox", clocator: [title: "Google Search"], respond: ["click", "focus", "mouseOver", "mouseOut", "blur"])
}}}

Except for the "click" event, all the "focus", "mouseOver", "mouseOut", and "blur" events will be automatically fired by Tellurium during testing. Do not worry about the event order for the respond attribute, Tellurium will automatically re-order the events and then process them appropriately for you.

== "Include" Frequently Used Sets of elements in UI Modules ==

Sometimes, you have a frequently used set of elements, which you do not want to redefined them over and over again in your UI module. Now, you can use the "Include" syntax to re-use pre-defined UI elements,

{{{
Include(uid: UID, ref: REFERRED_UID)
}}}  

You should use "ref" to reference the object you want to include, you can still specify the uid for the object (if you do not need a different UID, you do not need to specify it), if the object uid is not the same as the original one, Tellurium will clone a new object for you so that you can have multiple objects with different UIDs. 

For example, you first define the following reused UI module

{{{
   ui.Container(uid: "SearchModule", clocator: [tag: "td"], group: "true") {
     InputBox(uid: "Input", clocator: [title: "Google Search"])
     SubmitButton(uid: "Search", clocator: [name: "btnG", value: "Google Search"])
     SubmitButton(uid: "ImFeelingLucky", clocator: [value: "I'm Feeling Lucky"])
   }
}}}

Then, you can include it into your new UI module as follows,

{{{
   ui.Container(uid: "Google", clocator: [tag: "table"]) {
     Include(ref: "SearchModule")
     Include(uid: "MySearchModule", ref: "SearchModule")
     Container(uid: "Options", clocator: [tag: "td", position: "3"], group: "true") {
       UrlLink(uid: "LanguageTools", clocator: [tag: "a", text: "Language Tools"])
       UrlLink(uid: "SearchPreferences", clocator: [tag: "a", text: "Search Preferences"])
       UrlLink(uid: "AdvancedSearch", clocator: [tag: "a", text: "Advanced Search"])
     }
   }
}}}
  
== Tellurium Widgets ==

[http://code.google.com/p/aost/wiki/TelluriumWidget Tellurium Widget] is a good way to re-use the UI components in testing. Usually, Java script frameworks provide a lot of widgets. Take the Dojo framework as an example, the DatePicker Dojo widget could be described as follows,

{{{
class DatePicker extends DojoWidget{

    public void defineWidget() {
        ui.Container(uid: "DatePicker", locator: "/div[@class='datePickerContainer' and child::table[@class='calendarContainer']]"){
            Container(uid: "Title", locator: "/table[@class='calendarContainer']/thead/tr/td[@class='monthWrapper']/table[@class='monthContainer']/tbody/tr/td[@class='monthLabelContainer']"){
                Icon(uid: "increaseWeek", locator: "/span[@dojoattachpoint='increaseWeekNode']")
                Icon(uid: "increaseMonth", locator: "/span[@dojoattachpoint='increaseMonthNode']")
                Icon(uid: "decreaseWeek", locator: "/span[@dojoattachpoint='decreaseWeekNode']")
                Icon(uid: "decreaseMonth", locator: "/span[@dojoattachpoint='decreaseMonthNode']")
                TextBox(uid: "monthLabel", locator: "/span[@dojoattachpoint='monthLabelNode']")   
            }
            StandardTable(uid: "calendar", locator: "/table[@class='calendarContainer']/tbody/tr/td/table[@class='calendarBodyContainer']"){
                TextBox(uid: "header: all", locator: "")
                TextBox(uid: "all", locator: "", respond: ["click"])
            }
            Container(uid: "year", locator: "/table[@class='calendarContainer']/tfoot/tr/td/table[@class='yearContainer']/tbody/tr/td/h3[@class='yearLabel']"){
                Span(uid: "prevYear", locator: "/span[@class='previousYear' and @dojoattachpoint='previousYearLabelNode']")
                TextBox(uid: "currentYear", locator: "/span[@class='selectedYear' and @dojoattachpoint='currentYearLabelNode']")
                Span(uid: "nextYear", locator: "/span[@class='nextYear' and @dojoattachpoint='nextYearLabelNode']")
            }
        }
    }
}
}}} 

You may notice that we use _base locator_, i.e., XPath directly. The reason is that we try to improve the speed for the widget. You can define the Widget using _composite locator_, i.e., attributes, as well. In Tellurium 0.7.0, the widget will be improved so that you define and use them more easily. 

For widgets, it is important to include name space to avoid name collision between different widget modules. If we use "DOJO" as the name space, the widget will be like "DOJO_DatePicker". We can define the following methods for the DOJO Date Picker widget:

{{{    
    public String getCurrentYear(){
        return getText("DatePicker.year.currentYear")
    }

    public void selectPrevYear(){
        click "DatePicker.year.prevYear"
    }
}}}

To use the Date Picker widget, we can include the compiled jar file and include it like a regular tellurium UI object. For example,

{{{
class DatePickerDemo extends DslContext{
    
    public void defineUi() {
        ui.Form(uid: "dropdown", clocator: [:], group: "true"){
            TextBox(uid: "label", clocator: [tag: "h4", text: "Dropdown:"])
            InputBox(uid: "input", clocator: [dojoattachpoint: "valueInputNode"])
            Image(uid: "selectDate", clocator: [title: "select a date", dojoattachpoint: "containerDropdownNode", alt: "date"])
            DOJO_DatePicker(uid: "datePicker", clocator: [tag: "div", dojoattachpoint: "subWidgetContainerNode"])
        }
    }
}
}}}

To make the framework scalable, Tellurium provides an _onWidget_ method for Tellurium widgets. In that way, we can call the widget methods as follows:

{{{
onWidget "dropdown.datePicker", selectPrevYear
}}}

== Tellurium Configuration ==

Tellurium use a configuration file TelluriumConfig.groovy to configure the framework. Do not be panic to see that it is a groovy file. Yes, it is a groovy file, but it is parsed by the framework as a text file. For you, just treat it as a text file with some rules such as using "{" and "}" for a block. Look at a snippet of configuration

tellurium{
    //embedded selenium server configuration
    embeddedserver {
        //port number
        port = "4444"
        //whether to use multiple windows
        useMultiWindows = false
        //whether to run the embedded selenium server. If false, you need to manually set up a selenium server
        runInternally = true
    }
    //event handler
    eventhandler{
        //whether we should check if the UI element is presented
        checkElement = true
        //wether we add additional events like "mouse over"
        extraEvent = true
    }

   ...

}

Obviously, "//" is used for comments. You may wonder how Tellurium parses the configuration file, Tellurium actually uses the Groovy ConfigSlurper class to achieve
this. The nested settings will be turned into a Groovy ConfigObject object, which is basically a nested map, for example, the port number for the embedded server could be referred by "conf.tellurium.embeddedserver.port". 

[http://code.google.com/p/aost/wiki/TelluriumSampleConfigurationFile TelluriumConfig.groovy] acts like a global setting file for a Tellurium project. In the meanwhile, Tellurium provides the following method for you to override the settings in individual test case class, 

{{{
void setCustomConfig(boolean runInternally, int port, String browser, boolean useMultiWindows, String profileLocation) 
}}}

For example, you can override the default settings in a test class as follows,

{{{

public class GoogleStartPageJavaTestCase extends TelluriumJavaTestCase
{
    static{
        setCustomConfig(true, 5555, "*chrome", true, null);
    }

...

} 
}}}

= How to Obtain and Use Tellurium =

== Create a Tellurium Project ==

here are three ways, i.e., use [http://code.google.com/p/aost/wiki/ReferenceProjectGuide the reference project] as a base, use [http://code.google.com/p/aost/wiki/TelluriumMavenArchetypes Tellurium Maven archetype], or manually create Tellurium project using [http://code.google.com/p/aost/downloads/list tellurium jar] and [http://code.google.com/p/aost/wiki/TelluriumSampleConfigurationFile  Tellurium configuration file]. Alternatively, you could create your own Tellurium Maven project manually using [http://code.google.com/p/aost/wiki/TelluriumTestProjectMavenSamplePom the sample POM file].

Teasiest way to create a Tellurium project is to use Tellurium Maven archetypes. Tellurium provides two Maven archetype, i.e., tellurium-junit-archetype and tellurium-testng-archetype for Tellurium JUnit test project and Tellurium TestNG test project, respectively. As a result, you can create a Tellurium project using one Maven command. For a Tellurium JUnit project, use 

mvn archetype:create -DgroupId=your_group_id -DartifactId=your_artifact_id -DarchetypeArtifactId=tellurium-junit-archetype -DarchetypeGroupId=tellurium -DarchetypeVersion=0.7.0-SNAPSHOT -DarchetypeRepository=http://kungfuters.org/nexus/content/repositories/snapshots

and for a Tellurium TestNG project, use

mvn archetype:create -DgroupId=your_group_id -DartifactId=your_artifact_id -DarchetypeArtifactId=tellurium-testng-archetype -DarchetypeGroupId=tellurium -DarchetypeVersion=0.7.0-SNAPSHOT -DarchetypeRepository=http://kungfuters.org/nexus/content/repositories/snapshots

== Create UI Module ==

Tellurium provides Trump for you to automatically create UI modules. Trump can be download from Tellurium project site 

http://code.google.com/p/aost/downloads/list

Choose the Firefox 2 or Firefox 3 version depending on your Firefox version. Or you can download the Firefox 3 version directly from Firefox addons site at

https://addons.mozilla.org/en-US/firefox/addon/11035

Once you install it and restart Firefox, you are ready to record your UI modules by simply clicking on the UI element on the web and then click the "generate" button. You may like to customize your UI a bit by clicking the "Customize" button. More detailed Trump introductions can be found at

http://code.google.com/p/aost/wiki/TrUMP

and

http://code.google.com/p/aost/wiki/HowTrUMPWorks

In our example, we open up Tellurium download page 

http://code.google.com/p/aost/downloads/list

and record the download search module as follows

http://tellurium-users.googlegroups.com/web/TrUMPRecordDownloadPage.png?gda=OlvnAU0AAACXZPxEX7Ki-M5C2JpeBoXX_AfRGjKOg8bfAG7WWa1zzr3MhpfIdLRuVAwbLjuTZtSqonpmmrv0I-p7nCVZQmP65Tb_vjspK02CR95VRrtmeQ&gsc=r5ESUAsAAAB_6XgBAY-OTO2KhvY2ZJUe

After we customize the UI module, we export it as the module file NewUiModule.groovy to the demo project and add couple methods to the class.

{{{
class NewUiModule extends DslContext {

  public void defineUi() {
    ui.Form(uid: "TelluriumDownload", clocator: [tag: "form", method: "get", action: "list"], group: "true") {
      Selector(uid: "DownloadType", clocator: [tag: "select", name: "can", id: "can"])
      InputBox(uid: "Input", clocator: [tag: "input", type: "text", name: "q", id: "q"])
      SubmitButton(uid: "Search", clocator: [tag: "input", type: "submit", value: "Search"])
    }
  }

  //Add your methods here
  public void searchDownload(String keyword) {
    keyType "TelluriumDownload.Input", keyword
    click "TelluriumDownload.Search"
    waitForPageToLoad 30000
  }

  public String[] getAllDownloadTypes() {
    return getSelectOptions("TelluriumDownload.DownloadType")
  }

  public void selectDownloadType(String type) {
    selectByLabel "TelluriumDownload.DownloadType", type
  }
}
}}}

== Create Tellurium Test Cases ==

Once you create the UI module, you can create a new Tellurium test case NewTestCase by extending TelluriumJavaTestCase class.

{{{
public class NewTestCase extends TelluriumJavaTestCase {
    private static NewUiModule app;

    @BeforeClass
    public static void initUi() {
        app = new NewUiModule();
        app.defineUi();
    }

    @Before
    public void setUpForTest() {
        connectUrl("http://code.google.com/p/aost/downloads/list");
    }

    @Test
    public void testTelluriumProjectPage() {
        String[] allTypes = app.getAllDownloadTypes();
        assertNotNull(allTypes);
        assertTrue(allTypes[1].contains("All Downloads"));
        app.selectDownloadType(allTypes[1]);
        app.searchDownload("TrUMP");
    }
}
}}}

Compile the project and run the new test case.

= Conclusions and Future Directions =

Tellurium is robust, expressive, flexible, and reusable with many unique features. Tellurium introduces a new approach to test web applications based on UI modules.
We have released Tellurium 0.6.0 and are working on 0.7.0. 

Tellurium will continue evolving and we will focus on the following tasks,

  * Develop the Engine project in 0.7.0 to provide better support for UI module and achieve better re-usability, speed performance, and robust to changes. 
  * Tellurium widget will be re-architected to encapsulate dynamic factors and to make it easier to define and use Tellurium widgets. 
  * The widget extension projects will be implemented to include many widgets from Javascript frameworks such as Dojo and ExtJS so that users can include these widgets in their UI modules simply by their names without the need to know the details of the internal UI elements. 
  * TrUMP will be improved to support frames, pop-up widows, and UI templates. Another big move will be to automatically create UI modules as well as DSL test scripts for non-developers. 
  * To better support functional tests, we will introduce a "stage and test binding" concept to make functional tests easier to write and configure. 
  * Headless web testing using HtmlUnit could be another interesting topic. 
  * Other initiatives include behavior driven test support, IDE plugins, XHTML support, integration with other testing framework like Fitnesse, and porting to other languages.

= Acknowledgments =

= Resources =

  * [http://code.google.com/p/aost/ Tellurium Project website] 
  * [http://groups.google.com/group/tellurium-users Tellurium User Group]
  * [http://code.google.com/p/aost/wiki/UserGuide Tellurium User Guide]
  * [http://code.google.com/p/aost/wiki/TrUMP Tellurium UI Model Firefox Plugin (TrUMP) 0.1.0]
  * [http://seleniumhq.org/ Selenium]
  * [http://webtest.canoo.com Canoo WebTest]
  * [http://twill.idyll.org/ Twill]  
  * [http://groovy.codehaus.org/ Groovy]
  * [http://jquery.com/ JQuery]
  * [http://www.junit.org/ JUnit] 
  * [http://testng.org/doc/documentation-main.html TestNG]
  * [http://htmlunit.sourceforge.net HtmlUnit]