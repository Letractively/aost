#labels Featured,Phase-Design
= Introduction =

*Tellurium Automated Testing Framework* (_Tellurium_) framework
  * Written in *Groovy*, test cases can be written in *Java* or *Groovy* 
  * Include a *Domain Specific Language* (_DSL_) to define UI objects 
  * Can also use the _DSL_ to describe events, actions, or assertions 
  * include an *Object to Locator Mapping framework* (_OLM_)
  * Tellurium can automatically generate the UI object locator for you
  * Tellurium implements the *group locating* concept to utilize a group of UI objects to help locating their locators
  * Make it possible for users to write Selenium tests when they start coding
  * Reusable, easier to refactor and maintain
  * Provide _DSL_ script executor so that non-developers can write Selenium tests in DSL
  * Provide *Data Driven Testing* feature for Tellurium tests. You can specify input data format and define different tests. Then use input data to drive the testing. The test result can be output as an XML file.

== Architecture ==

The Tellurium framework Architecture is shown as in Figure 1.

http://tellurium-users.googlegroups.com/web/tellurium.architecture.png?gda=1NP4x0sAAAAFkHkURP2WlgYU-UhtQDFJganRixm7ZVzXjIzQXs5CXWG1qiJ7UbTIup-M2XPURDThcsDHHqasJHRvnmR6jbzWzHqwysTvAgdPZHbdH4XvXg&gsc=26Y4eBYAAAAkGgIQNXlg3kIha08SEZtI9pmI1qD38G08ONb6YfjJaQ

Figure 1. Tellurium Architecture.

The system diagram of Tellurium consists of three parts, one is the Selenium Server, on which our Tellurium framework builds, the Tellurium framework, and user defined Java test cases or .dsl pure DSL test scripts. 

The Tellurium Framework is based on the DslContext, which defines all DSLs we can use for Tellurium. We can further divide the Tellurium Framework into Four parts.

=== UI Object Parser ===

This parts consists of the DSL Object Parser, Object Builders, and the Object Registry.

Thanks to Groovy’s builder pattern, we can define UI object expressively and in a nested fashion. The DSL object parser will parse the DSL object definition recursively and use object builders to build the objects on the fly. An object builder registry is designed to hold all predefined UI object builders in the Tellurium framework and the DSL object parser will look at the builder registry to find the appropriate builders. Since the registry is a hash map, you can override a builder with a new one using the same UI name. Users can also add their customer builders into the builder registry.
 
The DSL object definition always comes first with a container type object. An object registry (A hash map) is used to stored all top level UI Objects. As a result, for each DSL object definition, the top object ids must be unique in the DslContext. The object registry will be used by the framework to search objects by their ids and fetch objects for different actions.

=== Object Locator Mapping ===

The Object Locator Mapping (OLM) is the core of the Tellurium framework and it includes UI ID mapping, XPath builder, Locator Processor, and Group Locating. The UI ID supports nested object, for example, "menu.wiki" stands for a URL Link "wiki" inside a container called "menu". The UI ID also supports one dimension and two dimension index for table and list. For example, {{{"main.table[2][3]"}}} stands the UI object of the 2nd row and the 3rd column of a table inside the container "main".

XPath builder can build the XPath from relative XPaths or from attributes. The locator processor converts the locator information in the UI object to the XPath. The Group Locating Concept (GLC) is to exploit the group information in side a collection of UI objects to help us find the locator of the collection of UI objects. 

=== Event and Data Handling ===

The Eventhandler in this part will handle all events like "click", "type", "select", and so on. The Data Accessor is used to fetch data or UI status from the DOM. The dispatcher will delegate all calls it receives from the Eventhandler and the data accessor to the Selenium Client, which will connect to the Selenium Server. The dispatcher is designed to decouple the rest of the Tellurium framework with the Selenium framework so that we can simply change the dispatcher logic to delegate all calls to other underneath UI test frameworks if we want to switch Tellurium not to use the Selenium framework someday.  

=== UI Objects ===

The UI Object includes
  * uid: should be unique in a UI module
  * namespace: for future extension
  * locator: the locator of the UI object, could be XPATH, CSS selector... The easier way to find the locator would be to use firefox XPather plugin.
  * Features: the inherent feature of the UI component, for example, the selection UI component normally comes with “label=?” or “value=?”. Table always has the “table”, “tr”, “td”, “th” tags.
  * useGroupInfo: this option only applies to a collection type of UI object such as Container, Table, List, Form and so on. By default, this option is turned off. If it is on, the object will use the UI objects to help locating its locator.

Regular UI objects include Button, CheckBox, Icon, InputBox, Selector, TextBox, Table... 
A container is a special UI object and it could be a pure abstract object to hold and group different UI objects together. The container will make the objects inside searchable since it uses a list to hold them.

Users can also define custom UI objects. They need to create a UI builder for each new UI 
object and add it to the UiObjectBuilderRegistry.

Be aware that each UI object only has predefined set of events or actions. For example, the InputBox has the _type_ action, but the Selector does not have that.

=== UI Object Locators ===

There are two type of UI object locators:
  * Base Locator: the actual locator at run time. Denoted by "locator".
  * Composite Locator: User specifies a set of parameters for the object and the actual locator will be derived automatically by Tellurium. Denoted by "clocator".

The Basic Locator is only a String that you can specify the run time locator, be aware that the basic locator can be a partial locator, Tellurium will construct the actual run time locator starting from the top level object and all the way to the current object. 

The Composite Locator is more complicated and its definition is as follows:
{{{
class CompositeLocator {
    String header
    String tag
    String text
    String trailer
    def position
    boolean direct
    Map<String, String> attributes = [:]
}
}}}

To use composite locator, you need to use "clocator" and its value is a map, i.e.,
{{{
clocator: [key1: value1, key2: value2, ...]
}}}
format in Groovy. The defined keys include "header", "tag", "text", "trailer", "position", and "direct". They are all optional. For most UI object, the html tag is fixed, for example, a Table's tag is always "table". If a UI object has fixed tag and it is defined in object class, you do not need to include "tag". The "direct" key specifies whether this UI object is a direct child of the header or its parent UI and the default value is "false".

You may have additional attributes, define them in the same way as the predefined keys. For example:
 
{{{
value: "Tellurium home"
}}} 

Header and Trailer are used to specify addition xpath related to this UI object and the final xpath is 
{{{
XPath = header + derived xpath for object + trailer
}}}

=== The Group Locating Concept (GLC) ===

The Group Locating Concept (GLC) concept comes from the simple observation, i.e., it is much easier to locate a collection of UI objects than a single UI object. The reason is multiple UI objects provide more search criteria to help you to locate the UIs. This concept is implemented in Tellurium. All collection type object, i.e., Container and its extended classes have an option to use the group locating concept. 

Let's see the differences between regular locating and group locating. Still take the google start page as an example:

{{{
ui.Container(uid: "google_start_page", clocator: [tag: "td"], group: "true"){
  InputBox(uid: "searchbox", clocator: [title: "Google Search"])
  SubmitButton(uid: "googlesearch", clocator: [name: "btnG", value: "Google Search"])
  SubmitButton(uid: "Imfeelinglucky", clocator: [value: "I'm Feeling Lucky"])
}

}}}

Here, clocator stands for composite locator. Without group locating, I can only use the given criteria 

{{{
tag = "td" 
}}}

to find the container locator, i.e., 
{{{
I am looking for a td html tag in the DOM
}}} 
which is quite difficult. If we use the group locating, the Container can use the group information provided by its children. Now, the problem becomes: 
{{{
  I am looking for a td html tag in the DOM and its children including an input box with
  title "Google Search", a submit button with name "btnG" and value "Google Search", and
  another submit button with value "I'm Feeling Lucky"
}}}
Woo! I have a lot of information to help me to locate the container. Once the container is found, all its children can be found very easily.

The direct result of group locating is that for most case, the information defined in the UI module itself is enough for you to locate all UI objects in that UI module. That is to say, your test code only depends on your own UI module, not its location and its outside. Even we change the UI, the test may still work.  

Another advantage is that you may be able to map your JSP, PHP, ASP,..., file directly to the UI module in Tellurium. This could help developers a lot for writing Selenium tests because they do not need to manually find the locator for an UI object. 

== DSL ==
 
Domain Specific Language (DSL) indicates a programming language or specification language   dedicated to a particular problem domain, a particular problem representation technique, and/or a particular solution technique. Here the domain refers to UI testing. DSL is specified in the class *DslContext*, which defines the basic DSLs. 

=== Define UI objects ===

_ui.Container_ is used to define the UI objects on the web and map them to objects.
For example, the search module in the google start page can be defined by 
the following DSL.

{{{
ui.Container(uid: "google_search"){
   InputBox(uid: "inputbox1", locator: "//input[@title='Google Search']")
   Button(uid: "button1", locator: "//input[@name='btnG' and @type='submit']")
}
}}}

The definition can be nested, for example
{{{
ui.Container(uid: "parent_ui"){
   InputBox(uid: "inputbox1", locator: "...")
   Button(uid: "button1", locator: "...")
   Container(uid: "child_ui){
     Selector(uid: "selector1", locator: "...")
     ...
     Container(uid: "grand_child"){
       TextBox(uid: "textbox1", locator: "...")
       ...
     }
   }
}
}}}

=== UiID ===

In DSL, the Ui object is referred by the UiID. For nested Ui objects, the UiID of the Ui Object is a concatenated of the Ui objects' uids along its path to the Ui Object. For example, in the above nested Ui Module, the TextBox is referred as "parent_ui.child_ui.grand_child.textbox1". The exceptions are tables and lists, which use {{{[x][y]}}} or {{{[x]}}} to reference its elements inside. For example, {{{labels_table[2][1]}}} and {{{GoogleBooksList.subcategory[2]}}}. Table header can be referred in the format of {{{issueResult.header[2]}}}.

For menu, you need to define an alias name for each item. For instance, the Tellurium issues page includes the following menu,

{{{
//items is a map in the format of "alias name" : menu_item
ui.SimpleMenu(uid: "IdMenu", clocator:[class: "popup", id: "pop_0"],
      items: ["SortUp":"Sort Up", "SortDown":"Sort Down", "HideColumn":"Hide Column"])
}}} 

You need to use the alias name to refer the menu item, for example, "IdMenu.SortUp".

For the option object, the option uid must be the same as the UI objects it represent
and in this way, you do not need to include it in the DSL. For example, in the following Ui Module,

{{{
//The selector to choose the data grid layout as List or Grid
ui.Option(uid: "layoutSelector"){
   Container(uid: "layoutSelector", clocator: [tag: "div"], group: "true") {
      TextBox(uid: "List", clocator: [tag: "b", text: "List", direct: "true"])
      UrlLink(uid: "Grid", clocator: [text: "Grid", direct: "true"])
   }
   Container(uid: "layoutSelector", clocator: [tag: "div"], group: "true") {
      UrlLink(uid: "List", clocator: [text: "List", direct: "true"])
      TextBox(uid: "Grid", clocator: [tag: "b", text: "Grid", direct: "true"])
   }
}
}}}

you just use

{{{
click "layoutSelector.List"
}}}

instead of

{{{
click "layoutSelector.layoutSelector.List"
}}}

=== Basic DSLs ===

Because of the Groovy Syntax, each method in the DslContext is a DSL expression.
For example, the _click_ method as follows:
{{{
def click(String id){
  ...
}
}}}
is a dsl in the format:
{{{
  click id
}}}

Similarly, we have the following dsls:
{{{
doubleClick id
clickAt id, coordination
check id
uncheck id
type id, input
keyType id, input
typeAndReturn id, input
clearText id
select id, target
selectByLabel  id, target
selectByValue id, target
waitForText id, timeout
isElementPresent id
isVisible id
isChecked id
waitForElementPresent id, timeout
waitForElementPresentid, timeout, step
getText id
getValue id
pause milliseconds
}}}

=== Extended DSLs ===
The DslContext can be extended to include more DSLs. For example, 
the DslScriptEngine extends DslContext to add the following DSL
{{{
openUrl url
}}}
and other assertions defined in GroovyTestCase.

=== Define multiple UI modules in a single file ===
Tellurium supports multiple UI modules in a single file. For example, you can define multiple UI modules as follows:
{{{
//define the menu
//It is fine to use Container to abstract Table if you have special table
ui.Container(uid: "menu", clocator: [tag: "table", id: "mt", trailer: "/tbody/tr/th"], group: "true"){
    //since the actual text is  Project&nbsp;Home, we can useString partial match here. Note "%%" stands for partial match
    UrlLink(uid: "project_home", clocator: [text: "%%Home"])
    UrlLink(uid: "downloads", clocator: [text: "Downloads"])
    UrlLink(uid: "wiki", clocator: [text: "Wiki"])
    UrlLink(uid: "issues", clocator: [text: "Issues"])
    UrlLink(uid: "source", clocator: [text: "Source"])
}

//define the search module, which includes an input box, two search buttons
ui.Form(uid: "search", clocator: [:], group: "true"){
    InputBox(uid: "searchbox", clocator: [name: "q"])
    SubmitButton(uid: "search_project_button", clocator: [value: "Search Projects"])
    SubmitButton(uid: "search_web_button", clocator: [value: "Search the Web"])
}
}}}

== Data Driven Testing ==

Data Driven Testing is a different way to write tests, i.e, separate test data from the test scripts and the test flow is not controlled by the test scripts. It is controlled by the input file instead. In the input file, users can specify which test to run, what are input parameters, and what are expected results.
 

The Tellurium Data Driven Testing Architecture is described on [http://code.google.com/p/aost/wiki/DataDrivenArchitecture this wiki page]. Tellurium provides a data to object mapping framework to convert input data to Java variables. Tellurium provides a class TelluriumDataDrivenModule, which extends DslContext, for user to define Ui modules, input data formats, and tests. The TelluriumDataDrivenTest is the actual test class which loads different TelluriumDataDrivenModules, reads input data, converts data to variables defined in the test scripts, run the tests specified by the input data, and report the test results in an XML file.

=== Data Provider ===
The data provider is the key component of the data driven testing. It reads data from input and binds them to variables defined in the test scripts. This part is handled by the data to object mapping framework. Data provider usually works behind the scene and it provides the following methods for users:

  # loadData file_name, load input data from a file. 
  # useData String_name, load input data from a String in the test script
  # bind("fieldSet field name"), bind a variable to a FieldSet field name
  # closeData, close the input data stream and report the test results

The file name should include the file path, for example,

{{{
  loadData "src/test/example/test/ddt/GoogleBookListCodeHostInput.txt"
}}}

Right now, Tellurium supports pipe format input file and will add more file format support later on. To change the file reader for different formats, please change the following settings in the configuration file TelluriumConfig.groovy:

{{{
datadriven{
    dataprovider{
        //specify which data reader you like the data provider to use
        //the valid options include "PipeFileReader" at this point
        reader = "PipeFileReader"
    }
}

}}}

Sometimes, you may like to specify test data in the test scripts directly, useData is designed for this purpose and it loads input from a String. The String is usually defined in Groovy style using triple quota, for example:

{{{
  protected String data = """
    google_search | true | 865-692-6000 | tellurium
    google_search | false| 865-123-4444 | tellurium selenium test
    google_search | true | 755-452-4444 | tellurium groovy
    google_search | false| 666-784-1233 | tellurium user group
    google_search | true | 865-123-5555 | tellurium data driven
"""
    ...

  useData data
}}}

bind is the command to bind a variable to input Field Set field at runtime. FieldSet is the format of a line of data and it is defined in the next section. For example,

{{{
  def row = bind("GCHLabel.row")
}}}

is used to bind the row variable to the "row" field in the FieldSet "GCHLabel". Tellurium does not explicitly differentiate input parameters from the expected results in the input data. You only need to bind variables to the input data and then you can use any of them as the expected results for result comparison.

When you are done with your testing, please use "closeData" to close the input data stream. In the meantime, the result reporter will output the test results in the format you specified in the configuration file, for example, XML file as shown in the TelluriumConfig.groovy file:

{{{
test{
    result{
       //specify what result reporter used for the test result
       //valid options include "SimpleResultReporter", "XMLResultReporter", and "StreamXMLResultReporter"
       reporter = "XMLResultReporter"
       //the output of the result
       //valid options include "Console", "File" at this point
       //if the option is "File", you need to specify the file name, other wise it will use the default
       //file name "TestResults.output"
       output = "Console"
       //test result output file name
       filename = "TestResult.output"
    }
}
}}}

=== TelluriumDataDrivenModule ===

TelluriumDataDrivenModule is designed to provide a test module for data driven testing. Users should extend this class to define their own test modules. 


TelluriumDataDrivenModule provides one method "defineModule" for users to implement. Since it extends the DslContext class, users can define Ui modules just like in regular Tellurium Ui Module. For example:

{{{
ui.Table(uid: "labels_table", clocator: [:], group: "true"){
   TextBox(uid: "row: 1, column: 1", clocator: [tag: "div", text: "Example project labels:"])
   Table(uid: "row: 2, column: 1", clocator: [header: "/div[@id=\"popular\"]"]){
        UrlLink(uid: "all", locator: "/a")
   }
}
}}}

FieldSet is used to define the format of one line of input data and FieldSet consists of fields, i.e., columns, in the input data. There is a special field "test", which users can specify what test this line of data apply to. For example,

{{{
fs.FieldSet(name: "GCHStatus", description: "Google Code Hosting input") {
    Test(value: "getGCHStatus")
    Field(name: "label")
    Field(name: "rowNum", type: "int")
    Field(name: "columNum", type: "int")
}  
}}}

The above FieldSet defines the input data format for testing google code hosting web page. Note, the Test field must be the first column of the input data. The default name of the test field is "test" and does not need to be specified. If the value attribute of the test field is not specified, it implies this same format, i.e., FieldSet, can used for different tests.


For regular field, it includes the following attributes:

{{{

class Field {
	//Field name
	private String name

        //Field type, default is String
        private String type = "String"

        //optional description of the Field
	private String description

	//If the value can be null, default is true
	private boolean nullable = true

	//optional null value if the value is null or not specified
	private String nullValue

	//If the length is not specified, it is -1
	private int length = -1

	//optional String pattern for the value
	//if specified, we must use it for String validation
	private String pattern
   } 

}}}

Tellurium can automatically handle Java primitive types. Another flexibility Tellurium provides is that users can define their own custom type handlers to deal with more complicated data types by using "typeHandler", for example, 

{{{
//define custom data type and its type handler
typeHandler "phoneNumber", "org.tellurium.test.PhoneNumberTypeHandler"

//define file data format
fs.FieldSet(name: "fs4googlesearch", description: "example field set for google search") {
    Field(name: "regularSearch", type: "boolean", description: "whether we should use regular search or use I'm feeling lucky")
    Field(name: "phoneNumber", type: "phoneNumber", description: "Phone number")
    Field(name: "input", description: "input variable")
}
}}}

The above script defined a custom type "PhoneNumber" and the Tellurium will automatically call this type handler to convert the input data to the "PhoneNumber" Java type.

The "defineTest" method is used to define a test in the TelluriumDataDrivenModule, for example, the following script defines the "clickGCHLabel" test:

{{{
defineTest("clickGCHLabel"){
    def row = bind("GCHLabel.row")
    def column = bind("GCHLabel.column")
           
    openUrl("http://code.google.com/hosting/")
    click  "labels_table[2][1].[${row}][${column}]"

    waitForPageToLoad 30000
}
}}}

Note, the bind command is used to bind variables row, column to the fields "row" and "column" in the FieldSet "GCHLabel".

Tellurium also provide the command "compareResult" for users to compare the actual result with the expected result. For example, the following script compares the expected label, row number, and column number with the acutal ones at runtime: 

{{{
defineTest("getGCHStatus"){
    def expectedLabel = bind("GCHStatus.label")
    def expectedRowNum = bind("GCHStatus.rowNum")
    def expectedColumnNum = bind("GCHStatus.columNum")

    openUrl("http://code.google.com/hosting/")
    def label = getText("labels_table[1][1]")
    def rownum = getTableMaxRowNum("labels_table[2][1]")
    def columnum = getTableMaxColumnNum("labels_table[2][1]")

    compareResult(expectedLabel, label)
    compareResult(expectedRowNum, rownum)
    compareResult(expectedColumnNum, columnum)
    pause 1000
}
}}}

Sometimes, users may need custom "compareResult" to handle more complicated situation, for example, users want to compare two lists. In such a case, users can override the default "compareResult" behaviour by specifying custom code in the closure:

{{{
compareResult(list1, list2){
    assertTrue(list1.size() == list2.size())
    for(int i=0; i<list1.size();i++){
        //put your custom comparison code here
    }
}
}}}
   
=== TelluriumDataDrivenTest ===

TelluriumDataDrivenTest is the class users should extend to run the actual data driven testing and it is more like a data driven testing engine.


There is only one method, "testDataDriven", which users need to implement. Usually, users need to do the following steps:

  # use "includeModule" to load defined Modules
  # use "loadData" or "useData" to load input data stream
  # use "stepToEnd" to read the input data line by line and pick up the specified test and run it, until reaches the end of the data stream
  # use "closeData" to close the data stream and output the test results

What the "includeModule" does is to merge in all Ui modules, FieldSets, and tests defined in that module file to the global registry. "stepToEnd" will look at each input line, first to find the test name and pass in all input parameters to it, and then run the test. The whole process can be illustrated in the following example:

{{{
class GoogleBookListCodeHostTest extends TelluriumDataDrivenTest{

    public void testDataDriven() {

        includeModule  example.google.GoogleBookListModule.class
        includeModule  example.google.GoogleCodeHostingModule.class

        //load file
        loadData "src/test/example/test/ddt/GoogleBookListCodeHostInput.txt"
        
        //read each line and run the test script until the end of the file
        stepToEnd()

        //close file
        closeData()
    }
}

}}} 

The input data for this example are as follows,

{{{
##TEST should be always be the first column

##Data for test "checkBookList"
##TEST | CATEGORY | SIZE
checkBookList|Fiction|8
checkBookList|Fiction|3

##Data for test "getGCHStatus"
##TEST | LABEL | Row Number | Column Number
getGCHStatus |Example project labels:| 3 | 6
getGCHStatus |Example project| 3 | 6

##Data for test "clickGCHLabel"
##TEST | row | column
clickGCHLabel | 1 | 1
clickGCHLabel | 2 | 2
clickGCHLabel | 3 | 3
}}}

Note that line starting with "##" is comment line and empty line will be ignored.

If some times, users want to control the testing execution flow by themselves, Tellurium also provides this capability even though it is not recommended. Tellurium provides two additional commands, i.e., "step" and "stepOver". "step" is used to read one line of input data and run it, and "stepOver" is used to skip one line of input data. In this meanwhile, Tellurium also allows you to specify additional test script using closure. For example, 

{{{
step{
    //bind variables
    boolean regularSearch = bind("regularSearch")
    def phoneNumber = bind("fs4googlesearch.phoneNumber")
    String input = bind("input")

    openUrl "http://www.google.com"
    type "google_start_page.searchbox", input
    pause 500
    click "google_start_page.googlesearch"
    waitForPageToLoad 30000
}
}}} 

But this usually implies that the input data format is unique or the test script knows about what format the current input data are using.
 
== Future Directions ==

Tellurium will continue evolving and more new features will be developed to make it more powerful and easier to use. We are considering the following new features for the next or future releases:

  # A Firefox plugin will be developed to automatically generate UI modules for users. The idea is to provide the "select UI by click" capability in the plugin to select an area of UI. Then the plugin will extract the html source and use a special algorithm to generate Tellurium style UI modules using composite locators and group locating concept.  After that, the plugin will validate the generated UI module to make sure it is unique in the current DOM and output the results. 
  # Tellurium will provide a Locator Query Language to get the locators of Ui objects by some search criteria such as their attributes and their relationship to each other, i.e., parent, child, and sibling. That is to say, Tellurium will be interactive with the DOM in runtime so as to be adaptive to dynamic web page. 
  # The "Automated Acceptance Testing" feature will be added to Tellurium. The basic idea is to setup a server and the user can use web browser to browse all available tests defined in the registry at the server side. The user can select any test to run by typing in parameters required by the test and see the actual test result. 