#summary Tellurium jQuery Selector.
#labels Phase-Design,Phase-Support

= Introduction =

Start from version 0.6.0, Tellurium adds support for jQuery selector to address the problem that xpath is way too slow in IE web browser. 

Tellurium automatically builds runtime xpath or jQuery selector based on a flag _exploreJQuerySelector_ in DslContext, which is false by default. To use jQuery selector, you should call 

{{{
useJQuerySelector()
}}}

and use

{{{
disableJQuerySelector()
}}}

to go back to XPath as shown in the following diagram.


http://tellurium-users.googlegroups.com/web/jqueryxpath.png?gda=6PAnKEEAAACXZPxEX7Ki-M5C2JpeBoXXSeCZLNZLSTKezjdQbQSZ7bErkxyCRchkHxw6zyngrBhTCT_pCLcFTwcI3Sro5jAzlXFeCn-cdYleF-vtiGpWAA&gsc=yWkUQBYAAABg2sP7OurkFA0-Ab9h6nxKaKk2tFLs90LD5qOQGCC3Kw

Be aware that jQuery selector only works for composite locator, i.e., _clocator_. If you have base locator, which is xpath, then the jQuery selector will not work for you.


= How jQuery Selector Works ? =

The basic idea is to customize Selenium Core to load jQuery library at startup time. You can put jquery.js to the TestRunner.html and RemoteRunner.html. Another way is dump all jquery.js into user-extensions.js. Since our Engine prototype customizes Selenium core anyway, we use the first method.

After that, we register a custom locate strategy "jquery". By Selenium definition:

{{{
addLocationStrategy ( strategyName,functionDefinition )

}}}
    Defines a new function for Selenium to locate elements on the page. For example,
if you define the strategy "foo", and someone runs click("foo=blah"), we'll run your
function, passing you the string "blah", and click on the element that your function
returns, or throw an "Element not found" error if your function returns null. We'll
pass three arguments to your function:

  * locator: the string the user passed in
  * inWindow: the currently selected window
  * inDocument: the currently selected document

The function must return null if the element can't be found.

Arguments:

  * strategyName - the name of the strategy to define; this should use only letters [a-zA-Z] with no spaces or other punctuation.
  * functionDefinition - a string defining the body of a function in JavaScript. For example: return inDocument.getElementById(locator);

Accordingly, we define the custom locate strategy as follows,

{{{
addLocationStrategy("jquery", '''
  var found = $(inDocument).find(locator);
  if(found.length == 1 ){
    return found[0];
  }else if(found.length > 1){
    return found.get();
  }else{
    return null;
  }
''')
}}}

The code is pretty straightforward. When we found one element, return its DOM reference (Note: Selenium does not accept returning an array with only one element) and if we found multiple elements, we use jQuery get() method to return the DOM references. Otherwise, return null.

The actual code is a bit more complicated because we need to consider the attribute locator. We use the same format of attribute locator as the XPath one, i.e.,
 
{{{
locator@attribute
}}}

Apart from that, we need to create a set of custom Selenium methods and add the appropriate Selenium RC Java methods. For example, we create the following Selenium method 

{{{
Selenium.prototype.getAllText = function(locator){
  var $e = $(this.browserbot.findElement(locator));
  var out = [];
  $e.each(function(){
     out.push($(this).text());
  });

  return JSON.stringify(out);
};
}}} 

Then, create the corresponding Java method by extending Selenium

{{{
class CustomSelenium extends DefaultSelenium {

  def String getAllText(String locator){
     String[] arr = [locator];
     String st = commandProcessor.doCommand("getAllText", arr);
     return st;
  }
}
}}}

= New Features Provided by jQuery Selector =

The most important feature is that Tellurium automatically generates the runtime jQuery selector based on your UI module definition, more specifically, the composite locator _clocator_. Tellurium also supports group locating for jQuery Selector by using jQuery :has() pseudo class and multiple selectors. For example, the following UI module

{{{
ui.Container(uid: "Google", clocator: [tag: "table"], group: "true") {
   InputBox(uid: "Input", clocator: [tag: "input", title: "Google Search", name: "q"])
   SubmitButton(uid: "Search", clocator: [tag: "input", type: "submit", value: "Google Search", name: "btnG"])
   SubmitButton(uid: "ImFeelingLucky", clocator: [tag: "input", type: "submit", value: "I'm Feeling Lucky", name: "btnI"])
    }

}}}

could produce the jQuery selector with group locating as follows,

{{{
jquery=table:has(input[title=Google Search][name=q], input[type=submit][value=Google Search][name=btnG], input[type=submit][value$=m Feeling Lucky][name=btnI]) input[title=Google Search][name=q]
}}}

jQuery Selector provides the following additional Selenium methods, which are utilized in DslContext to form a set of new DSL methods:

  # _String getAllText(String locator)_: Get all text from the set of elements corresponding to the jQuery Selector.
  # _String getCSS(String locator, String cssName)_: Get the CSS properties for the set of elements corresponding to the jQuery Selector. 
  # _Number getJQuerySelectorCount(String locator)_: Get the number of elements matching the corresponding jQuery Selector
  # _boolean isDisabled(String locator)_: Test if an element is disabled.

jQuery supports the following attribute selectors
  * _[attribute]_: have the specified attribute
  * _[attribute=value]_: have the specified attribute with a certain value
  * _[attribute!=value]_: either don't have the specified attribute or do have the specified attribute but not with a certain value.
  * _[attribute^=value]_: have the specified attribute and it starts with a certain value.
  * _[attribute$=value]_: have the specified attribute and it ends with a certain value.
  * _[attribute*=value]_: have the specified attribute and it contains a certain value.

Tellurium supports all the attribute selectors, that is to say, it looks at the prefix of the value and converts them to the appropriate attribute selectors if the values include either '!', '^', '$', or '`*`'. Be aware Tellurium partial matching symbol "%%" is depreciated. Please use the new symbols.
 
The are something you should be aware of for jQuery Selector:
  * If you have duplicated "tag" + "id" on the page, jQuery selector always returns the first one.
  * Some attribute may not working in jQuery, for example, the "action" attribute in a form. Tellurium has a black list to automatically filter out the attributes that are not honored by jQuery selector.
  * Seems the "src" attribute in Image has to be full URL such as http://www.google.com. One workaround is to put '`*`' before the URL.

= New DslContext Methods =

Tellurium provides a set of locator agnostic methods, i.e., the method will automatically decide to use XPath or jQuery dependent on the _exploreJQuerySelector_ flag, which can be turn on and off by the following two methods:

{{{

public void useJQuerySelector()

public void disableJQuerySelector()

}}}

In the meanwhile, Tellurium also provides the corresponding XPath specific and jQuery selector specific methods for your convenience. However, we recommend you to use the locator agnostic methods until you have a good reason not to. 

The new methods are listed here:

==== Get the Generated locator from the UI module ====

Locator agnostic:
  * String getLocator(String uid)

JQuery selector specific:
  * String getSelector(String uid)

XPath specific: 
  * String getXPath(String uid) 

==== Get the Number of Elements matching the Locator ====

Locator agnostic:
  * Number getLocatorCount(String locator)

JQuery selector specific:
  * Number getJQuerySelectorCount(String jQuerySelector)

XPath specific: 
  * Number getXpathCount(String xpath) 
 
==== Table methods ====

Locator agnostic:
  * int getTableHeaderColumnNum(String uid) 
  * int getTableFootColumnNum(String uid)
  * int getTableMaxRowNum(String uid)
  * int getTableMaxColumnNum(String uid)
  * int getTableMaxRowNumForTbody(String uid, int ntbody)
  * int getTableMaxColumnNumForTbody(String uid, int ntbody)
  * int getTableMaxTbodyNum(String uid)

JQuery selector specific:
  * int getTableHeaderColumnNumBySelector(String uid)
  * int getTableFootColumnNumBySelector(String uid)
  * int getTableMaxRowNumBySelector(String uid)
  * int getTableMaxColumnNumBySelector(String uid)
  * int getTableMaxRowNumForTbodyBySelector(String uid, int ntbody)
  * int getTableMaxColumnNumForTbodyBySelector(String uid, int ntbody)
  * int getTableMaxTbodyNumBySelector(String uid)
  * 

XPath specific:  
  * int getTableHeaderColumnNumByXPath(String uid) 
  * int getTableFootColumnNumByXPath(String uid)
  * int getTableMaxRowNumByXPath(String uid)
  * int getTableMaxColumnNumByXPath(String uid)
  * int getTableMaxRowNumForTbodyByXPath(String uid, int ntbody)
  * int getTableMaxColumnNumForTbodyByXPath(String uid, int ntbody)
  * int getTableMaxTbodyNumByXPath(String uid) 

==== Check if an Element is Disabled ====

Locator agnostic:
  * boolean isDisabled(String uid)

JQuery selector specific:
  * boolean isDisabledBySelector(String uid)

XPath specific: 
  * boolean isDisabledByXPath(String uid)

==== Get the Attribute ====

Locator agnostic:
  * def getAttribute(String uid, String attribute)

==== Check the CSS Class  ====

Locator agnostic
  * def hasCssClass(String uid, String cssClass)

==== Get CSS Properties ====

JQuery selector specific:
  * String[] getCSS(String uid, String cssName)

==== Get All Data from a Table ====

JQuery selector specific:
  * String[] getAllTableCellText(String uid)
  * String[] getAllTableCellTextForTbody(String uid, int index)

= Performance Comparison =

= Reference Materials =