#summary Tellurium User Guide
#labels Featured,Phase-Implementation

= Tellurium User Guide =

== Tellurium APIs ==

Tellurium APIs include all methods defined in DslContext. The time here is in miliseconds unless otherwise specified. 

=== DSL Methods ===

Here we list all the available methods that can be used as DSLs in DslContext and their corresponding DSL syntax. Note the id here refers to the UiID in the format of "issueSearch.issueType" and the time units are all in milliseconds if not specified. Be aware, you can only apply the methods to the Ui Object if it has these methods defined.

  * {{{mouseOver id}}}: Simulates a user hovering a mouse over the specified element. 

  * {{{mouseOut id}}}: Simulates a user moving the mouse pointer away from the specified element. 

  * {{{mouseDown id}}}: Simulates a user pressing the mouse button (without releasing it yet) on the specified element.

  * {{{click id}}}: Clicks on a link, button, checkbox or radio button. If the click action causes a new page to load (like a link usually does), call waitForPageToLoad. 

  * {{{doubleClick id}}}: Double clicks on a link, button, checkbox or radio button. If the double click action causes a new page to load (like a link usually does), call waitForPageToLoad. 

  * {{{clickAt id, coordination}}}: Clicks on a link, button, checkbox or radio button. If the click action causes a new page to load (like a link usually does), call waitForPageToLoad. 

  * {{{check id}}}: Clicks on a link, button, checkbox or radio button. If the click action causes a new page to load (like a link usually does), call waitForPageToLoad.

  * {{{uncheck id}}}: Uncheck a toggle-button (checkbox/radio). 

  * {{{type id, input}}}: Sets the value of an input field, as though you typed it in. 

  * {{{keyType id, value}}}: Simulates keystroke events on the specified element, as though you typed the value key-by-key. 

  * {{{typeAndReturn id, input}}}: Sets the value of an input field followed by {{{<Return>}}} key. 

  * {{{clearText id}}}: Resets input field to an empty value. 

  * {{{select id, optionLocator}}}: Select an option from a drop-down using an option locator. 

  * {{{selectByLabel id, optionLocator}}}: Select an option from a drop-down using an option label. 

  * {{{selectByValue id, optionLocator}}}: Select an option from a drop-down using an option value. 

  * {{{addSelectionByLabel id, optionLocator}}}: Add a selection to the set of selected options in a multi-select element using an option label.

  * {{{addSelectionByValue id, optionLocator}}}: Add a selection to the set of selected options in a multi-select element using an option value. 

  * {{{removeSelectionByLabel id, optionLocator}}}: Remove a selection from the set of selected options in a multi-select element using an option label. 

  * {{{removeSelectionByValue id, optionLocator}}}: Remove a selection from the set of selected options in a multi-select element using an option value. 

  * {{{removeAllSelections id}}}: Unselects all of the selected options in a multi-select element. 

  * {{{pause time}}}: Suspend the current thread for a specified milliseconds.

  * {{{submit id, attribute}}}: Submit the specified form. This is particularly useful for forms without submit buttons, e.g. single-input "Search" forms.

  * {{{openWindow UID, url}}}: Opens a popup window (if a window with that ID isn't already open). After opening the window, you'll need to select it using the selectWindow command.

  * {{{selectWindow UID}}}: Selects a popup window; once a popup window has been selected, all commands go to that window. To select the main window again, use null as the target.

  * {{{closeWindow UID}}}: Close the popup window. 

  * {{{selectMainWindow}}}: Select the original window, i.e., the Main window.

  * {{{selectFrame frameName}}}: Selects a frame within the current window.

  * {{{selectParentFrameFrom frameName}}}: Select the parent frame from the frame identified by the "frameName".

  * {{{selectTopFrameFrom}}}: Select the main frame from the frame identified by the "frameName".

  * {{{waitForPopUp UID, timeout}}}: Waits for a popup window to appear and load up.

  * {{{waitForPageToLoad timeout}}}: Waits for a new page to load.

  * {{{waitForFrameToLoad frameAdddress, timeout}}}: Waits for a new frame to load.

  * {{{runScript script}}}: Creates a new "script" tag in the body of the current test window, and adds the specified text into the body of the command.  Scripts run in this way can often be debugged more easily than scripts executed using Selenium's "getEval" command.  Beware that JS exceptions thrown in these script tags aren't managed by Selenium, so you should probably wrap your script in try/catch blocks if there is any chance that the script will throw an exception.

  * {{{captureScreenshot filename}}}: Captures a PNG screenshot to the specified file.

  * {{{chooseCancelOnNextConfirmation}}}: By default, Selenium's overridden window.confirm() function will return true, as if the user had manually clicked OK; after running this command, the next call to confirm() will return false, as if the user had clicked Cancel.  Selenium will then resume using the default behavior for future confirmations, automatically returning true (OK) unless/until you explicitly call this command for each confirmation.

  * {{{chooseOkOnNextConfirmation}}}: Undo the effect of calling chooseCancelOnNextConfirmation.  Note that Selenium's overridden window.confirm() function will normally automatically return true, as if the user had manually clicked OK, so you shouldn't need to use this command unless for some reason you need to change your mind prior to the next confirmation.  After any confirmation, Selenium will resume using the default behavior for future confirmations, automatically returning true (OK) unless/until you explicitly call chooseCancelOnNextConfirmation for each confirmation.

  * {{{answerOnNextPrompt(String answer))}}}: Instructs Selenium to return the specified answer string in response to the next JavaScript prompt [window.prompt()].

  * {{{goBack}}}: Simulates the user clicking the "back" button on their browser.

  * {{{refresh}}}: Simulates the user clicking the "Refresh" button on their browser.

  * {{{dragAndDrop(uid, movementsString)}}}:  Drags an element a certain distance and then drops it.

  * {{{dragAndDropTo(sourceUid, targetUid)}}}: Drags an element and drops it on another element.


===  Data Access Methods ===

In addition to the above DSLs, Tellurium provides Selenium-compatible data access methods so that you can get data or Ui statuses from the web. The methods are listed here:

  * {{{ String[] getSelectOptions(id)}}}: Gets all option labels in the specified select drop-down. 

  * {{{String[] getSelectedLabels(id)}}}: Gets all selected labels in the specified select drop-down. 

  * {{{String getSelectedLabel(id)}}}: Gets a single selected label in the specified select drop-down. 

  * {{{String[] getSelectedValues(id)}}}: Gets all selected values in the specified select drop-down. 

  * {{{String getSelectedValue(id)}}}: Gets a single selected value in the specified select drop-down. 

  * {{{String[] getSelectedIndexes(id)}}}: Gets all selected indexes in the specified select drop-down. 

  * {{{String getSelectedIndex(id)}}}: Gets a single selected index in the specified select drop-down. 

  * {{{String[] getSelectedIds(id)}}}: Gets option element ID for selected option in the specified select element. 

  * {{{String getSelectedId(id)}}}: Gets a single element ID for selected option in the specified select element. 

  * {{{boolean isSomethingSelected(id)}}}: Determines whether some option in a drop-down menu is selected. 

  * {{{String waitForText(id, timeout)}}}: Waits for a text event. 

  * {{{int getTableHeaderColumnNum(id)}}}: Gets the column header count of a table

  * {{{int getTableMaxRowNum(id)}}}: Gets the maximum row count of a table

  * {{{int getTableMaxColumnNum(id)}}}: Gets the maximum column count of a table

  * {{{int getTableFootColumnNum(id)}}}: Gets the maximum foot column count of a standard table

  * {{{int getTableMaxTbodyNum(id)}}}: Gets the maximum tbody count of a standard table

  * {{{int getTableMaxRowNumForTbody(id, index)}}}: Gets the maximum row number of the index-th tbody of a standard table

  * {{{int getTableMaxColumnNumForTbody(id, index)}}}: Gets the maximum column number of the index-th tbody of a standard table 

  * {{{int getListSize(id)}}}: Gets the item count of a list

  * {{{getUiElement(id)}}}: Gets the UIObject of an element.
  
  * {{{boolean isElementPresent(id)}}}: Verifies that the specified element is somewhere on the page.

  * {{{boolean isVisible(id)}}}: Determines if the specified element is visible. An element can be rendered invisible by setting the CSS "visibility" property to "hidden", or the "display" property to "none", either for the element itself or one if its ancestors.  This method will fail if the element is not present.

  * {{{boolean isChecked(id)}}}: Gets whether a toggle-button (checkbox/radio) is checked.  Fails if the specified element doesn't exist or isn't a toggle-button.

  * {{{boolean isDisabled(id)}}}: Determines if an element is disabled or not

  * {{{boolean isEnabled(id)}}}: Determines if an element is enabled or not

  * {{{boolean waitForElementPresent(id, timeout)}}}: Wait for the Ui object to be present

  * {{{boolean waitForElementPresent(id, timeout, step)}}}: Wait for the Ui object to be present and check the status by step.

  * {{{boolean waitForCondition(script, timeout)}}}: Runs the specified JavaScript snippet repeatedly until it evaluates to "true". The snippet may have multiple lines, but only the result of the last line will be considered.

  * {{{String getText(id)}}}: Gets the text of an element. This works for any element that contains text. This command uses either the textContent (Mozilla-like browsers) or the innerText (IE-like browsers) of the element, which is the rendered text shown to the user.

  * {{{String getValue(id)}}}: Gets the (whitespace-trimmed) value of an input field (or anything else with a value parameter). For checkbox/radio elements, the value will be "on" or "off" depending on whether the element is checked or not.

  * {{{String getLink(id)}}}: Get the href of an element.

  * {{{String getImageSource(id)}}}: Get the image source element.

  * {{{String getImageAlt(id)}}}: Get the image alternative text of an element.

  * {{{String getImageTitle(id)}}}: Get the image title of an element.

  * {{{getAttribute(id, attribute)}}}: Get an attribute of an element.

  * {{{String getBodyText()}}}: Gets the entire text of the page.

  * {{{boolean isTextPresent(pattern)}}}: Verifies that the specified text pattern appears somewhere on the rendered page shown to the user.

  * {{{boolean isEditable(id)}}}: Determines whether the specified input element is editable, ie hasn't been disabled. This method will fail if the specified element isn't an input element.

  * {{{String getHtmlSource()}}}: Returns the entire HTML source between the opening and closing "html" tags.

  * {{{String getExpression(expression)}}}: Returns the specified expression.

  * {{{getXpathCount(xpath)}}}: Returns the number of nodes that match the specified xpath, eg. "//table" would give the number of tables.

  * {{{String getCookie()}}}: Return all cookies of the current page under test.

  * {{{boolean isAlertPresent()}}}: Has an alert occurred?

  * {{{boolean isPromptPresent()}}}: Has a prompt occurred?

  * {{{boolean isConfirmationPresent()}}}: Has confirm() been called?

  * {{{String getAlert()}}}: Retrieves the message of a JavaScript alert generated during the previous action, or fail if there were no alerts.

  * {{{String getConfirmation()}}}: Retrieves the message of a JavaScript confirmation dialog generated during the previous action.

  * {{{String getPrompt()}}}: Retrieves the message of a JavaScript question prompt dialog generated during the previous action.

  * {{{String getLocation()}}}: Gets the absolute URL of the current page.

  * {{{String getTitle()}}}: Gets the title of the current page.

  * {{{String[] getAllButtons()}}}: Returns the IDs of all buttons on the page.

  * {{{String[] getAllLinks()}}}: Returns the IDs of all links on the page.

  * {{{String[] getAllFields()}}}: Returns the IDs of all input fields on the page.

  * {{{String[] getAllWindowIds()}}}: Returns the IDs of all windows that the browser knows about.

  * {{{String[] getAllWindowNames()}}}: Returns the names of all windows that the browser knows about.

  * {{{String[] getAllWindowTitles()}}}: Returns the titles of all windows that the browser knows about.

== Tellurium UI Objects==

Tellurium provides a set of predefined Ui objects, which users can use directly. Here we describe them one by one in details.

=== Basic Ui Object ===

The basic Ui object is an abstract class and users cannot instantiate it directly. The basic Ui Object works as the base class for all Ui objects and it includes the following attributes:

  # uid: Ui object's identifier
  # namespace: for future extension
  # locator: the locator of the UI object, could be a base locator or a composite locator
  # respond: the JavaScript events the UI object can respond to. The value is a list.

and the base Ui object also provides the following methods:

  * boolean isElementPresent()
  * boolean isVisible()
  * boolean isDisabled()
  * waitForElementPresent(int timeout), where the time unit is ms.
  * waitForElementPresent(int timeout, int step)
  * String getText()
  * getAttribute(String attribute)

Obviously, all Ui Objects will inherit the above attributes and methods. But be aware that you usually do not call these methods directly and you should use DSL syntax instead. For example, use

{{{
  click "google_start_page.googlesearch"
}}}

In this way, Tellurium will first map the UiID "google_start_page.googlesearch" to the actual Ui object and then call the _click_ method on it. If that Ui object does not have the _click_ method defined, you will get an error.

=== jQuery Selector ===

The motivation behind the jQuery Selector is to improve the test speed in IE since IE lacks of native XPath support and the XPath is very slow. Tellurium exploits jQuery selector capability to improve the test speed dramatically. 

Tellurium supports both XPath and jQuery selector and still uses XPath as the default locator. To use jQuery selector, you need to explicitly tell Tellurium to use jQuery selector. 

To enable jQuery selector call the following method.

   * {{{useJQuerySelector()}}}: Use jQuery selector.

To disable jQuery selector call the following method, it also switches back to the default
locator. i.e. XPath

   * {{{disableJQuerySelector()}}}: Switch back to XPath locator.


jQuery selector only works for composite locator, i.e. clocator. You cannot have base locator, i.e., XPath, in your UI module.

jQuery Selector provides the following additional Selenium methods, which are utilized in DslContext? to form a set of new DSL methods.

   * {{{String getAllText(String locator)}}}: Get all text from the set of elements corresponding to the jQuery Selector.

   * {{{String getCSS(String locator, String cssName)}}} : Get the CSS properties for the set of elements corresponding to the jQuery Selector.

   * {{{Number getJQuerySelectorCount(String locator)}}} : Get the number of elements matching the corresponding jQuery Selector

jQuery also supports the following attribute selectors.

   * {{{attribute}}}: have the specified attribute.

   * {{{attribute=value}}}: have the specified attribute with a certain value.

   * {{{attribute!=value}}}: either don't have the specified attribute or do have the specified attribute but not with a certain value.

   * {{{attribute^=value}}}: have the specified attribute and it starts with a certain value.

   * {{{attribute$=value}}}: have the specified attribute and it ends with a certain value.

   * {{{attribute*=value}}}: have the specified attribute and it contains a certain value.

Apart from the above, jQuery selector also provides a jQuery selector version of many existing DSL methods, for instance,

{{{
int getTableHeaderColumnNumBySelector(String uid)
}}}

But you should use locator agnostic API, such as

{{{
int getTableHeaderColumnNum(String uid) 
}}}

Under the hood, Tellurium core will call the appropriate API based on what locator you are currently using. For more details, please see Tellurium jQuery Selector Guide.


=== Button ===

Button represents various Buttons on the web and its default tag is "input". The following methods can be applied to Button:

  * click()
  * doubleClick()
  * clickAt(String coordination)

Example:

{{{
Button(uid: "searchButton", clocator: [value: "Search", name: "btn"])
}}}

=== SubmitButton ===

SubmitButton is a special Button with its type being "submit".

Example:

{{{
SubmitButton(uid: "search_web_button", clocator: [value: "Search the Web"])
}}}

=== CheckBox ===

The CheckBox on the web is abstracted as "CheckBox" Ui object. The default tag for CheckBox is "input" and its type is "checkbox". CheckBox comes with the following methods:

  * check()
  * boolean isChecked()
  * uncheck()

Example:

{{{
CheckBox(uid: "autoRenewal", clocator: [dojoattachpoint: 'dap_auto_renew'])
}}}

=== Div ===

Div is often used in the Dojo framework and it can represent a lot objects. Obviously, its tag is "div" and it has the following method:

  * click()

Example:


{{{
Div(uid: "dialog", clocator: [class: 'dojoDialog', id: 'loginDialog'])
}}}

=== Image ===

Image is used to abstract the "img" tag and it comes with the following additional methods:

  * getImageSource()
  * getImageAlt()
  * String getImageTitle()

Example:

{{{
Image(uid: "dropDownArrow", clocator: [src: 'drop_down_arrow.gif'])
}}}

=== Icon ===

Icon is similar to the Image object, but user can perform actions on it. As a result, it can have the following additional methods:

  * click()
  * doubleClick()
  * clickAt(String coordination)

Example:

{{{
Icon(uid: "taskIcon", clocator:[tag: "p", dojoonclick: 'doClick', img: "Show_icon.gif"] )
}}}

=== RadioButton ===

RadioButton is the abstract object for the Radio Button Ui. As a result, its default tag is "input" and its type is "radio". RadioButton has the following additional methods:

  * check()
  * boolean isChecked()
  * uncheck()
  * String getValue()

Example:

{{{
RadioButton(uid: "autoRenewal", clocator: [dojoattachpoint: 'dap_auto_renew'])
}}}

=== TextBox ===

TextBox is the abstract Ui object from which you can get back the text, i.e., it comes with the method:

  * String waitForText(int timeout)

Note, TextBox can have various types of tags.

Example:

{{{
TextBox(uid: "searchLabel", clocator: [tag: "span"])
}}}

=== InputBox ===

InputBox is the Ui where user types in input data. As its name stands, InputBox's default tag is "input". InputBox has the following additional methods:

  * type(String input)
  * keyType(String input), used to simulate keyboard typing
  * typeAndReturn(String input)
  * clearText()
  * boolean isEditable()
  * String getValue()

Example:

{{{
InputBox(uid: "searchBox", clocator: [name: "q"])
}}}

=== UrlLink ===

UrlLink stands for the web url link, i.e., its tag is "a". UrlLink has the following additional methods:

  * String getLink()
  * click()
  * doubleClick()
  * clickAt(String coordination)

Example:

{{{
UrlLink(uid: "Grid", clocator: [text: "Grid", direct: "true"])
}}}

=== Selector ===

Selector represents the Ui with tag "select" and user can select from a set of options. Selector has a lot of methods, such as:

  * selectByLabel(String target)
  * selectByValue(String value)
  * addSelectionByLabel(String target)
  * addSelectionByValue(String value)
  * removeSelectionByLabel(String target)
  * removeSelectionByValue(String value)
  * removeAllSelections()
  * String[] getSelectOptions()
  * String[] getSelectedLabels()
  * String getSelectedLabel()
  * String[] getSelectedValues()
  * String getSelectedValue()
  * String[] getSelectedIndexes()
  * String getSelectedIndex()
  * String[] getSelectedIds()
  * String getSelectedId()
  * boolean isSomethingSelected()

Example:

{{{
Selector(uid: "issueType", clocator: [name: "can", id: "can"])
}}}

=== Container ===

Container is an abstract object that can hold a collection of Ui objects. As a result, the  Container has a special attribute "useGroupInfo" and its default value is false. If this attribute is true, the Group Locating is enabled. But make sure all the Ui objects inside the Container are children nodes of the Container in the DOM, otherwise, you should not use the Group Locating capability.

Example:

{{{
ui.Container(uid: "google_start_page", clocator: [tag: "td"], group: "true"){
    InputBox(uid: "searchbox", clocator: [title: "Google Search"])
    SubmitButton(uid: "googlesearch", clocator: [name: "btnG", value: "Google Search"])
    SubmitButton(uid: "Imfeelinglucky", clocator: [value: "I'm Feeling Lucky"])
}
}}}

=== Form ===

Form is a type of Container with its tag being "form" and it represents web form. Like Container, it has the capability to use Group Locating and it has a special method:

  * submit()

This method is useful and can be used to submit input data if the form does not have a submit button.

Example,

{{{
ui.Form(uid: "downloadSearch", clocator: [action: "list", method: "get"], group: "true") {
    Selector(uid: "downloadType", clocator: [name: "can", id: "can"])
    TextBox(uid: "searchLabel", clocator: [tag: "span"])

    InputBox(uid: "searchBox", clocator: [name: "q"])
    SubmitButton(uid: "searchButton", clocator: [value: "Search"])
}
}}}

=== Table ===

Table is one of the most complicated Ui Object and also the most often used one. Obviously, its tag is "table" and a table could have headers besides rows and columns. Table is a good choice for data grid. Tellurium can handle its header, rows, and columns automatically for users. One important is the Table has different UiID than other Ui objects. For example, if the id of the table is "table1", then its i-th row and j-th column is referred as {{{"table1[i][j]"}}} and its m-th header is {{{"table1.header[m]"}}}.

Another distinguished feature of Table is that you can define Ui template for its elements. For example, the following example defines different table headers and the template for the first column, the element on the second row and the second column, and the template for all the other elements in other rows and columns.

{{{
ui.Table(uid: "downloadResult", clocator: [id: "resultstable", class: "results"], group: "true"){
    //define table header
    //for the border column
    TextBox(uid: "header: 1", clocator: [:])
    UrlLink(uid: "header: 2", clocator: [text: "%%Filename"])
    UrlLink(uid: "header: 3", clocator: [text: "%%Summary + Labels"])
    UrlLink(uid: "header: 4", clocator: [text: "%%Uploaded"])
    UrlLink(uid: "header: 5", clocator: [text: "%%Size"])
    UrlLink(uid: "header: 6", clocator: [text: "%%DownloadCount"])
    UrlLink(uid: "header: 7", clocator: [text: "%%..."])

    //define Ui object for the second row and the second column
    InputBox(uid: "row: 2, colum: 2" clocator: [:])
    //define table elements
    //for the border column
    TextBox(uid: "row: *, column: 1", clocator: [:])
    //For the rest, just UrlLink
    UrlLink(uid: "all", clocator: [:])
}
}}} 

Be aware, the templates inside the Table follow the name convention:

  * For the i-th row, j-th column, the uid should be "row: i, column: j"
  * The wild case for row or column is {{{"*"}}}
  * "all" stands for matching all rows and columns
  
As a result, {{{"row : *, column : 3"}}} refers to the 3rd column for all rows. Once the templates are defined for the table, Tellurium uses a special way to find a matching for a Ui element {{{"table[i][j]"}}} in the table. i.e., the following rules apply,

   * First, Tellurium tries to find the template defined for the i-th row, j-th column.
   * If not found, Tellurium tries to search for a general template {{{"row: *, column: j"}}}, i.e., the template for column j.
   * If not found, Tellurium tries to search for another general template {{{"row: i, column: *"}}}, i.e., the template for row i.
   * If not found either, Tellurium tries to find the template matching all rows and columns. 
   * If still out of luck, Tellurium will use a TextBox as the default element for this element.

Generally speaking, Tellurium always searches for the special case first, then more general case, and until the all matching case. In this way, user can define very flexible templates for tables.

Table is a type of Container and thus, it can use the Group Locating feature. Table has the following special methods:

  * boolean hasHeader()
  * int getTableHeaderColumnNum()
  * int getTableMaxRowNum()
  * int getTableMaxColumnNum()

From Tellurium 0.6.0, you can also specify the tbody attribute for the Table object and this may be helpful if you have multiple tbody elements inside a single table tab. For example, you can specify tbody as follows,

{{{
Container(uid: "tables", clocator:[:]){
     Table(uid: "first", clocator: [id: "someId", tbody: [position: "1"]]){
          ......
      }
     Table(uid: "second", clocator: [id: "someId", tbody: [position: "2"]]){
          ......
      }

      ...

} 

}}}

=== StandardTable ===

A StandardTable is a table in the following format

{{{

table
      thead
         tr
           td
           ...
           td
      tbody
         tr
           td
           ...
           td
         ...
       tbody (multiple tbodies)
         tr
           td
           ...
           td
         ...
      tfoot
         tr
           td
           ...
           td 
}}}

For a StandardTable, you can specify UI templates for different tbodies. Apart from the methods in Table, it has the following additional methods:

  * int getTableFootColumnNum()
  * int getTableMaxTbodyNum()
  * int getTableMaxRowNumForTbody(int tbody_index)
  * int getTableMaxColumnNumForTbody(int body_index)

Example:

{{{
ui.StandardTable(uid: "table", clocator: [id: "std"]) {
   UrlLink(uid: "header: 2", clocator: [text: "%%Filename"])
   UrlLink(uid: "header: 3", clocator: [text: "%%Uploaded"])
   UrlLink(uid: "header: 4", clocator: [text: "%%Size"])
   TextBox(uid: "header: all", clocator: [:])

   Selector(uid: "tbody: 1, row:1, column: 3", clocator: [name: "can"])
   SubmitButton(uid: "tbody: 1, row:1, column:4", clocator: [value: "Search", name: "btn"])
   InputBox(uid: "tbody: 1, row:2, column:3", clocator: [name: "words"])
   InputBox(uid: "tbody: 2, row:2, column:3", clocator: [name: "without"])
   InputBox(uid: "tbody: 2, row:*, column:1", clocator: [name: "labels"])

   TextBox(uid: "foot: all", clocator: [tag: "td"])
}
}}}

=== List ===

List is also a Container type abstract Ui object and it can be used to represent any list like Ui objects. Very much like Table, users can define Ui templates for List and following rule of "the special case first and then the general case". The index number is  used to specify an element and "all" is used to match all elements in the List. List also uses TextBox as the default Ui if no template could be found. Since List is a Container type, it can use the Group Locating feature.

List has one special attribute "separator", which is used to indicate the tag used to separate different List UI elements. If "separator" is not specified or "", all UI elements must be under the same DOM node, i.e., they are siblings.

Example:

{{{

List(uid: "subcategory", locator: "", separator: "p"){
    InputBox(uid: "2", clocator: [title: "Google Search"])
    UrlLink(uid: "all", clocator: [:])
}
}}} 

=== SimpleMenu ===

The SimpleMenu represent a menu without a header and only contains menu items. The default tag is "div" and user should specify the alias name for each menu item. For example,

{{{
//items is a map in the format of "alias name" : menu_item
ui.SimpleMenu(uid: "IdMenu", clocator:[class: "popup", id: "pop_0"],
    items: ["SortUp":"Sort Up", "SortDown":"Sort Down", "HideColumn":"Hide Column"])
}}}

The above menu specified the menu item "Sort up", "Sort Down", and "Hiden Column" with their alias names. Users should use the alias name to refer the menu item, for instance, "IdMenu.SortUp".

The SimpleMenu has the following methods:

  * click()
  * mouseOve()
  * mouseOut()

=== SelectMenu ===

SelectMenu is designed for the selecting column menu on the Tellurium Issues page and it is prototyped to demonstrate how to write Ui object with interaction with the DOM since the Ui elements have different patterns at runtime, hence, it is not a general purpose Ui object. SelectMenu could have a header and its menu item content could keep changing when users select different columns to display. 

The SelectMenu on the Tellurium issues page is expressed as follows,

{{{
ui.SelectMenu(uid: "selectColumnMenu", clocator:[class: "popup",id: "pop__dot"], title: "Show columns:",
    items: ["ID":"ID", "Type":"Type", "Status":"Status", "Priority":"Priority", "Milestone":"Milestone", "Owner":"Owner", "Summary":"Summary", "Stars":"Stars", "Opened":"Opened", "Closed":"Closed", "Modified":"Modified", "EditColumn":"Edit Column Spec..." ])
}}}

Like SimpleMenu, SelectMenu also has the following methods:

  * click()
  * mouseOve()
  * mouseOut()

=== Frame ===

Frame is a type of Container and is used to mode Frame or IFrame. It includes the
following attributes:
  * id
  * name
  * title

and the following methods

  * selectParentFrame() 
  * selectTopFrame() 
  * selectFrame(locator)
  * getWhetherThisFrameMatchFrameExpression(currentFrameString, target)
  * waitForFrameToLoad(frameAddress, timeout) 

When you test website with IFrames, you should use multiple window mode, i.e., set the option useMultiWindows to be true in TelluriumConfig.groovy.

Example,

{{{
ui.Frame(uid: "SubscribeFrame", name: "subscrbe"){
   Form(uid: "LoginForm", clocator: [name: "loginForm"]){
      InputBox(uid: "UserName", clocator: [id: "username", type: "text"])
      InputBox(uid: "Password", clocator: [id: "password", type: "password"])
      Button(uid: "Login", clocator: [type: "image", class: "login"])
      CheckBox(uid: "RememberMe", clocator: [id: "rememberme"])
   }
} 
}}}

=== Window ===

Window is a type of Container and is used to mode Popup Window. It includes the
following attributes:
  * id
  * name
  * title

and the following methods

  * openWindow(String UID, String url)
  * selectWindow(String UID)
  * closeWindow(String UID)
  * boolean getWhetherThisWindowMatchWindowExpression(String currentWindowString, String target)
  * waitForPopup(String UID, int timeout)
 
Example,

{{{
ui.Window(uid: "HelpWindow", name: "HelpWindow"){
...
}

openWindow helpUrl, "HelpWindow"
waitForPopUp "HelpWindow", 2000
selectWindow "HelpWindow" 
...
selectMainWindow()
}}}

=== Option ===

Option is also designed to be adaptive the dynamic web. Option is a pure abstract object and it holds multiple UIs with each representing a possible UI pattern at runtime. For example, the List/Grid selector on the issue page can described as: 

{{{
//The selector to choose the data grid layout as List or Grid
ui.Option(uid: "layoutSelector"){
    Container(uid: "layoutSelector", clocator: [tag: "div"], group: "true") {
        TextBox(uid: "List", clocator: [tag: "b", text: "List", direct: "true"])
        UrlLink(uid: "Grid", clocator: [text: "Grid", direct: "true"])
    }
    Container(uid: "layoutSelector", clocator: [tag: "div"], group: "true") {
        UrlLink(uid: "List", clocator: [text: "List", direct: "true"])
        TextBox(uid: "Grid", clocator: [tag: "b", text: "Grid", direct: "true"])
    }
}
}}}

Note, the option's uid must be the same as the next UI objects it represent and in this way, you do not need to include option's uid in the UiID. For example,  you can just use

{{{
click "layoutSelector.List"
}}}

instead of

{{{
click "layoutSelector.layoutSelector.List"
}}}

The option object will automatically detect which UI pattern you need to use at runtime. 