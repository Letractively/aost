#labels Featured,Phase-Design
= Introduction =

*Tellurium Automated Testing Framework* (_Tellurium_) framework
  * Written in *Groovy*, test cases can be written in *Java* or *Groovy* 
  * Include a *Domain Specific Language* (_DSL_) to define UI objects 
  * Can also use the _DSL_ to describe events, actions, or assertions 
  * include an *Object to Locator Mapping framework* (_OLM_)
  * Tellurium can automatically generate the UI object locator for you
  * Tellurium implements the *group locating* concept to utilize a group of UI objects to help locating their locators
  * Make it possible for users to write Selenium tests when they start coding
  * Reusable, easier to refactor and maintain
  * Provide _DSL_ script executor so that non-developers can write Selenium tests in DSL
  * Provide *Data Driven Testing* feature for Tellurium tests. You can specify input data format and define different tests. Then use input data to drive the testing. The test result can be output as an XML file.

= Details =

== UI Objects ==

The UI Object includes
  * uid: should be unique in a UI module
  * namespace: for future extension
  * locator: the locator of the UI object, could be XPATH, CSS selector... The easier way to find the locator would be to use firefox XPather plugin.
  * Features: the inherent feature of the UI component, for example, the selection UI component normally comes with “label=?” or “value=?”. Table always has the “table”, “tr”, “td”, “th” tags.
  * useGroupInfo: this option only applies to a collection type of UI object such as Container, Table, List, Form and so on. By default, this option is turned off. If it is on, the object will use the UI objects to help locating its locator.

Regular UI objects include Button, CheckBox, Icon, InputBox, Selector, TextBox, Table... 
A container is a special UI object and it could be a pure abstract object to hold and group different UI objects together. The container will make the objects inside searchable since it uses a list to hold them.

Users can also define custom UI objects. They need to create a UI builder for each new UI 
object and add it to the UiObjectBuilderRegistry.

Be aware that each UI object only has predefined set of events or actions. For example, the InputBox has the _type_ action, but the Selector does not have that.

== DSL ==
 
DSL can only be run in *DslContext*, which defines the basic DSLs. 

=== Define UI objects ===
_ui.Container_ is used to define the UI objects on the web and map them to objects.
For example, the search module in the google start page can be defined by 
the following DSL.

{{{
ui.Container(uid: "google_search"){
   InputBox(uid: "inputbox1", locator: "//input[@title='Google Search']")
   Button(uid: "button1", locator: "//input[@name='btnG' and @type='submit']")
}
}}}

The definition can be nested, for example
{{{
ui.Container(uid: "parent_ui"){
   InputBox(uid: "inputbox1", locator: "...")
   Button(uid: "button1", locator: "...")
   Container(uid: "child_ui){
     Selector(uid: "selector1", locator: "...")
     ...
     Container(uid: "grand_child"){
       TextBox(uid: "textbox1", locator: "...")
       ...
     }
   }
}
}}}

=== Basic DSLs ===

Because of the Groovy Syntax, each method in the DslContext is a DSL expression.
For example, the _click_ method as follows:
{{{
def click(String id){
  ...
}
}}}
is a dsl in the format:
{{{
  click id
}}}

Similarly, we have the following dsls:
{{{
doubleClick id
clickAt id, coordination
check id
uncheck id
type id, input
keyType id, input
typeAndReturn id, input
clearText id
select id, target
selectByLabel  id, target
selectByValue id, target
waitForText id, timeout
isElementPresent id
isVisible id
isChecked id
waitForElementPresent id, timeout
waitForElementPresentid, timeout, step
getText id
getValue id
pause milliseconds
}}}

=== Extended DSLs ===
The DslContext can be extended to include more DSLs. For example, 
the DslScriptEngine extends DslContext to add the following DSL
{{{
openUrl url
}}}
and other assertions defined in GroovyTestCase.

=== UI Object Locators ===
There are two type of UI object locators:
  * Base Locator: the actual locator at run time. Denoted by "locator".
  * Composite Locator: User specifies a set of parameters for the object and the actual locator will be derived automatically by Tellurium. Denoted by "clocator".

The Basic Locator is only a String that you can specify the run time locator, be aware that the basic locator can be a partial locator, Tellurium will construct the actual run time locator starting from the top level object and all the way to the current object. 

The Composite Locator is more complicated and its definition is as follows:
{{{
class CompositeLocator {
    String header
    String tag
    String text
    String trailer
    def position
    boolean direct
    Map<String, String> attributes = [:]
}
}}}

To use composite locator, you need to use "clocator" and its value is a map, i.e.,
{{{
clocator: [key1: value1, key2: value2, ...]
}}}
format in Groovy. The defined keys include "header", "tag", "text", "trailer", "position", and "direct". They are all optional. For most UI object, the html tag is fixed, for example, a Table's tag is always "table". If a UI object has fixed tag and it is defined in object class, you do not need to include "tag". The "direct" key specifies whether this UI object is a direct child of the header or its parent UI and the default value is "false".

You may have additional attributes, define them in the same way as the predefined keys. For example:
 
{{{
value: "Tellurium home"
}}} 

Header and Trailer are used to specify addition xpath related to this UI object and the final xpath is 
{{{
XPath = header + derived xpath for object + trailer
}}}

=== The Group Locating Concept (GLC) ===

The Group Locating Concept (GLC) concept comes from the simple observation, i.e., it is much easier to locate a collection of UI objects than a single UI object. The reason is multiple UI objects provide more search criteria to help you to locate the UIs. This concept is implemented in Tellurium. All collection type object, i.e., Container and its extended classes have an option to use the group locating concept. 

Let's see the differences between regular locating and group locating. Still take the google start page as an example:

{{{
ui.Container(uid: "google_start_page", clocator: [tag: "td"], group: "true"){
  InputBox(uid: "searchbox", clocator: [title: "Google Search"])
  SubmitButton(uid: "googlesearch", clocator: [name: "btnG", value: "Google Search"])
  SubmitButton(uid: "Imfeelinglucky", clocator: [value: "I'm Feeling Lucky"])
}

}}}

Here, clocator stands for composite locator. Without group locating, I can only use the given criteria 

{{{
tag = "td" 
}}}

to find the container locator, i.e., 
{{{
I am looking for a td html tag in the DOM
}}} 
which is quite difficult. If we use the group locating, the Container can use the group information provided by its children. Now, the problem becomes: 
{{{
  I am looking for a td html tag in the DOM and its children including an input box with
  title "Google Search", a submit button with name "btnG" and value "Google Search", and
  another submit button with value "I'm Feeling Lucky"
}}}
Woo! I have a lot of information to help me to locate the container. Once the container is found, all its children can be found very easily.

The direct result of group locating is that for most case, the information defined in the UI module itself is enough for you to locate all UI objects in that UI module. That is to say, your test code only depends on your own UI module, not its location and its outside. Even we change the UI, the test may still work.  

Another advantage is that you may be able to map your JSP, PHP, ASP,..., file directly to the UI module in Tellurium. This could help developers a lot for writing Selenium tests because they do not need to manually find the locator for an UI object. 

=== Define multiple UI modules in a single file ===
Initially, you can define only one UI module in a file that extends the DslContext class. Now, Tellurium supports multiple UI modules in a single file. This is extremely important for pure DSL scripts.

For example, you can define multiple UI modules as follows:
{{{
class AostProjectPage extends DslContext{
  public void defineUi() {
     //define the menu
     //It is fine to use Container to abstract Table if you have special table
     ui.Container(uid: "menu", clocator: [tag: "table", id: "mt", trailer: "/tbody/tr/th"], group: "true"){
     //since the actual text is  Project&nbsp;Home, we can use partial match here. Note "%%" stands for partial match
     UrlLink(uid: "project_home", clocator: [text: "%%Home"])
     UrlLink(uid: "downloads", clocator: [text: "Downloads"])
     UrlLink(uid: "wiki", clocator: [text: "Wiki"])
     UrlLink(uid: "issues", clocator: [text: "Issues"])
     UrlLink(uid: "source", clocator: [text: "Source"])
    }

    //define the search module, which includes an input box, two search buttons
    ui.Form(uid: "search", clocator: [:], group: "true"){
     InputBox(uid: "searchbox", clocator: [name: "q"])
     SubmitButton(uid: "search_project_button", clocator: [value: "Search Projects"])
     SubmitButton(uid: "search_web_button", clocator: [value: "Search the Web"])
    }
  }
}
}}}

== Data Driven Testing ==
Data Driven Testing is a different way to write tests, i.e, separate test data from the test scripts and the test flow is not controlled by the test scripts. It is controlled by the input file instead. In the input file, users can specify which test to run, what are input parameters, and what are expected results.
 

Tellurium provides a data to object mapping framework to convert input data to Java variables. Tellurium provides a class TelluriumDataDrivenModule, which extends DslContext, for user to define Ui modules, input data formats, and tests. The TelluriumDataDrivenTest is the actual test class which loads different TelluriumDataDrivenModules, reads input data, converts data to variables defined in the test scripts, run the tests specified by the input data, and report the test results in an XML file.

=== Data Provider ===
The data provider is the key component of the data driven testing. It reads data from input and binds them to variables defined in the test scripts. This part is handled by the data to object mapping framework. Data provider usually works behind the scene and it provides the following methods for users:

  # loadData file_name, load input data from a file. 
  # useData String_name, load input data from a String in the test script
  # bind("fieldSet field name"), bind a variable to a FieldSet field name
  # closeData, close the input data stream and report the test results

The file name should include the file path, for example,

{{{
  loadData "src/test/example/test/ddt/GoogleBookListCodeHostInput.txt"
}}}

Right now, Tellurium supports pipe format input file and will add more file format support later on. To change the file reader for different formats, please change the following settings in the configuration file TelluriumConfig.groovy:

{{{
    datadriven{
        dataprovider{
            //specify which IO reader you like the data provider to use
            //the valid options include "PipeFileReader" at this point
            reader = "PipeFileReader"
        }
    }

}}}

Sometimes, you may like to specify test data in the test scripts directly, useData is designed for this purpose and it loads input from a String. The String is usually defined in Groovy style using triple quota, for example:

{{{
    protected String data = """
        google_search | true | 865-692-6000 | tellurium
        google_search | false| 865-123-4444 | tellurium selenium test
        google_search | true | 755-452-4444 | tellurium groovy
        google_search | false| 666-784-1233 | tellurium user group
        google_search | true | 865-123-5555 | tellurium data driven
    """
    ...
    useData data
}}}

bind is the command to bind a variable to input Field Set field at runtime. FieldSet is the format of a line of data and it is defined in the next section. For example,

{{{
  def row = bind("GCHLabel.row")
}}}

is used to bind the row variable to the "row" field in the FieldSet "GCHLabel". Tellurium does not explicitly differentiate input parameters from the expected results in the input data. You only need to bind variables to the input data and then you can use any of them as the expected results for result comparison.

When you are done with your testing, please use "closeData" to close the input data stream. In the meantime, the result reporter will output the test results in the format you specified in the configuration file, for example, XML file as shown in the TelluriumConfig.groovy file:

{{{
    test{
        result{
            //specify what result reporter used for the test result
            //valid options include "SimpleResultReporter", "XMLResultReporter", and "StreamXMLResultReporter"
            reporter = "XMLResultReporter"
            //the output of the result
            //valid options include "Console", "File" at this point
            //if the option is "File", you need to specify the file name, other wise it will use the default
            //file name "TestResults.output"
            output = "Console"
            //test result output file name
            filename = "TestResult.output"
        }
    }

}}}

=== TelluriumDataDrivenModule ===
TelluriumDataDrivenModule is designed to provide a test module for data driven testing. Users should extend this class to define their own test modules. 


TelluriumDataDrivenModule provides one method "defineModule" for users to implement. Since it extends the DslContext class, users can define Ui modules just like in regular Tellurium Ui Module. For example:

{{{
       ui.Table(uid: "labels_table", clocator: [:], group: "true"){
         TextBox(uid: "row: 1, column: 1", clocator: [tag: "div", text: "Example project labels:"])
         Table(uid: "row: 2, column: 1", clocator: [header: "/div[@id=\"popular\"]"]){
             UrlLink(uid: "all", locator: "/a")
           }
       }
}}}

FieldSet is used to define the format of one line of input data and FieldSet consists of fields, i.e., columns, in the input data. There is a special field "test", which users can specify what test this line of data apply to. For example,

{{{
        fs.FieldSet(name: "GCHStatus", description: "Google Code Hosting input") {
            Test(value: "getGCHStatus")
            Field(name: "label")
            Field(name: "rowNum", type: "int")
            Field(name: "columNum", type: "int")
        }  
}}}

The above FieldSet defines the input data format for testing google code hosting web page. Note, the Test field must be the first column of the input data. The default name of the test field is "test" and does not need to be specified. If the value attribute of the test field is not specified, it implies this same format, i.e., FieldSet, can used for different tests.


For regular field, it includes the following attributes:

{{{

class Field {
	//Field name
	private String name

        //Field type, default is String
        private String type = "String"

        //optional description of the Field
	private String description

	//If the value can be null, default is true
	private boolean nullable = true

	//optional null value if the value is null or not specified
	private String nullValue

	//If the length is not specified, it is -1
	private int length = -1

	//optional String pattern for the value
	//if specified, we must use it for String validation
	private String pattern
   } 

}}}

Tellurium can automatically handle Java primitive types. Another flexible Tellurium provides is that users can define their own custom type handlers to deal with more complicated data types by using "typeHandler", for example, 

{{{
        //define custom data type and its type handler
        typeHandler "phoneNumber", "org.tellurium.test.PhoneNumberTypeHandler"

        //define file data format
        fs.FieldSet(name: "fs4googlesearch", description: "example field set for google search") {
            Field(name: "regularSearch", type: "boolean", description: "whether we should use regular search or use I'm feeling lucky")
            Field(name: "phoneNumber", type: "phoneNumber", description: "Phone number")
            Field(name: "input", description: "input variable")
        }
}}}

The above script defined a custom type "PhoneNumber" and the Tellurium will automatically call this type handler to convert the input data to the "PhoneNumber" Java type.



