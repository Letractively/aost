#labels Phase-Deploy,Featured,Phase-Support
= Guide for the Reference Project =

== Introduction ==

We create reference projects to demonstrate how to use Tellurium for your own testing project. In the reference projects, we use Tellurium project web site as an example to illustrate how to write real-world Tellurium tests. The reference projects only use tellurium jar files and there are two sub-projects at the time of writing

  * tellurium-junit-java
  * tellurium-testng-java

Basically, the two sub-projects are the same and the only difference is that tellurium-junit-java uses JUnit 4 and tellurium-testng-java uses TestNG. Hence, here we only focus on the tellurium-junit-java project.

The tellurium-junit-java project illustrates the following usages of Tellurium:

  * How to create your own Tellurium testing project using tellurium jar files.
  * How to create your own UI Objects and wire them into Tellurium core
  * How to create UI module files in Groovy
  * How to create JUnit tellurium testing files in Java
  * How to create and run DSL scripts
  * How to create Tellurium Data Driven tests
  * How to configure Tellurium with the configuration file TelluriumConfig.groovy
  * Ant build script
  * Maven support
  * Support Eclipse, NetBeans, and IntelliJ IDEs

== Check out and Setup the reference project in IDEs ==

The tellurium-junit-java reference project is at SVN trunk and the URL is:

{{{
http://aost.googlecode.com/svn/trunk/reference-projects/tellurium-junit-java
}}}

We have already included all Eclipse, NetBeans, and IntelliJ project files in the project code base. What you need to do is just check out the code and twist a bit about the settings.

For detailed step-by-step directions, please see

  * [http://code.google.com/p/aost/wiki/TelluriumReferenceProjectEclipseSetup Eclipse Project Setup]
  * [http://code.google.com/p/aost/wiki/TelluriumReferenceProjectNetBeansSetup NetBeans Project Setup]
  * [http://code.google.com/p/aost/wiki/TelluriumReferenceProjectIntelliJSetup IntelliJ Project Setup]

== Code Structure ==

The code structure for the tellurium-junit-java project is shown as follows

{{{
src/main/groovy          ---------- source code for custom UI objects
               org/tellurium/object  ------------- customer UI objects
               org/tellurium/builder ------------- builders for UI objects

src/test/groovy          ---------- test source code
               org/tellurium/module  ------------- Tellurium UI module files
               org/tellurium/test    ------------- JUnit test cases
               org/tellurium/ddt     ------------- Tellurium Data Driven test cases

src/test/resources       ---------- test resource files
               org/tellurium/data    ------------- test data files
               org/tellurium/dsl     ------------- Tellurium DSL scripts

lib/           --------------- library directory holding tellurium jars and other required jar files

build.xml      --------------- ant build script
build.properties ------------- ant build properties

pom.xml        --------------- Maven POM file

TelluriumConfig.groovy ------- Tellurium configuration file

rundsl.sh      --------------- Unix/Linux script to run Tellurium DSL scripts
rundsl.bat     --------------- Windows script to run Tellurium DSL scripts

Others are project files for Eclipse, NetBeans, and IntelliJ
}}}

== Create Custom UI objects ==

Tellurium supports custom UI objects defined by users. For most UI objects, they must extend the "UiObject" class and then define actions or methods they support. For container type UI objects, i.e., which hold other UI objects, they should extends the Container class. Please see Tellurium Table and List objects for more details.

In the tellurium-junit-java project, we defined the custom UI object "SelectMenu" as follows:

{{{
class SelectMenu extends UiObject{   
    public static final String TAG = "div"

    String header = null

    //map to hold the alias name for the menu item in the format of "alias name" : "menu item"
    Map<String, String> aliasMap

    def click(Closure c){
        c(null)
    }

    def mouseOver(Closure c){
        c(null)
    }

    def mouseOut(Closure c){
        c(null)
    }

    public void addTitle(String header){
        this.header = header
    }
    
    public void addMenuItems(Map<String, String> menuItems){
        aliasMap = menuItems
    }
   
    ......

}
}}}

For each UI object, you must define the builder so that Tellurium knows how to construct the UI object when it parses the UI modules. For example, we define the builder for the "SelectMenu" object as follows:

{{{
class SelectMenuBuilder extends UiObjectBuilder{
    static final String ITEMS = "items"
    static final String TITLE = "title"

    public build(Map map, Closure c) {
        def df = [:]
        df.put(TAG, SelectMenu.TAG)
        SelectMenu menu = this.internBuild(new SelectMenu(), map, df)
        Map<String, String> items = map.get(ITEMS)
        if(items != null && items.size() > 0){
           menu.addMenuItems(items) 
        }
        
        menu.addTitle(map.get(TITLE))
        
        return menu
    }
}
}}}

You may wonder how to hook the custom objects into Tellurium core so that it can recognize the new type. The answer is simple, you just add the UI object name and its builder class name to Tellurium configuration file TelluriumConfig.groovy. Update the following section:

{{{
    uiobject{
        builder{
           SelectMenu="org.tellurium.builder.SelectMenuBuilder"
        }
    }
}}}

== Create UI modules ==

You should create UI modules in Groovy files, which should extend the DslContext class. In the defineUi method, define your UIs and then define all methods for them. Take the Tellurium Downloads page as an example:

{{{
class TelluriumDownloadsPage extends DslContext{

   public void defineUi() {

       //define UI module of a form include download type selector and download search
       ui.Form(uid: "downloadSearch", clocator: [action: "list", method: "get"], group: "true") {
           Selector(uid: "downloadType", clocator: [name: "can", id: "can"])
           TextBox(uid: "searchLabel", clocator: [tag: "span"])
           InputBox(uid: "searchBox", clocator: [name: "q"])
           SubmitButton(uid: "searchButton", clocator: [value: "Search"])
       }

       ui.Table(uid: "downloadResult", clocator: [id: "resultstable", class: "results"], group: "true"){
           //define table header
           //for the border column
           TextBox(uid: "header: 1", clocator: [:])
           UrlLink(uid: "header: 2", clocator: [text: "%%Filename"])
           UrlLink(uid: "header: 3", clocator: [text: "%%Summary + Labels"])
           UrlLink(uid: "header: 4", clocator: [text: "%%Uploaded"])
           UrlLink(uid: "header: 5", clocator: [text: "%%Size"])
           UrlLink(uid: "header: 6", clocator: [text: "%%DownloadCount"])
           UrlLink(uid: "header: 7", clocator: [text: "%%..."])

           //define table elements
           //for the border column
           TextBox(uid: "row: *, column: 1", clocator: [:])
           //the summary + labels column consists of a list of UrlLinks
           List(uid: "row:*, column: 3", clocator: [:]){
               UrlLink(uid: "all", clocator: [:])
           }
           //For the rest, just UrlLink
           UrlLink(uid: "all", clocator: [:])
       }
   }

    public String[] getAllDownloadTypes(){
        return  getSelectOptions("downloadSearch.downloadType")
    }

    public String getCurrentDownloadType(){
        return  getSelectedLabel("downloadSearch.downloadType");
    }

    public void selectDownloadType(String type){
        selectByLabel "downloadSearch.downloadType", type
    }

    public void searchDownload(String keyword){
        type "downloadSearch.searchBox", keyword
        click "downloadSearch.searchButton"
        waitForPageToLoad 30000
    }

    ......

}
}}}
 
== Create JUnit Test Cases ==

You can create JUnit Test Cases by extending the TelluriumJavaTestCase class. Nothing special, just like regular JUnit test cases. For instance,

{{{
public class TelluriumDownloadsPageJavaTestCase extends TelluriumJavaTestCase{
   private static TelluriumDownloadsPage downloadPage;

    public static String newline = System.getProperty("line.separator");
    private static Logger logger = Logger.getLogger(TelluriumDownloadsPageJavaTestCase.class.getName());

    @BeforeClass
    public static void initUi() {
        downloadPage = new TelluriumDownloadsPage();
        downloadPage.defineUi();
    }

    @Test
    public void testDownloadTypes(){
        connectUrl("http://code.google.com/p/aost/downloads/list");
        String[] allTypes = downloadPage.getAllDownloadTypes();
        assertNotNull(allTypes);
        assertTrue(allTypes[1].contains("All Downloads"));
        assertTrue(allTypes[2].contains("Featured Downloads"));
        assertTrue(allTypes[3].contains("Current Downloads"));
        assertTrue(allTypes[4].contains("Deprecated Downloads"));
    }

    @Test
    public void testSearchByText(){
        connectUrl("http://code.google.com/p/aost/downloads/list");
        // Set download type with other value
        downloadPage.selectDownloadType("Â All Downloads");
        downloadPage.searchDownload("tellurium-0.4.0");

        List<String> list = downloadPage.getDownloadFileNames();
        assertNotNull(list);
        assertFalse(list.isEmpty());
        assertTrue(Helper.include(list, "tellurium-0.4.0.tar.gz"));
    }

    ......

}
}}}

== Create and Run DSL scripts ==

In Tellurium, you can create test scripts in pure DSL. Take TelluriumPage.dsl as an example,

{{{
//define Tellurium project menu
ui.Container(uid: "menu", clocator: [tag: "table", id: "mt", trailer: "/tbody/tr/th"], group: "true"){
    //since the actual text is  Project&nbsp;Home, we can use partial match here. Note "%%" stands for partial match
    UrlLink(uid: "project_home", clocator: [text: "%%Home"])
    UrlLink(uid: "downloads", clocator: [text: "Downloads"])
    UrlLink(uid: "wiki", clocator: [text: "Wiki"])
    UrlLink(uid: "issues", clocator: [text: "Issues"])
    UrlLink(uid: "source", clocator: [text: "Source"])
}

//define the Tellurium project search module, which includes an input box, two search buttons
ui.Form(uid: "search", clocator: [:], group: "true"){
    InputBox(uid: "searchbox", clocator: [name: "q"])
    SubmitButton(uid: "search_project_button", clocator: [value: "Search Projects"])
    SubmitButton(uid: "search_web_button", clocator: [value: "Search the Web"])
}

openUrl "http://code.google.com/p/aost/"
click "menu.project_home"
waitForPageToLoad 30000
click "menu.downloads"
waitForPageToLoad 30000
click "menu.wiki"
waitForPageToLoad 30000
click "menu.issues"
waitForPageToLoad 30000

openUrl "http://code.google.com/p/aost/"
type "search.searchbox", "Tellurium Selenium groovy"
click "search.search_project_button"
waitForPageToLoad 30000

type "search.searchbox", "tellurium selenium dsl groovy"
click "search.search_web_button"
waitForPageToLoad 30000
}}}

To run the DSL script, you should first compile the code with ant script. In project root, run the following ant task

{{{
ant compile-test
}}}

Then, use the rundsl.sh to run the DSL script

{{{
./rundsl.sh src/test/resources/org/tellurium/dsl/TelluriumPage.dsl
}}}

For Windows, you should use the rundsl.bat script.

== Data Driven Testing ==
Data Driven Testing examples will be provided later on

== Tellurium Configuration ==

Tellurium uses the configuration file TelluriumConfig.groovy to configure itself. The configuration includes different sections for embedded selenium server, selenium connection, data driven testing, custom UI objects, and widgets.

{{{
tellurium{
    //embedded selenium server configuration
    embeddedserver {
        //port number
        port = "4445"
        //whether to use multiple windows
        useMultiWindows = false
        //whether to run the embedded selenium server. If false, you need to manually set up a selenium server
        runInternally = true
    }
    //the configuration for the connector that connects the selenium client to the selenium server
    connector{
        //selenium server host
        //please change the host if you run the Selenium server remotely
        serverHost = "localhost"
        //server port number the client needs to connect
        port = "4445"
        //base URL
        baseUrl = "http://localhost:8080"
        //Browser setting, valid options are
        //  *firefox [absolute path]
        //  *iexplore [absolute path]
        //  *chrome
        //   *iehta
        browser = "*chrome"
    }
    datadriven{
        dataprovider{
            //specify which data reader you like the data provider to use
            //the valid options include "PipeFileReader", "CVSFileReader" at this point
            reader = "PipeFileReader"
        }
    }
    test{
        result{
            //specify what result reporter used for the test result
            //valid options include "SimpleResultReporter", "XMLResultReporter", and "StreamXMLResultReporter"
            reporter = "XMLResultReporter"
            //the output of the result
            //valid options include "Console", "File" at this point
            //if the option is "File", you need to specify the file name, other wise it will use the default
            //file name "TestResults.output"
            output = "Console"
            //test result output file name
            filename = "TestResult.output"
        }
    }
    uiobject{
        builder{
        //user can specify custom UI objects here by define the builder for each UI object

           SelectMenu="org.tellurium.builder.SelectMenuBuilder"

        }
    }
    widget{
        module{
            //define your widget modules here, for example Dojo or ExtJs
            included=""
        }
    }
}

}}}

As a result, Tellurium is very flexible for users to customize. Note, if you want to use widgets, you should include the widget jar files in your class path.

== Build Scripts ==

The tellurium-junit-java project includes ant build script and Maven POM file so that you can run ant tasks from the command line, or use Maven to build the project.