#summary Interesting Algorithm Design Problems in Tellurium.
#labels Phase-Design,Phase-Support
<wiki:toc max_depth="5" />

= Introduction =

Algorithm is the spirit of computing. Tellurium is a web test automation framework and it brings up various interesting algorithm design problems. Here we like to list a few of them to shed light on Tellurium internal so that you can get some idea of what Tellurium really does and what it tries to achieve.

= Problems =

== UI Module Generating Algorithm in Trump ==

The [http://code.google.com/p/aost/wiki/UserGuide070TelluriumSubprojects#Tellurium_UI_Module_Plugin_(TrUMP) Tellurium UI module plugin] (Trump) is a Firefox plugin and it generates UI modules automated from a set of web elements that user clicks on.   

For example, we have the following HTML snippet,

{{{
<form method="POST" action="j_security_check">
    <table border="0" cellspacing="2" cellpadding="1">
        <tr>
            <td>Username:</td>
            <td><input size="12" value="" name="j_username" maxlength="25" type="text"></td>
        </tr>
        <tr>
            <td>Password:</td>
            <td><input size="12" value="" name="j_password" maxlength="25" type="password"></td>
        </tr>
        <tr>
            <td colspan="2" align="center">
                <input name="submit" type="submit" value="Login">
            </td>
        </tr>
    </table>
</form>
}}}

If we click and select the following web elements,

{{{
<form method="POST" action="j_security_check">
<td>Username:</td>
<td><input size="12" value="" name="j_username" maxlength="25" type="text"></td>
<td>Password:</td>
<td><input size="12" value="" name="j_password" maxlength="25" type="password"></td>
<input name="submit" type="submit" value="Login">
}}}

Trump generates the following UI module.

{{{
ui.Form(uid: "root", clocator: [action: "j_security_check"]){
	Container(uid: "T4t", clocator: [tag: "tr"]){
		TextBox(uid: "td0", clocator: [tag: "td", text: "Username:", direct: "true"])
		InputBox(uid: "input1", clocator: [tag: "input", direct: "true", type: "text", name: "j_username"])
	}
	Container(uid: "T4t2", clocator: [tag: "tr"]){
		TextBox(uid: "td2", clocator: [tag: "td", text: "Password:", direct: "true"])
		InputBox(uid: "input3", clocator: [tag: "input", direct: "true", type: "password", name: "j_password"])
	}
	SubmitButton(uid: "input4", clocator: [tag: "input", type: "submit", value: "Login", name: "submit"])
}
}}}

How the UI module is generated? Tellurium used a Prie-based [http://code.google.com/p/aost/wiki/UIModuleGeneratingAlgorithm UI module generating algorithm]. We are also working on a new algorithm to support multiple UI module generation and frames/iframes.

== Smart Name Suggestion in Trump ==

The names, i.e., the UID, trump suggested as shown in above section are ugly somehow. Can you design an algorithm that generates better names such as the following?

{{{
    ui.Form(uid: "Form", clocator: [tag: "form"]){
        Container(uid: "Username", clocator: [tag: "tr"]){
            TextBox(uid: "Label", clocator: [tag: "td", text: "Username:", direct: "true"])
            InputBox(uid: "Input", clocator: [tag: "input", type: "text", name: "j_username"])
        }
        Container(uid: "Password", clocator: [tag: "tr"]){
            TextBox(uid: "Label", clocator: [tag: "td", text: "Password:", direct: "true"])
            InputBox(uid: "Input", clocator: [tag: "input", type: "password", name: "j_password"])
        }
        SubmitButton(uid: "Submit", clocator: [tag: "input", type: "submit", value: "Login", name: "submit"])
    }
}}}

One naive method is to see if the web element comes with an ID or name attribute, if it does, then use the attribute as the name. But for a more practical algorithm, it should be able to suggest a good name based on the context and web element's attributes.

== UI Module Group Locating Algorithm ==

When Tellurium works as a wrap for Selenium, Tellurium Core generates runtime locators for UI modules and uses the locators to locate each individual elements just like what Selenium does. For example, we can dump the runtime locators for the UI module as shown in the previous section by calling

{{{
   dump("Form");
}}}

and the output is as follows.

{{{
-------------------------------------------------------
Form: jquery=form
Form.Password: jquery=form tr
Form.Password.Input: jquery=form tr input[type=password][name=j_password]
Form.Password.Label: jquery=form tr > td:te_text(Password:)
Form.Username: jquery=form tr
Form.Username.Input: jquery=form tr input[type=text][name=j_username]
Form.Username.Label: jquery=form tr > td:te_text(Username:)
Form.Submit: jquery=form input[type=submit][value=Login][name=submit]
-------------------------------------------------------
}}}

This is really not very efficient because for each UI element, we have to locate it for each call. What if we have the following test code:

{{{
  public void logon(String username, String password){
    keyType "Form.Username.Input", username
    keyType "Form.Password.Input", password
    click "Form.Submit"
    waitForPageToLoad 30000
  }
}}}

The keyType command simulates each key stroke including KeyUp, KeyDown, and KeyPress. As a result, we will have many calls for the input such as username or password. For example, if we call

{{{
  logon("test", "test");
}}}

we can see the command sequence in Tellurium Marco command as follows.

{{{
Command request: getBundleResponse[[{"uid":"Form.Username.Input","args":["jquery=form tr input[type=text][name=j_username]","e"],"name":"keyPress","sequ":9},{"uid":"Form.Username.Input","args":["jquery=form tr input[type=text][name=j_username]","e"],"name":"keyUp","sequ":10},{"uid":"Form.Username.Input","args":["jquery=form tr input[type=text][name=j_username]","s"],"name":"keyDown","sequ":11},{"uid":"Form.Username.Input","args":["jquery=form tr input[type=text][name=j_username]","s"],"name":"keyPress","sequ":12},{"uid":"Form.Username.Input","args":["jquery=form tr input[type=text][name=j_username]","s"],"name":"keyUp","sequ":13}], ] 

...
}}}

A more efficient and more elegant way is to locate the whole UI module in one shot and cache the UI mode. Then we can use the UI elements cached for all subsequent calls. This is exact what Tellurium new Engine mode does. We are used to locate a single UI element by its XPath or CSS selector, but how to locate all the UI elements defined in the UI module simultaneously?  



