<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
    <section>
        <title>Introduction</title>
        <para>Tellurium UID Description Language (UDL) is the Language to definite
            the UID field in Tellurium UI objects. In Tellurium, the UI object is referred to by its
            UID, i.e., the UI object identifier.
        </para>
        <para>For nested UI objects, the UID of the UI Object is a concatenated UI objects&apos; uids
            along its path to the UI Object.
        </para>
        <para>For example, in the following nested UI Module shown below, the TextBox is referred to as
            the<literal>&quot;parent_ui.child_ui.grand_child.textbox1&quot;</literal>.
        </para>
        <programlisting language="java">
<![CDATA[
ui.Container(uid: "parent_ui"){
  InputBox(uid: "inputbox1", locator: "...")
  Button(uid: "button1", locator: "...")
  Container(uid: "child_ui){
    Selector(uid: "selector1", locator: "...")
    ...
    Container(uid: "grand_child"){
      TextBox(uid: "textbox1", locator: "...")
      ...
    }
  }
}
]]>
        </programlisting>

        <para>The exceptions are tables and lists, which use
            <literal>[x][y]</literal>
            or
            <literal>[x]</literal>
            to reference the elements inside. For example,
            <literal>labels_table[2][1]</literal>
            and<literal>GoogleBooksList.subcategory[2]</literal>. The Table header can be referred in
            the format of<literal>issueResult.header[2]</literal>.
        </para>

        <para>More
            general cases are illustrated by the following UI module:
        </para>

        <programlisting language="java">
<![CDATA[
ui.Form(uid: "A", clocator: [:]){
  InputBox(uid: "B", clocator: [:])
  Container(uid: "C", clocator: [tag: "div"]){
     Selector(uid: "D", clocator: [:])
     List(uid: "E", clocator: [tag: "ul"], separator: "li"){
        UrlLink(uid: "{1} as Link", clocator: [:])
        InputBox(uid: "{all}", clocator: [:])
     }
  }
}
]]>
        </programlisting>

        <para>The UID name convention can be illustrated by the following graph.</para>

        <mediaobject>
            <imageobject>
                <imagedata fileref="./media/TelluriumUID.png" scalefit="1" width="100%"></imagedata>
            </imageobject>
        </mediaobject>

        <para>For example, the UID of the List
            <emphasis>E</emphasis>
            in the above diagram is
            <literal>A.C.E</literal>
            and the InputButton in the List
            <emphasis>E</emphasis>
            is referred by its index n. For example: A.C.En.
        </para>
        <para>As we said above, UID is used to identify and describe a UI object in Tellurium, but why do we
            need a language to describe the name of a UI object in Tellurium?
        </para>
        <para>The answer is that UID is not just the name of a UI object, it is also used to describe the
            dynamic factors in a<link
                    xlink:href="http://code.google.com/p/aost/wiki/UserGuide070TelluriumBasics#UI_Templates">
                Tellurium UI template</link>.
        </para>
        <para>Tellurium UI templates have two purposes:</para>
        <orderedlist>
            <listitem>
                <para>When there are many identical UI elements, use one template to represent them all.
                </para>
            </listitem>
            <listitem>
                <para>When there are variable/dynamic sizes of UI elements at runtime, the patterns are
                    known, but not the size.
                </para>
            </listitem>
        </orderedlist>
        <para>More specifically, Table, StandardTable, and List are the three Tellurium objects that
            define UI templates. The Table object is a special case of the StandardTable object.
        </para>
        <orderedlist>
            <listitem>
                <para>
                    <emphasis role="bold">Table</emphasis>
                    and
                    <emphasis role="bold">StandardTable</emphasis>
                    define two dimensional UI templates.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">List</emphasis>
                    defines one dimensional UI templates.
                </para>
            </listitem>
        </orderedlist>
        <para>As a result, the Tellurium UID Description Language (UDL) is designed to</para>
        <orderedlist>
            <listitem>
                <para>address the dynamic factors in Tellurium UI templates</para>
            </listitem>
            <listitem>
                <para>increase the flexibility of Tellurium UI templates.</para>
            </listitem>
        </orderedlist>
        <para>Tellurium UID Description Language (UDL) is implemented with<link
                xlink:href="http://www.antlr.org/">the Antlr 3 parser generator</link>. We will first cover
            the grammars of UDL and then the implementation details.
        </para>

    </section>

    <section>
        <title>Tellurium UID Description Language</title>
        <para>We like to introduce the UDL grammars and the use of UDL.</para>
        <section>
            <title>UDL Grammars</title>
            <para>The UDL grammars are defined as follows,
            </para>

         <programlisting language="java">
<![CDATA[
grammar Udl;

uid
        :       baseUid
        |       listUid
        |       tableUid
        ;

baseUid
        :       ID
        ;

listUid
        :       '{' INDEX '}'
        |       '{' INDEX '}' 'as' ID
        ;

tableUid
        :       tableHeaderUid
        |       tableFooterUid
        |       tableBodyUid
        ;

tableHeaderUid
        :       '{' 'header' ':' INDEX '}'
        |       '{' 'header' ':' INDEX '}' 'as' ID
        ;

tableFooterUid
        :       '{' 'footer' ':' INDEX '}'
        |       '{' 'footer' ':' INDEX '}' 'as' ID
        ;

tableBodyUid
        :       '{' 'row' ':' INDEX ',' 'column' ':' INDEX '}'
        |       '{' 'row' ':' INDEX ',' 'column' ':' INDEX '}' 'as' ID
        |       '{' 'row' '->' ID ',' 'column' ':' INDEX '}'
        |       '{' 'row' '->' ID ',' 'column' ':' INDEX '}' 'as' ID
        |       '{' 'row' ':' INDEX ',' 'column' '->' ID '}'
        |       '{' 'row' ':' INDEX ',' 'column' '->' ID '}' 'as' ID
        |       '{' 'row' '->' ID ',' 'column' '->' ID '}'
        |       '{' 'row' '->' ID ',' 'column' '->' ID '}' 'as' ID
        |       '{' 'tbody' ':' INDEX ',' 'row' ':' INDEX ',' 'column' ':' INDEX '}'
        |       '{' 'tbody' ':' INDEX ',' 'row' ':' INDEX ',' 'column' ':' INDEX '}' 'as' ID
        |       '{' 'tbody' ':' INDEX ',' 'row' '->' ID ',' 'column' ':' INDEX '}'
        |       '{' 'tbody' ':' INDEX ',' 'row' '->' ID ',' 'column' ':' INDEX '}' 'as' ID
        |       '{' 'tbody' ':' INDEX ',' 'row' ':' INDEX ',' 'column' '->' ID '}'
        |       '{' 'tbody' ':' INDEX ',' 'row' ':' INDEX ',' 'column' '->' ID '}' 'as' ID
        |       '{' 'tbody' ':' INDEX ',' 'row' '->' ID ',' 'column' '->' ID '}'
        |       '{' 'tbody' ':' INDEX ',' 'row' '->' ID ',' 'column' '->' ID '}' 'as' ID
        ;

fragment LETTER : ('a'..'z' | 'A'..'Z') ;
fragment DIGIT : '0'..'9';
INDEX   :       (DIGIT+ |'all' | 'odd' | 'even' | 'any' | 'first' | 'last' );
ID      :       LETTER (LETTER | DIGIT | '_')*;
WS      :       (' ' | '\t' | '\n' | '\r' | '\f')+ {$channel = HIDDEN;};
]]>
        </programlisting>

            <para>The grammars defined the UIDs for the following three categories of<link
                    xlink:href="http://code.google.com/p/aost/wiki/UserGuide070UIObjects">Tellurium UI
                Objects</link>.
            </para>
            <orderedlist>
                <listitem>
                    <para>Regular UI objects without UI templates such as
                        <link xlink:href="http://code.google.com/p/aost/wiki/UserGuide070UIObjects#Input_Box">
                            Input Box
                        </link>
                        and
                        <link xlink:href="http://code.google.com/p/aost/wiki/UserGuide070UIObjects#Container">
                            Container
                        </link>
                    </para>
                </listitem>
                <listitem>
                    <para>List type UI object, i.e.,
                        <link xlink:href="http://code.google.com/p/aost/wiki/UserGuide070UIObjects#List">List
                        </link>
                    </para>
                </listitem>
                <listitem>
                    <para>Table type UI objects including
                        <link xlink:href="http://code.google.com/p/aost/wiki/UserGuide070UIObjects#Table">Table
                        </link>
                        and<link
                                xlink:href="http://code.google.com/p/aost/wiki/UserGuide070UIObjects#Standard_Table">
                            StandardTable</link>.
                    </para>
                </listitem>
            </orderedlist>
            <para>We like to go over the grammars in details.</para>
            <section>
                <title>ID</title>
                <para>ID is the name of the UI object. The ID in the UDL starts with a letter and is followed by
                    digits, letters, and &quot;<literal>_</literal>&quot; as follows.
                </para>

                <mediaobject>
                    <imageobject>
                        <imagedata fileref="./media/udl_id.jpg" scalefit="1" width="100%"></imagedata>
                    </imageobject>
                </mediaobject>

                <section>
                    <title>Index</title>
                    <para>Index defines the position of the UI object. The index in the UDL can be any of the
                            following values:
                        </para>
                        <itemizedlist>
                            <listitem>
                                <para>Number, for example, &quot;5&quot;.
                                </para>
                            </listitem>
                            <listitem>
                                <para>&quot;first&quot;, the first element.
                                </para>
                            </listitem>
                            <listitem>
                                <para>&quot;last&quot;, the last element.
                                </para>
                            </listitem>
                            <listitem>
                                <para>&quot;any&quot;, any position, usually the position is dynamic at runtime.
                                </para>
                            </listitem>
                            <listitem>
                                <para>&quot;odd&quot;, the odd elements.
                                </para>
                            </listitem>
                            <listitem>
                                <para>&quot;even&quot;, the even elements
                                </para>
                            </listitem>
                            <listitem>
                                <para>&quot;all&quot;, wild match if not exact matches found.
                                </para>
                            </listitem>
                        </itemizedlist>

                 <mediaobject>
                    <imageobject>
                        <imagedata fileref="./media/udl_index.jpg" scalefit="1" width="100%"></imagedata>
                    </imageobject>
                </mediaobject>

                </section>

                <section>
                    <title>Regular UI Objects</title>
                    <para>For most
                        <link xlink:href="http://code.google.com/p/aost/wiki/UserGuide070UIObjects">Tellurium UI
                            objects
                        </link>
                        without UI templates, the UID is an ID, i.e., a name. They don&apos;t need any index
                        description since the name and the UI object is one to one mapping.
                    </para>

                 <mediaobject>
                    <imageobject>
                        <imagedata fileref="./media/udl_baseuid.jpg" scalefit="1" width="100%"></imagedata>
                    </imageobject>
                </mediaobject>

                    <para>For example, the UID of the container is &quot;GoogleSearchModule&quot; and &quot;Search&quot;
                        is the name of one SubmitButton in the previous Google search module.
                    </para>
                </section>
                <section>
                    <title>List</title>
                    <para>
                        <link xlink:href="http://code.google.com/p/aost/wiki/UserGuide070UIObjects#List">The List
                            object
                        </link>
                        defines an array of UI objects and its UID consists of an index and an optional name.
                    </para>

                 <mediaobject>
                    <imageobject>
                        <imagedata fileref="./media/udl_list.jpg" scalefit="1" width="100%"></imagedata>
                    </imageobject>
                </mediaobject>

                        <para>For example, the following List &quot;A&quot;, defines the following Ui Objects:</para>
                        <itemizedlist>
                            <listitem>
                                <para>InputBox, position at &quot;1&quot; and name &quot;Input&quot;.</para>
                            </listitem>
                            <listitem>
                                <para>Selector, position at &quot;2&quot; and name &quot;Select&quot;.</para>
                            </listitem>
                            <listitem>
                                <para>TextBox, represents the rest objects not at position &quot;1&quot; and &quot;2&quot;.</para>
                            </listitem>
                        </itemizedlist>

        <programlisting language="java">
<![CDATA[
ui.List(uid: "A", clocator: [tag: "table"], separator: "tr") {
   InputBox(uid: "{1} as Input", clocator: [:])
   Selector(uid: "{2} as Select", clocator: [:])
   TextBox(uid: "{all}", clocator: [tag: "div"])
}
]]>
        </programlisting>
                         <para>We can use
                            <literal>&quot;A[1]&quot;</literal>
                            or
                            <literal>&quot;A.Input&quot;</literal>
                            to reference the InputBox object.
                            <literal>&quot;A[3]&quot;</literal>
                            and
                            <literal>&quot;A[6]&quot;</literal>
                            are mapped to the TextBox object.
                        </para>
                </section>
                <section>
                    <title>Table</title>
                    <para>As we said, the
                        <link xlink:href="http://code.google.com/p/aost/wiki/UserGuide070UIObjects#Table">Table object
                        </link>
                        is a special case of the more general object<link
                                xlink:href="http://code.google.com/p/aost/wiki/UserGuide070UIObjects#Standard_Table">
                            StandardTable</link>, which includes a header, a footer, and one or multiple body
                        sections.
                    </para>
                    <para>
                        Table header is very much similar to the List, but its index starts with the &quot;header&quot;
                            indicator.
                    </para>

                  <mediaobject>
                    <imageobject>
                        <imagedata fileref="./media/udl_tableheader.jpg" scalefit="1" width="100%"></imagedata>
                    </imageobject>
                </mediaobject>

                    <para>The footer is similar to header and its index starts with the &quot;footer&quot; indicator.
                    </para>

                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="./media/udl_tablefooter.jpg" scalefit="1" width="100%"></imagedata>
                        </imageobject>
                    </mediaobject>

                    <para>The body is more complicated since it is represented by the triple<literal>[tbody, row,
                        column]</literal>.
                    </para>

                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="./media/udl_tablebody.jpg" scalefit="1" width="100%"></imagedata>
                        </imageobject>
                    </mediaobject>

                    <para>The tbody can be omitted if we have only one tbody. Thus, we can reduce the above subrules
                        to 8. The subrules look complicated, but they are not. Each row and column can be either an
                        index just like that in the List object or a reference to the ID of a header or a footer.
                        The reference is defined by the &quot;<literal>-&gt;</literal>&quot; symbol. In this way,
                        the row or column position can be dynamic and follow a header or a footer UI object.
                    </para>

                    <para>The Table grammars are better to be explained by an example. The issue search result UI in the
                        issue page of the Tellurium project can be described as follows.
                    </para>

         <programlisting language="java">
<![CDATA[
ui.Table(uid: "issueResult", clocator: [id: "resultstable", class: "results"],
    group: "true") {
  //Define the header elements
  UrlLink(uid: "{header: any} as ID", clocator: [text: "*ID"])
  UrlLink(uid: "{header: any} as Type", clocator: [text: "*Type"])
  UrlLink(uid: "{header: any} as Status", clocator: [text: "*Status"])
  UrlLink(uid: "{header: any} as Priority", clocator: [text: "*Priority"])
  UrlLink(uid: "{header: any} as Milestone", clocator: [text: "*Milestone"])
  UrlLink(uid: "{header: any} as Owner", clocator: [text: "*Owner"])
  UrlLink(uid: "{header: any} as Summary",
        clocator: [text: "*Summary + Labels"])
  UrlLink(uid: "{header: any} as Extra", clocator: [text: "*..."])

  //Define table body elements
  //Column "Extra" are TextBoxs
  TextBox(uid: "{row: all, column -> Extra}", clocator: [:])
  //For the rest, they are UrlLinks
  UrlLink(uid: "{row: all, column: all}", clocator: [:])
}
]]>
        </programlisting>
                    <para>The headers of the issue search results can be
                        dragged to different columns and thus, we use &quot;any&quot; to represent the dynamic
                        runtime index. Each header comes with a name so that the body could reference them.
                    </para>

                    <para>For the body, we have one TextBox for the &quot;Extra&quot;
                        column, i.e., the column where the header &quot;Extra&quot; is at, and all the others are
                        UrlLinks. As a result, we have the following references to the table UI objects:
                    </para>
                    <itemizedlist>
                        <listitem>
                            <para>
                                <literal>issueResult.header.ID</literal>
                                refers to the ID header
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <literal>issueResult[1][ID]</literal>
                                refers to the UI object in the first row and the same column as the header &quot;ID&quot;.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <literal>issueResult[3][Extra]</literal>
                                refers to the UI object in the third row and the same column as the &quot;Extra&quot;
                                header.
                            </para>
                        </listitem>
                    </itemizedlist>
                    
                </section>
                
            </section>
            <section>
                <title>Routing</title>
                <para>The routing mechanism maps the runtime UID reference to the appropriate UI template. We will
                    cover the routing mechanism for UI templates in the List and Table objects.
                </para>
                <section>
                    <title>RTree</title>
                    <para>For a List object, the index could be any of the following:
                    </para>
                    <itemizedlist>
                        <listitem>
                            <para>
                                <emphasis>digits</emphasis>, such as &quot;1&quot;, &quot;3&quot;, and &quot;5&quot;.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>first</emphasis>, which is converted to &quot;1&quot;.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>last</emphasis>, the last element.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>any</emphasis>, any position.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>odd</emphasis>, odd elements.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>even</emphasis>, even elements.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>all</emphasis>, match all and default UI element.
                            </para>
                        </listitem>
                    </itemizedlist>

                    <para>The routing tree for a List object is called a
                        <emphasis role="bold">RTree</emphasis>
                        as follows.
                    </para>
                    
        <mediaobject>
            <imageobject>
                <imagedata fileref="./media/udl_rtree.png" scalefit="1" width="60%"></imagedata>
            </imageobject>
        </mediaobject>

                    <para>The root is the &quot;all&quot; node and the digits, &quot;any&quot;,
                        and &quot;last&quot; are leaf nodes. &quot;odd&quot; and &quot;even&quot; nodes are parents
                        of the digit nodes. The routing algorithm always to match the runtime uid to one of the leaf
                        node, if not found, go up to match its parent node until it reaches the &quot;all&quot;
                        node, which presents a default UI object.
                    </para>
                    <para>
                        For example, we have the following List defined:
                    </para>

         <programlisting language="java">
<![CDATA[
ui.List(uid: "Example", clocator: [tag:"div"], separator: "p"){
  InputBox(uid: "{first} as Input", clocator: [:])
  Button(uid: "{odd}", clocator: [:])
  Selector(uid: "{4} as Select", clocator: [:])
  SubmitButton(uid: "{last} as Submit", clocator: [:])
  TextBox(uid: "{all}", clocator: [:])
}
]]>
        </programlisting>

                    <para>
                        By the RTree routing algorithm, the runtime uid mappings are shown as follows.
                    </para>

         <programlisting language="xml">
<![CDATA[
   //Runtime uid         mapped UI object

   //List Referenced by ID
   "Example.Input"  ---> InputBox
   "Example.Select" ---> Selector
   "Example.Submit" ---> SubmitButton

   //List Referenced by Index
   "Example[first]" ---> InputBox
   "Example[1]"     ---> InputBox
   "Example[2]"     ---> TextBox
   "Example[3]"     ---> Button
   "Example[4]"     ---> Selector
   "Example[last]"  ---> SubmitButton
]]>
        </programlisting>

                </section>

                <section>
                    <title>RGraph</title>
                    <para>The Table type of objects usually
                        include one header, one or multiple tbodies, and one footers. That is to say, the Table
                        object is represented by triple<literal>[tbody, row, column]</literal>. Each tuple is
                        represented by a RTree and the three RTrees form a RGraph. The reason it is called a graph
                        is that each tuple is not separated. If multiple nodes in the RGraph form a UI template, we
                        can draw a dash line to connect together. For example, the node &quot;4&quot; in tbody, the
                        &quot;even&quot; node in row, and the &quot;odd&quot; node in the column form a UI template
                        such as
                    </para>

        <programlisting language="java">
<![CDATA[
UrlLink(uid: "tbody: 4, row: even, column: odd", clocator: [:])
]]>
        </programlisting>

        <mediaobject>
            <imageobject>
                <imagedata fileref="./media/udl_rgraph.png" scalefit="1" width="100%"></imagedata>
            </imageobject>
        </mediaobject>

                    <para>In this way, the three RTrees actually form a graph. As a result, the
                        routing problem becomes &quot;how to find a UI template in the RGraph that is the closest
                        one to the runtime UID ?&quot;.
                    </para>
                    <para>To do this, we assign a fitness, i.e., weight, to tbody, row,
                        and column respectively. Usually, we select the weight as follows:
                    </para>
                    <screen>tbody &gt; row &gt; column
                    </screen>

                    <para>That is to say, we always try to match the tbody first, then the row and the column.
                    </para>

                    <para>The routing algorithm can be illustrated by the following code snippet.
                    </para>

         <programlisting language="java">
<![CDATA[
UiObject route(String key) {
//check the ID reference
UiObject object = this.indices.get(key);

//this is a index reference
if(object == null){
  //normalize the index
  String[] parts= key.replaceFirst('_', '').split('_');
  String[] ids = parts;
  if(parts.length < 3){
    ids = ["1", parts].flatten();
  }
  String x = ids[0];
  if("first".equalsIgnoreCase(x)){
    x = "1";
  }
  String y = ids[1];
  if("first".equalsIgnoreCase(y)){
    y = "1";
  }
  String z = ids[2];
  if("first".equalsIgnoreCase(z)){
    z = "1";
  }

  //Find match nodes separately for tbody, row, and column
  String[] list = this.generatePath(x);
  Path path = new Path(list);
  RNode nx = this.walkTo(this.t, x, path);
  list = this.generatePath(y);
  path = new Path(list);
  RNode ny = this.walkTo(this.r, y, path);
  list = this.generatePath(z);
  path = new Path(list);
  RNode nz = this.walkTo(this.c, z, path);

  //Use the fitness to select the closest match
  int smallestFitness = 100 * 4;
  RNode xp = nx;
  while (xp != null) {
    RNode yp = ny;
    while (yp != null) {
      RNode zp = nz;
      while(zp != null){
        //internal representation of the index
        String iid = this.getInternalId(xp.getKey(), yp.getKey(), zp.getKey());
        //If they form a UI template
        if(xp.templates.contains(iid) && yp.templates.contains(iid)
           && zp.templates.contains(iid)){
          int fitness = (nx.getLevel() - xp.getLevel()) * 100 +
              (ny.getLevel() - yp.getLevel()) * 10 +
              (nz.getLevel() - zp.getLevel());
          if(fitness < smallestFitness){
            object = this.templates.get(iid);
            smallestFitness = fitness;
          }
        }
        //walk up the RGraph
        zp = zp.parent;
      }
      //walk up the RGraph
      yp = yp.parent;
     }
    //walk up the RGraph
    xp = xp.parent;
  }
}

//return the closest match
return object;
}
]]>
        </programlisting>

                    <para>Take the previous
                        <link xlink:href="http://code.google.com/p/aost/wiki/TelluriumUIDDescriptionLanguage#Example">
                            Tellurium Issue Result UI module
                        </link>
                        as an example, we have the following runtime UID to UI object mapping.
                    </para>
                    <screen>   
                         //Runtime UID               mapped UI object
                           &quot;issueResult[1][Extra]&quot;--&gt;TextBox
                           &quot;issueResult[1][ID]     --&gt; UrlLink
                           &quot;issueResult[2[[Type]   --&gt;UrlLink
                    </screen>
                    <para>Be aware that the &quot;Extra&quot;, &quot;ID&quot;, and &quot;Type&quot; are index
                        references to the header columns of the header &quot;Extra&quot;, &quot;ID&quot;, and &quot;Type&quot;
                        respectively and they will be replaced by the actual column number of the corresponding
                        header at runtime.
                    </para>

                </section>
            </section>

        </section>
    </section>

</section>