#summary Tellurium: A New Approach for Web Testing.
#labels Phase-Implementation,Phase-Support
<wiki:toc max_depth="5" />

= Introduction =

== Challenges and Problems ==

Automated web testing has always been one of the most important and hot topics in software testing arena with web becoming one indispensable part of most people's lives. Web techniques keep moving forward and more and more dynamic web techniques are adopted by web developers. For example, Ajax is one of the most important ones. 

With the advent of new web techniques, automated web testing tools must keep up with the improvement and be able to address the following challenges imposed by the automated web testing nature and new web techniques:

  * *Javascript Events*: Javascript events are the foundation of all Javascript frameworks and are everywhere in today's web. The automated testing framework should be able to trigger the events in a very convenient way.
  * *Ajax for Dynamic Web Content*: Ajax is a convenient way to update the part of the web page without refresh the whole page. The web context for an Ajax application is usually dynamic. For example, in a data grid, the number of rows and data keep changing at runtime. 
  * *Robust to Changes*: A good automated web testing tool should be able to address the changes in the web context to some degree so that users do not need to keep updating the test code.
  * *Easy to Maintain*: In an agile world, the software are developed in multiple scrums with new features added on in each scrum. The functional tests or user acceptance tests must be refactored and updated for new features. The testing framework should provide the flexibility for users to maintain the test code very easily.
  * *Re-usability*: Many web applications use the same UI module for different part of the application. The adoption of Javascript frameworks such as Dojo and ExtJS increases the chance to use the same UI module for difference applications. A good testing framework should also be able to provide re-usability of test modules.
  * *Expressiveness*: The testing framework should be able to provide the users without too much coding experience to write test code/scripts easily in a way that they are familiar with, for example, use a domain specific language (DSL).

== Existing Open source Automated Web Testing Frameworks ==

The Selenium framework is the most popular open source automated web testing framework and it was a ground-breaking framework and it offered many unique features such as browser based testing, Selenium Grid, and "record and replay" testing mode using Selenium IDE. As a pioneer framework, it inevitably comes with some shortcomings. One important one is that it focuses on individual UI elements such as links and buttons, as a result, it is to address dynamic web content in Selenium. The "record and replay" testing mode does make it much easier for users, especially non-developers, to create a test case, however, it also suffers drawbacks such as difficult to refactor and maintain. Other downsides include the coupling of UI elements and test code, verbose, and fragile to changes. 

Take the following Selenium test code as an example,

{{{
   setUp("http://www.google.com/", "*chrome");
   selenium.open("/");
   selenium.click("//input[@value='Google Search' and @type='button']");
   selenium.type("q", "Selenium test");
}}}

Do you know clearly what UI module is under testing? What does the locator “q" mean here? And what if the XPath "//input[@value='Google Search' and @type='button']" becomes invalid due to changes on the web? As a result, the Selenium test code is easy to create using Selenium IDE, but hard to generalize and refactor, which proved to be as tedious and painful as to re-generate a new test code from scratch because of the hard-coded locators and the coupling of locator with test code. Maintenance was a headache as well because the test code was not structured. Due to the nature of testing individual UI elements, Selenium is also difficult to address dynamic web context. 

Canoo WebTest is another popular open source tool for automated testing of web applications. But it also focuses on individual UI elements and thus it suffers many similar shortcomings as Selenium, for example, test code couple with UI. Here is a sample test code,

{{{

    webtest("check that WebTest is Google's top 'WebTest' result"){
       invoke "http://www.google.com", description: "Go to Google"
       verifyTitle "Google"
       setInputField name: "q", value: "WebTest"
       clickButton "I'm Feeling Lucky"
       verifyTitle "Canoo WebTest"
    }
}}}

Twill is a simple scripting language that allows users to browse the Web from a command-line interface and it uses link, forms, cookies, and most standard Web features. It also deals with individual UI elements, need to parsing html interactively, and only support Python, which make Twill not really convenient to test practical web applications. Here is a sample Twill test code

{{{
setlocal query "twill Python"
go http://www.google.com/
fv 1 q $query
submit btnI # use the "I'm feeling lucky" button
show
}}}

== Motivations ==

Since the existing automated testing frameworks cannot address the challenges and problems very well. We really need a new automated testing framework to address them with the following motivations:

  * Robust to changes and allow changes to be localized
  * Address dynamic web context such as JavaScript events and Ajax 
  * Easy to refactor and maintain
  * Modular and test modules are reusable 
  * Expressive and easy to use

Our answer is the Tellurium Automated Testing Framework (Tellurium). In the next sections, we will first give a brief introduction of Tellurium and how it addresses the challenges and problems in web testing, then go over more details about Tellurium including its architecture, new concepts, and how to obtain and use Tellurium followed by detailed tutorials with code samples. Finally, we end this article with future directions.

= A New Approach for Web Testing =

== Why Tellurium is a New Approach for Web Testing ==
 
The Tellurium Automated Testing Framework (Tellurium) is an open source automated testing framework for web applications to address the challenges and problems in web testing. 

Most existing web testing tools/frameworks focus on individual UI elements such as links and buttons. Tellurium takes a new approach for automated web testing using the UI module.  The UI module is a collection of UI elements grouped together. Usually, the UI module represents a composite UI object in the format of nested basic UI elements. For example, the Google search UI module can be expressed as follows,

{{{
ui.Container(uid: "GoogleSearchModule", clocator: [tag: "td"], group: "true"){
   InputBox(uid: "Input", clocator: [title: "Google Search"])
   SubmitButton(uid: "Search", clocator: [name: "btnG", value: "Google Search"])
   SubmitButton(uid: "ImFeelingLucky", clocator: [value: "I'm Feeling Lucky"])
}
}}}
 
Tellurium is built on the foundation of the UI module.  The UI module makes it possible to build locators for UI elements at runtime.  First, this makes Tellurium robust and responsive to changes from internal UI elements.  Second, the UI module makes Tellurium expressive.  A UI element can be referred to simply by appending the names (uid) along the path to the specific element. This also enables Tellurium's "Group Locating" feature, making composite objects reusable, and addressing dynamic web pages.

Tellurium is implemented in Groovy and Java.  The test cases can be written in Java, Groovy, or pure "Domain Specific Language (DSL)" scripts.  Tellurium evolved out of Selenium, but the UI testing approach is completely different. For example, Tellurium is not a "record and replay" style framework, and it enforces the separation of UI modules from test code, making refactoring easy. For example, once you defined the Google Search UI module shown above, you can write your test code as follows,

{{{
type "GoogleSearchModule.Input", "Tellurium test"
click "GoogleSearchModule.Search"
}}} 

Tellurium does "Object to Locator Mapping (OLM)" automatically at run time so that UI objects can be defined simply by their attributes using "Composite Locators." Tellurium uses the "Group Locating Concept (GLC)" to exploit information inside a collection of UI components so that locators can find their elements.  It also defines a set of DSLs for web testing.  Furthermore, Tellurium uses UI templates to define sets of dynamic UI elements at runtime.  As a result, Tellurium is robust, expressive, flexible, reusable, and easy to maintain. 
    
The main features of Tellurium include:

  * Abstract UI objects to encapsulate web UI elements
  * DSL for UI definition, actions, and testing
  * Composite Locator to use a set of attributes to describe a UI element
  * Group locating to exploit information inside a collection of UI components
  * Dynamically generate runtime locators to localize changes
  * UI module for structured test code and re-usability
  * UI templates for dynamic web content
  * XPath support
  * jQuery selector support to improve test speed in IE
  * Locator caching to improve speed
  * Javascript event support
  * Use Tellurium Firefox plugin, Trump, to automatically generate UI modules
  * Dojo and ExtJS widget extensions    
  * Data driven test support 
  * Selenium Grid support
  * JUnit and TestNG support
  * Ant and Maven support

== How Challenges and Problems are addressed in Tellurium ? ==
 
Back to the challenges and problems, how are they addressed in Tellurium? First of all, Tellurium does not use the "record and replay" style. Instead, it uses Tellurium Firefox plugin Trump to generate the UI module, not the test code for you. Then you need to create your test code based on the UI module. In this way, the UI and the test code are decoupled. The structured test code in Tellurium make it much easier to refactor and maintain the code.

The composite locator uses UI element attributes to define UI and the actual locator, i.e., xpath or jQuery selector, will be generated at runtime. Any updates to the composite locator will lead to different runtime locators and the changes inside the UI module are localized. The Group locating is used to remove the dependency of the UI objects from external UI elements, i.e., external UI changes will not affect the current UI module for most cases so that your test code is robust to changes up to certain level.

Tellurium use the “respond” attribute in UI object for you to specify JavaScript events and the rest will be handled automatically by the framework itself. UI templates is a powerful feature in Tellurium to represent many identical UI elements or dynamic size of different UI elements at runtime, which are extremely useful to test dynamic web context such as a data grid. The “Option” UI object is designed to automatically address dynamic web with multiple possible UI patterns.

The re-usability is achieved by UI module for the same application and Tellurium Widgets for different web applications. With the Domain Specific Language (DSL) in Tellurium, you can define UI module and write test code in a very expressive way. Tellurium also provides you the flexibility to write test code in Java, Groovy, or pure DSL scripts.

== Tellurium Architecture ==

he Tellurium framework Architecture is shown as in Figure 1.

http://tellurium-users.googlegroups.com/web/tellurium.architecture.png?gda=1NP4x0sAAAAFkHkURP2WlgYU-UhtQDFJganRixm7ZVzXjIzQXs5CXWG1qiJ7UbTIup-M2XPURDThcsDHHqasJHRvnmR6jbzWzHqwysTvAgdPZHbdH4XvXg&gsc=26Y4eBYAAAAkGgIQNXlg3kIha08SEZtI9pmI1qD38G08ONb6YfjJaQ

Figure 1. Tellurium Architecture.

The system diagram of Tellurium consists of three parts, one is the Selenium Server, on which our Tellurium framework builds, the Tellurium framework, and user defined Java test cases or .dsl pure DSL test scripts. 

The Tellurium Framework is based on the DslContext, which defines all DSLs we can use for Tellurium. We can further divide the Tellurium Framework into Four parts.

=== UI Object Parser ===

This parts consists of the DSL Object Parser, Object Builders, and the Object Registry.

Thanks to Groovy’s builder pattern, we can define UI object expressively and in a nested fashion. The DSL object parser will parse the DSL object definition recursively and use object builders to build the objects on the fly. An object builder registry is designed to hold all predefined UI object builders in the Tellurium framework and the DSL object parser will look at the builder registry to find the appropriate builders. Since the registry is a hash map, you can override a builder with a new one using the same UI name. Users can also add their customer builders into the builder registry.
 
The DSL object definition always comes first with a container type object. An object registry (A hash map) is used to stored all top level UI Objects. As a result, for each DSL object definition, the top object ids must be unique in the DslContext. The object registry will be used by the framework to search objects by their ids and fetch objects for different actions.

=== Object Locator Mapping ===

The Object Locator Mapping (OLM) is the core of the Tellurium framework and it includes UI ID mapping, XPath builder, Locator Processor, and Group Locating. The UI ID supports nested object, for example, "menu.wiki" stands for a URL Link "wiki" inside a container called "menu". The UI ID also supports one dimension and two dimension index for table and list. For example, {{{"main.table[2][3]"}}} stands the UI object of the 2nd row and the 3rd column of a table inside the container "main".

XPath builder can build the XPath from relative XPaths or from attributes. The locator processor converts the locator information in the UI object to the XPath. The Group Locating Concept (GLC) is to exploit the group information in side a collection of UI objects to help us find the locator of the collection of UI objects. 

=== Event and Data Handling ===

The Eventhandler in this part will handle all events like "click", "type", "select", and so on. The Data Accessor is used to fetch data or UI status from the DOM. The dispatcher will delegate all calls it receives from the Eventhandler and the data accessor to the Selenium Client, which will connect to the Selenium Server. The dispatcher is designed to decouple the rest of the Tellurium framework with the Selenium framework so that we can simply change the dispatcher logic to delegate all calls to other underneath UI test frameworks if we want to switch Tellurium not to use the Selenium framework someday.

== Tellurium Subprojects ==

Tellurium began as a small core project over a year ago and quickly spawned multiple sub-projects including: [http://code.google.com/p/aost/wiki/UserGuide Core], [http://code.google.com/p/aost/wiki/ReferenceProjectGuide Reference projects], [http://code.google.com/p/aost/wiki/TelluriumWidget Widget extensions], [http://code.google.com/p/aost/wiki/TrUMP TrUMP], and Engine projects as shown in the following diagram,

http://tellurium-users.googlegroups.com/web/TelluriumProjects.png?gsc=8WCcfRYAAABueqEHekK8LxR3X1leEByKg-kXU5InE09W2o0GCSVgCQ

   * Tellurium Core: UI module, APIs, DSL, Object to Runtime Locator mapping, and test support.
  * Tellurium Engine: Based on Selenium Core with UI module, jQuery selector, command bundle, and exception hierarchy support.
  * Tellurium Extensions: Dojo Javascript widgets and ExtJS Javascript widgets.
  * Tellurium UI Module Plugin (TrUMP): A Firefox plugin to automatically generate the UI module after users select the UI elements from the web under testing.
  * Tellurium Maven Archetypes: Maven archetypes to generate skeleton Tellurium JUnit and Tellurium TestNG projects using one Maven command.
  * Tellurium Reference Projects: Use Tellurium project site as examples to illustrate how to use different features in Tellurium and how to create Tellurium test cases.

== Tellurium Community ==

Tellurium cannot reach today's stage without our users' support. Our users' comments and suggestions have shaped the Tellurium framework in many different ways and various aspects. 

Tellurium is attracting more and more contributors and users. We have over 15,000 pageviews of our project website each month, and the number keeps growing.  With many new contributors joining our project from different parts of the world, we expect Tellurium will grow even more rapidly. 

= Tellurium Concepts =

= How to Obtain and Use Tellurium =

== Create a Tellurium Project ==

here are three ways, i.e., use [http://code.google.com/p/aost/wiki/ReferenceProjectGuide the reference project] as a base, use [http://code.google.com/p/aost/wiki/TelluriumMavenArchetypes Tellurium Maven archetype], or manually create Tellurium project using [http://code.google.com/p/aost/downloads/list tellurium jar] and [http://code.google.com/p/aost/wiki/TelluriumSampleConfigurationFile  Tellurium configuration file]. Alternatively, you could create your own Tellurium Maven project manually using [http://code.google.com/p/aost/wiki/TelluriumTestProjectMavenSamplePom the sample POM file].

Teasiest way to create a Tellurium project is to use Tellurium Maven archetypes. Tellurium provides two Maven archetype, i.e., tellurium-junit-archetype and tellurium-testng-archetype for Tellurium JUnit test project and Tellurium TestNG test project, respectively. As a result, you can create a Tellurium project using one Maven command. For a Tellurium JUnit project, use 

mvn archetype:create -DgroupId=your_group_id -DartifactId=your_artifact_id -DarchetypeArtifactId=tellurium-junit-archetype -DarchetypeGroupId=tellurium -DarchetypeVersion=0.7.0-SNAPSHOT -DarchetypeRepository=http://kungfuters.org/nexus/content/repositories/snapshots

and for a Tellurium TestNG project, use

mvn archetype:create -DgroupId=your_group_id -DartifactId=your_artifact_id -DarchetypeArtifactId=tellurium-testng-archetype -DarchetypeGroupId=tellurium -DarchetypeVersion=0.7.0-SNAPSHOT -DarchetypeRepository=http://kungfuters.org/nexus/content/repositories/snapshots

== Create UI Module ==

= Future Directions =

Tellurium will continue evolving and we will focus on the following tasks,

  * Develop the Engine project in 0.7.0 to provide better support for UI module and achieve better re-usability, speed performance, and robust to changes. 
  * Tellurium widget will be re-architected to encapsulate dynamic factors and to make it easier to define and use Tellurium widgets. 
  * The widget extension projects will be implemented to include many widgets from Javascript frameworks such as Dojo and ExtJS so that users can include these widgets in their UI modules simply by their names without the need to know the details of the internal UI elements. 
  * TrUMP will be improved to support frames, pop-up widows, and UI templates. Another big move will be to automatically create UI modules as well as DSL test scripts for non-developers. 
  * To better support functional tests, we will introduce a "stage and test binding" concept to make functional tests easier to write and configure. 
  * Headless web testing using HtmlUnit could be another interesting topic. 
  * Other initiatives include behavior driven test support, IDE plugins, XHTML support, integration with other testing framework like Fitnesse, and porting to other languages.

= Acknowledgments =

= Resources =

  * [http://code.google.com/p/aost/ Tellurium Project website] 
  * [http://groups.google.com/group/tellurium-users Tellurium User Group]
  * [http://seleniumhq.org/ Selenium]
  * [http://webtest.canoo.com Canoo WebTest]
  * [http://twill.idyll.org/ Twill]  
  * [http://groovy.codehaus.org/ Groovy]
  * [http://jquery.com/ JQuery]
  * [http://www.junit.org/ JUnit] 
  * [http://testng.org/doc/documentation-main.html TestNG]
  * [http://htmlunit.sourceforge.net HtmlUnit]