#summary How to Generate Html Source from UI Modules.
#labels Phase-Support,Phase-Implementation
<wiki:toc max_depth="5" />

== Prerequisites ==
 
  * Tellurium Core 0.7.0-SNAPSHOT

= Motivation =

Very often, some Tellurium users asked us to help them to track problems in their Tellurium test code. Due to some company policy, they cannot provide us the HTML source directly, but the UI module instead. Without the HTML source, there is no way for us to debug their test code because we do not have access to their web applications.

However, if we can do reverse engineering to generate the HTML source from the given UI module, we can use the [http://code.google.com/p/aost/wiki/TelluriumMockHttpServer mock http server] to test the generated HTML Source without the need to access their web applications. 

Driven by this motivation, we provided the following new method in {{{DslContext}}} for users to generate HTML source from UI modules:

{{{
  public String generateHtml(String uid)
}}}

= Implementation =

The key is to generate the HTML source for each individual UI object from the composite locator, denoted by {{{clocator}}}. As a result, we added two methods to the {{{CompositeLocator}}} class:

{{{
class CompositeLocator {
    String header
    String tag
    String text
    String trailer
    Map<String, String> attributes = [:]

    public String generateHtml(boolean closeTag){ 
      ......
    }

    public String generateCloseTag(){
      ......
    }
}}}

where {{{generateHtml(boolean closeTag)}}} returns the generated HTML source from the composite locator and the boolean variable _closeTag_ indicates whether to generate the closing tag for the HTML source. For Container type UI objects, most likely, you will not generate the closing tag directly, but use the other method {{{generateCloseTag()}}} to generate the closing tag separately so that we can include its child elements in between.

Then on the base class UiObject, we add the {{{generateHtml()}}} method as follows,

{{{
abstract class UiObject implements Cloneable{
    String uid
    String namespace = null
  
    def locator

    //reference back to its parent
    def Container parent

    public String generateHtml(){
      if(this.locator != null){
        return getIndent() + this.locator.generateHtml(true) + "\n";
      }
      
      return "\n";
    }

    public String getIndent(){
      if(parent != null){
          return parent.getIndent() + "    ";
      }else{
        return "";
      }
    }
}
}}}

To make pretty print, we add a {{{getIndent()}}} method in the UiObject to get the indentation for the current UI object. 

Once we added the {{{generateHtml()}}} method, all the concrete UI objects such as Button, InputBox, and UrlLink inherit this method to generate HTML source. However, for a Contain type, the implementation is different because we need to include its child UI objects in the HTML source. As a result, we overwrite the {{{generateHtml()}}} method in the UiObject.

{{{
class Container extends UiObject {
    def components = [:]

    @Override
    public String generateHtml(){
      StringBuffer sb = new StringBuffer(64);
      String indent = getIndent();

      if(this.components.size() > 0){
        if(this.locator != null)
          sb.append(indent + this.locator.generateHtml(false)).append("\n");
        this.components.each {String uid, UiObject obj ->
          sb.append(obj.generateHtml());
        }
        if(this.locator != null)
          sb.append(indent + this.locator.generateCloseTag()).append("\n");
      }else{
        if(this.locator != null){
          sb.append(this.locator.generateHtml(true)).append("\n")
        }
      }

      return sb.toString();
    }
}
}}}

UI templates in Tellurium objects such as List and Table make things more complicated. The basic idea is to elaborate all UI templates and key is to get the appropriate List size and Table size. We use an algorithm to determine the sizes and we don't want to go over the details here. 

= Usage =

 