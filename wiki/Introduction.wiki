#labels Featured,Phase-Design
= Introduction =

*Tellurium Automated Testing Framework* (_Tellurium_) framework
  * Written in *Groovy*, test cases can be written in *Java* or *Groovy* 
  * Include a *Domain Specific Language* (_DSL_) to define UI objects 
  * Can also use the _DSL_ to describe events, actions, or assertions 
  * include an *Object to Locator Mapping framework* (_OLM_)
  * Tellurium can automatically generate the UI object locator for you
  * Tellurium implements the *group locating* concept to utilize a group of UI objects to help locating their locators
  * Make it possible for users to write Selenium tests when they start coding
  * Reusable, easier to refactor and maintain
  * Provide _DSL_ script executor so that non-developers can write Selenium tests in DSL
  * Provide *Data Driven Testing* feature for Tellurium tests. You can specify input data format and define different tests. Then use input data to drive the testing. The test result can be output as an XML file.

== Architecture ==

The Tellurium framework Architecture is shown as in Figure 1.

http://tellurium-users.googlegroups.com/web/tellurium.architecture.png?gda=1NP4x0sAAAAFkHkURP2WlgYU-UhtQDFJganRixm7ZVzXjIzQXs5CXWG1qiJ7UbTIup-M2XPURDThcsDHHqasJHRvnmR6jbzWzHqwysTvAgdPZHbdH4XvXg&gsc=26Y4eBYAAAAkGgIQNXlg3kIha08SEZtI9pmI1qD38G08ONb6YfjJaQ

Figure 1. Tellurium Architecture.

The system diagram of Tellurium consists of three parts, one is the Selenium Server, on which our Tellurium framework builds, the Tellurium framework, and user defined Java test cases or .dsl pure DSL test scripts. 

The Tellurium Framework is based on the DslContext, which defines all DSLs we can use for Tellurium. We can further divide the Tellurium Framework into Four parts.

=== UI Object Parser ===

This parts consists of the DSL Object Parser, Object Builders, and the Object Registry.

Thanks to Groovy’s builder pattern, we can define UI object expressively and in a nested fashion. The DSL object parser will parse the DSL object definition recursively and use object builders to build the objects on the fly. An object builder registry is designed to hold all predefined UI object builders in the Tellurium framework and the DSL object parser will look at the builder registry to find the appropriate builders. Since the registry is a hash map, you can override a builder with a new one using the same UI name. Users can also add their customer builders into the builder registry.
 
The DSL object definition always comes first with a container type object. An object registry (A hash map) is used to stored all top level UI Objects. As a result, for each DSL object definition, the top object ids must be unique in the DslContext. The object registry will be used by the framework to search objects by their ids and fetch objects for different actions.

=== Object Locator Mapping ===

The Object Locator Mapping (OLM) is the core of the Tellurium framework and it includes UI ID mapping, XPath builder, Locator Processor, and Group Locating. The UI ID supports nested object, for example, "menu.wiki" stands for a URL Link "wiki" inside a container called "menu". The UI ID also supports one dimension and two dimension index for table and list. For example, {{{"main.table[2][3]"}}} stands the UI object of the 2nd row and the 3rd column of a table inside the container "main".

XPath builder can build the XPath from relative XPaths or from attributes. The locator processor converts the locator information in the UI object to the XPath. The Group Locating Concept (GLC) is to exploit the group information in side a collection of UI objects to help us find the locator of the collection of UI objects. 

=== Event and Data Handling ===

The Eventhandler in this part will handle all events like "click", "type", "select", and so on. The Data Accessor is used to fetch data or UI status from the DOM. The dispatcher will delegate all calls it receives from the Eventhandler and the data accessor to the Selenium Client, which will connect to the Selenium Server. The dispatcher is designed to decouple the rest of the Tellurium framework with the Selenium framework so that we can simply change the dispatcher logic to delegate all calls to other underneath UI test frameworks if we want to switch Tellurium not to use the Selenium framework someday.  

== HOW Tellurium works ==

Basically, there are two parts for the Tellurium framework. The first part is to define UI objects and the second part is working on the UI objects like firing events and getting data or status from the DOM.

=== The "Define UI" Operation ===

The "Define UI" operation can be demonstrated in the following sequence diagram:

http://tellurium-users.googlegroups.com/web/aost_sequence_defineui.png?gda=ut9Dd0sAAAAFkHkURP2WlgYU-UhtQDFJfFjOBE5aGMxp_hs9PNxhIGG1qiJ7UbTIup-M2XPURDRalx4T6cOZyoocLzTpPNoT-xRs6kTo9_1MlJqhLlX0VQ&gsc=26Y4eBYAAAAkGgIQNXlg3kIha08SEZtI9pmI1qD38G08ONb6YfjJaQ

Figure 2. The sequence diagram for "DefineUI"

When the Test Case calls "DefineUI", the DslContext will call the Dsl Object Parser to parse the UI definition. The Parser will look at each node and call the appropriate builders to build UI objects. The top level object will be stored in the UI Object registry so that we can search for the UI object by UI Id.
 

Note that the processing of the pure DSL script is the same.
 
=== The Action Operation ===

The processing of actions such as clicking on an UI object is illustrated in Figure 3:

http://tellurium-users.googlegroups.com/web/aost_sequence_click.png?gda=EuRP9kgAAAAFkHkURP2WlgYU-UhtQDFJfFjOBE5aGMxp_hs9PNxhIGG1qiJ7UbTIup-M2XPURDSpnGSpq9shp5Nom0pUQ_VQjwc8kMSHiCJV0Te5P6rKfA&gsc=26Y4eBYAAAAkGgIQNXlg3kIha08SEZtI9pmI1qD38G08ONb6YfjJaQ

Figure 3. The sequence diagram for the "click" action

The action processing includes following two parts. 

==== Search For the UI Object ===
First, the DslContext will create a WorkflowContext so that we can pass meta data such the relative xpath inside it. Then, we start to look at the UI object registry by calling the walkTo method. Remember, the UI object registry hold all the top level UI objects. If we can find the top level UI object, we can recursively call the WalkTo method on the next UI object until we find the UI Object matching the UI id, or we cannot find the UI object by UI Id. 

During the walkTo method calls, we also start to aggregate relative xpaths into the reference xpath to the next UI object.

==== Construct the Locator and Fire the Event ====

If the UI Object is found, we fire the action such as "click" on the UI object and pass in a closure which can access the eventhandler, the WorkflowContext, and the LocatorProcessor. The WorkflowContext includes the reference xpath to the UI object and the LocatorProcessor can generate the xpath of the UI object itself. In this way, the runtime locator is constructed. 

Then, the UI object will call the Eventhandler to fire the click event. The event will pass all the way down from the dispatcher and Selenium Client to the Selenium Server.
 
=== The Data Access Operation ===

The data access operation is very much like the action operation shown in Figure 3 and the only difference is that the Data Accessor will replace the Eventhandler. But be aware, for some data access, there is no UI locator associated with it. For example, you want to get the current DOM html presentation. In this case, you just call the Data Accessor directly.


== General Concepts ==

=== UI Objects ===

The UI Object includes
  * uid: should be unique in a UI module
  * namespace: for future extension
  * locator: the locator of the UI object, could be a base locator or a composite locator
  * Features: the inherent feature of the UI component, for example, the selection UI component normally comes with “label=?” or “value=?”. Table always has the “table”, “tr”, “td”, “th” tags.
  * useGroupInfo: this option only applies to a collection type of UI object such as Container, Table, List, Form and so on. By default, this option is turned off. If it is on, the object will use the UI objects to help locating its locator.

Regular UI objects include Button, CheckBox, Icon, InputBox, Selector, TextBox, Table... 
A container is a special UI object and it could be a pure abstract object to hold and group different UI objects together. The container will make the objects inside searchable since it uses a list to hold them.

Users can also define custom UI objects. They need to create a UI builder for each new UI 
object and add it to the UiObjectBuilderRegistry.

Be aware that each UI object only has predefined set of events or actions. For example, the InputBox has the _type_ action, but the Selector does not have that.

=== UI Object Locators ===

There are two type of UI object locators:
  * Base Locator: the actual locator at run time. Denoted by "locator".
  * Composite Locator: User specifies a set of parameters for the object and the actual locator will be derived automatically by Tellurium. Denoted by "clocator".

The Basic Locator is only a String that you can specify the run time locator, be aware that the basic locator can be a partial locator, Tellurium will construct the actual run time locator starting from the top level object and all the way to the current object. 

The Composite Locator is more complicated and its definition is as follows:
{{{
class CompositeLocator {
    String header
    String tag
    String text
    String trailer
    def position
    boolean direct
    Map<String, String> attributes = [:]
}
}}}

To use composite locator, you need to use "clocator" and its value is a map, i.e.,
{{{
clocator: [key1: value1, key2: value2, ...]
}}}
format in Groovy. The defined keys include "header", "tag", "text", "trailer", "position", and "direct". They are all optional. For most UI object, the html tag is fixed, for example, a Table's tag is always "table". If a UI object has fixed tag and it is defined in object class, you do not need to include "tag". The "direct" key specifies whether this UI object is a direct child of the header or its parent UI and the default value is "false".

You may have additional attributes, define them in the same way as the predefined keys. For example:
 
{{{
value: "Tellurium home"
}}} 

Header and Trailer are used to specify addition xpath related to this UI object and the final xpath is 
{{{
XPath = header + derived xpath for object + trailer
}}}

=== The Group Locating Concept (GLC) ===

The Group Locating Concept (GLC) concept comes from the simple observation, i.e., it is much easier to locate a collection of UI objects than a single UI object. The reason is multiple UI objects provide more search criteria to help you to locate the UIs. This concept is implemented in Tellurium. All collection type object, i.e., Container and its extended classes have an option to use the group locating concept. 

Let's see the differences between regular locating and group locating. Still take the google start page as an example:

{{{
ui.Container(uid: "google_start_page", clocator: [tag: "td"], group: "true"){
  InputBox(uid: "searchbox", clocator: [title: "Google Search"])
  SubmitButton(uid: "googlesearch", clocator: [name: "btnG", value: "Google Search"])
  SubmitButton(uid: "Imfeelinglucky", clocator: [value: "I'm Feeling Lucky"])
}

}}}

Here, clocator stands for composite locator. Without group locating, I can only use the given criteria 

{{{
tag = "td" 
}}}

to find the container locator, i.e., 
{{{
I am looking for a td html tag in the DOM
}}} 
which is quite difficult. If we use the group locating, the Container can use the group information provided by its children. Now, the problem becomes: 
{{{
  I am looking for a td html tag in the DOM and its children including an input box with
  title "Google Search", a submit button with name "btnG" and value "Google Search", and
  another submit button with value "I'm Feeling Lucky"
}}}
Woo! I have a lot of information to help me to locate the container. Once the container is found, all its children can be found very easily.

The direct result of group locating is that for most case, the information defined in the UI module itself is enough for you to locate all UI objects in that UI module. That is to say, your test code only depends on your own UI module, not its location and its outside. Even we change the UI, the test may still work.  

Another advantage is that you may be able to map your JSP, PHP, ASP,..., file directly to the UI module in Tellurium. This could help developers a lot for writing Selenium tests because they do not need to manually find the locator for an UI object. 

== DSL ==
 
Domain Specific Language (DSL) indicates a programming language or specification language   dedicated to a particular problem domain, a particular problem representation technique, and/or a particular solution technique. Here the domain refers to UI testing. DSL is specified in the class *DslContext*, which defines the basic DSLs. 

=== Define UI objects ===

_ui.Container_ is used to define the UI objects on the web and map them to objects.
For example, the search module in the google start page can be defined by 
the following DSL.

{{{
ui.Container(uid: "google_search"){
   InputBox(uid: "inputbox1", locator: "//input[@title='Google Search']")
   Button(uid: "button1", locator: "//input[@name='btnG' and @type='submit']")
}
}}}

The definition can be nested, for example
{{{
ui.Container(uid: "parent_ui"){
   InputBox(uid: "inputbox1", locator: "...")
   Button(uid: "button1", locator: "...")
   Container(uid: "child_ui){
     Selector(uid: "selector1", locator: "...")
     ...
     Container(uid: "grand_child"){
       TextBox(uid: "textbox1", locator: "...")
       ...
     }
   }
}
}}}

=== UiID ===

In DSL, the Ui object is referred by the UiID. For nested Ui objects, the UiID of the Ui Object is a concatenated of the Ui objects' uids along its path to the Ui Object. For example, in the above nested Ui Module, the TextBox is referred as "parent_ui.child_ui.grand_child.textbox1". The exceptions are tables and lists, which use {{{[x][y]}}} or {{{[x]}}} to reference its elements inside. For example, {{{labels_table[2][1]}}} and {{{GoogleBooksList.subcategory[2]}}}. Table header can be referred in the format of {{{issueResult.header[2]}}}.

For menu, you need to define an alias name for each item. For instance, the Tellurium issues page includes the following menu,

{{{
//items is a map in the format of "alias name" : menu_item
ui.SimpleMenu(uid: "IdMenu", clocator:[class: "popup", id: "pop_0"],
      items: ["SortUp":"Sort Up", "SortDown":"Sort Down", "HideColumn":"Hide Column"])
}}} 

You need to use the alias name to refer the menu item, for example, "IdMenu.SortUp".

For the option object, the option uid must be the same as the UI objects it represent
and in this way, you do not need to include it in the DSL. For example, in the following Ui Module,

{{{
//The selector to choose the data grid layout as List or Grid
ui.Option(uid: "layoutSelector"){
   Container(uid: "layoutSelector", clocator: [tag: "div"], group: "true") {
      TextBox(uid: "List", clocator: [tag: "b", text: "List", direct: "true"])
      UrlLink(uid: "Grid", clocator: [text: "Grid", direct: "true"])
   }
   Container(uid: "layoutSelector", clocator: [tag: "div"], group: "true") {
      UrlLink(uid: "List", clocator: [text: "List", direct: "true"])
      TextBox(uid: "Grid", clocator: [tag: "b", text: "Grid", direct: "true"])
   }
}
}}}

you just use

{{{
click "layoutSelector.List"
}}}

instead of

{{{
click "layoutSelector.layoutSelector.List"
}}}

=== Basic DSLs ===

Because of the Groovy Syntax, each method in the DslContext is a DSL expression. Here we list all the available methods in DslContext and their corresponding DSL syntax. Note the id here refers to the UiID in the format of "issueSearch.issueType" and the time units are all in milliseconds if not specified. Be aware, you can only apply the methods to the Ui Object if it has them defined.

  # mouseOver(String id): Simulates a user hovering a mouse over the specified element. Its DSL format is:

  {{{
    mouseOver id
  }}}

  Example:

  {{{
    mouseOver "IdMenu.SortDown"
  }}}


=== Extended DSLs ===
The DslContext can be extended to include more DSLs. For example, 
the DslScriptEngine extends DslContext to add the following DSL
{{{
openUrl url
}}}
and other assertions defined in GroovyTestCase.

== Tellurium UI Objects==


Tellurium provides a set of predefined Ui objects, which users can use directly. Here we describe them one by one in details.

=== Basic Ui Object ===

The basic Ui object is an abstract class and users cannot instantiate it directly. The basic Ui Object works as the base class for all Ui objects and it includes the following attributes:

  # uid: Ui object's identifier
  # namespace: for future extension
  # locator: the locator of the UI object, could be a base locator or a composite locator

and the base Ui object also provides the following methods:

  * boolean isElementPresent()
  * boolean isVisible()
  * boolean isDisabled()
  * waitForElementPresent(int timeout), where the time unit is ms.
  * waitForElementPresent(int timeout, int step)
  * String getText()
  * getAttribute(String attribute)

This also means all Ui Objects will inherit the above attributes and methods.

=== Button ===

Button represents various Buttons on the web and its default tag is "input". The following methods can be applied to Button:

  * click()
  * doubleClick()
  * clickAt(String coordination)

Example:

{{{
Button(uid: "searchButton", clocator: [value: "Search", name: "btn"])
}}}

=== SubmitButton ===

SubmitButton is a special Button with its type being "submit".

Example:

{{{
SubmitButton(uid: "search_web_button", clocator: [value: "Search the Web"])
}}}

=== CheckBox ===

The CheckBox on the web is abstracted as "CheckBox" Ui object. The default tag for CheckBox is "input" and its type is "checkbox". CheckBox comes with the following methods:

  * check()
  * boolean isChecked()
  * uncheck()

Example:

{{{
CheckBox(uid: "autoRenewal", clocator: [dojoattachpoint: 'dap_auto_renew'])
}}}

=== Div ===

Div is often used in the Dojo framework and it can represent a lot objects. Obviously, its tag is "div" and it has the following method:

  * click()

Example:

{{{
Div(uid: "dialog", clocator: [class: 'dojoDialog', id: 'loginDialog'])
}}}

=== Image ===

Image is used to abstract the "img" tag and it comes with the following additional methods:

  * getImageSource()
  * getImageAlt()
  * String getImageTitle()

Example:

{{{
Image(uid: "dropDownArrow", clocator: [src: 'drop_down_arrow.gif'])
}}}

=== Icon ===

Icon is similar to the Image object, but user can perform actions on it. As a result, it can have the following additional methods:

  * click()
  * doubleClick()
  * clickAt(String coordination)

Example:

{{{
Icon(uid: "taskIcon", clocator:[tag: "p", dojoonclick: 'doClick', img: "Show_icon.gif"] )
}}}

=== RadioButton ===

RadioButton is the abstract object for the Radio Button Ui. As a result, its default tag is "input" and its type is "radio". RadioButton has the following additional methods:

  * check()
  * boolean isChecked()
  * uncheck()
  * String getValue()

Example:

{{{
RadioButton(uid: "autoRenewal", clocator: [dojoattachpoint: 'dap_auto_renew'])
}}}

=== TextBox ===

TextBox is the abstract Ui object from which you can get back the text, i.e., it comes with the method:

  * String waitForText(int timeout)

Note, TextBox can have various types of tags.

Example:

{{{
TextBox(uid: "searchLabel", clocator: [tag: "span"])
}}}

=== InputBox ===

InputBox is the Ui where user types in input data. As its name stands, InputBox's default tag is "input". InputBox has the following additional methods:

  * type(String input)
  * keyType(String input), used to simulate keyboard typing
  * typeAndReturn(String input)
  * clearText()
  * boolean isEditable()
  * String getValue()

Example:

{{{
InputBox(uid: "searchBox", clocator: [name: "q"])
}}}

=== UrlLink ===

UrlLink stands for the web url link, i.e., its tag is "a". UrlLink has the following additional methods:

  * String getLink()
  * click()
  * doubleClick()
  * clickAt(String coordination)

Example:

{{{
UrlLink(uid: "Grid", clocator: [text: "Grid", direct: "true"])
}}}

=== Selector ===

Selector represents the Ui with tag "select" and user can select from a set of options. Selector has a lot of methods, such as:

  * selectByLabel(String target)
  * selectByValue(String value)
  * addSelectionByLabel(String target)
  * addSelectionByValue(String value)
  * removeSelectionByLabel(String target)
  * removeSelectionByValue(String value)
  * removeAllSelections()
  * String[] getSelectOptions()
  * String[] getSelectedLabels()
  * String getSelectedLabel()
  * String[] getSelectedValues()
  * String getSelectedValue()
  * String[] getSelectedIndexes()
  * String getSelectedIndex()
  * String[] getSelectedIds()
  * String getSelectedId()
  * boolean isSomethingSelected()

Example:

{{{
Selector(uid: "issueType", clocator: [name: "can", id: "can"])
}}}

=== Container ===

Container is an abstract object that can hold a collection of Ui objects. As a result, the  Container has a special attribute "useGroupInfo" and its default value is false. If this attribute is true, the Group Locating is enabled. But make sure all the Ui objects inside the Container are children nodes of the Container in the DOM, otherwise, you should not use the Group Locating capability.

Example:

{{{
ui.Container(uid: "google_start_page", clocator: [tag: "td"], group: "true"){
    InputBox(uid: "searchbox", clocator: [title: "Google Search"])
    SubmitButton(uid: "googlesearch", clocator: [name: "btnG", value: "Google Search"])
    SubmitButton(uid: "Imfeelinglucky", clocator: [value: "I'm Feeling Lucky"])
}
}}}

=== Form ===

Form is a type of Container with its tag being "form" and it represents web form. Like Container, it has the capability to use Group Locating and it has a special method:

  * submit()

This method is useful and can be used to submit input data if the form does not have a submit button.

Example,

{{{
ui.Form(uid: "downloadSearch", clocator: [action: "list", method: "get"], group: "true") {
    Selector(uid: "downloadType", clocator: [name: "can", id: "can"])
    TextBox(uid: "searchLabel", clocator: [tag: "span"])
    InputBox(uid: "searchBox", clocator: [name: "q"])
    SubmitButton(uid: "searchButton", clocator: [value: "Search"])
}
}}}

=== Table ===

Table is one of the most complicated Ui Object and also the most often used one. Obviously, its tag is "table" and a table could have headers besides rows and columns. Table is a good choice for data grid. Tellurium can handle its header, rows, and columns automatically for users. One important is the Table has different UiID than other Ui objects. For example, if the id of the table is "table1", then its i-th row and j-th column is referred as {{{"table1[i][j]"}}} and its m-th header is {{{"table1.header[m]"}}}.

Another distinguished feature of Table is that you can define Ui template for its elements. For example, the following example defines different table headers and the template for the first column, the element on the second row and the second column, and the template for all the other elements in other rows and columns.

{{{
ui.Table(uid: "downloadResult", clocator: [id: "resultstable", class: "results"], group: "true"){
    //define table header
    //for the border column
    TextBox(uid: "header: 1", clocator: [:])
    UrlLink(uid: "header: 2", clocator: [text: "%%Filename"])
    UrlLink(uid: "header: 3", clocator: [text: "%%Summary + Labels"])
    UrlLink(uid: "header: 4", clocator: [text: "%%Uploaded"])
    UrlLink(uid: "header: 5", clocator: [text: "%%Size"])
    UrlLink(uid: "header: 6", clocator: [text: "%%DownloadCount"])
    UrlLink(uid: "header: 7", clocator: [text: "%%..."])

    //define Ui object for the second row and the second column
    InputBox(uid: "row: 2, colum: 2" clocator: [:])
    //define table elements
    //for the border column
    TextBox(uid: "row: *, column: 1", clocator: [:])
    //For the rest, just UrlLink
    UrlLink(uid: "all", clocator: [:])
}
}}} 

Be aware, the templates inside the Table follow the name convention:

  * For the i-th row, j-th column, the uid should be "row: i, column: j"
  * The wild case for row or column is {{{"*"}}}
  * "all" stands for matching all rows and columns
  
As a result, {{{"row : *, column : 3"}}} refers to the 3rd column for all rows. Once the templates are defined for the table, Tellurium uses a special way to find a matching for a Ui element {{{table[i][j]}} in the table. i.e., the following rules apply,

   * First, Tellurium tries to find the template defined for the i-th row, j-th column.
   * If not found, Tellurium tries to search for a general template {{{"row: *, column: j"}}}, i.e., the template for column j.
   * If not found, Tellurium tries to search for another general template {{{"row: i, column: *"}}}, i.e., the template for row i.
   * If not found either, Tellurium tries to find the template matching all rows and columns. 
   * If still out of luck, Tellurium will use a TextBox as the default element for this element.

Generally speaking, Tellurium always searches for the special case first, then more general case, and until the all matching case. In this way, user can define very flexible templates for tables.

Table is a type of Container and thus, it can use the Group Locating feature. Table has the following special methods:

  * boolean hasHeader()
  * int getTableHeaderColumnNum()
  * int getTableMaxRowNum()
  * int getTableMaxColumnNum()

=== List ===

List is also a Container type abstract Ui object and it can be used to represent any list like Ui objects. Very much like Table, users can define Ui templates for List and following rule of "the special case first and then the general case". The index number is  used to specify an element and "all" is used to match all elements in the List. List also uses TextBox as the default Ui if no template could be found. Since List is a Container type, it can use the Group Locating feature.

Example:

{{{
List(uid: "subcategory", locator: "", separator: "/p"){
    InputBox(uid: "2", clocator: [title: "Google Search"])
    UrlLink(uid: "all", locator: "/a")
}
}}} 

=== SimpleMenu ===

The SimpleMenu represent a menu without a header and only contains menu items. The default tag is "div" and user should specify the alias name for each menu item. For example,

{{{
//items is a map in the format of "alias name" : menu_item
ui.SimpleMenu(uid: "IdMenu", clocator:[class: "popup", id: "pop_0"],
    items: ["SortUp":"Sort Up", "SortDown":"Sort Down", "HideColumn":"Hide Column"])
}}}

The above menu specified the menu item "Sort up", "Sort Down", and "Hiden Column" with their alias names. Users should use the alias name to refer the menu item, for instance, "IdMenu.SortUp".

The SimpleMenu has the following methods:

  * click()
  * mouseOve()
  * mouseOut()

=== SelectMenu ===

SelectMenu is designed for the selecting column menu on the Tellurium Issues page and it is prototyped to demonstrate how to write Ui object with interaction with the DOM since the Ui elements have different patterns at runtime, hence, it is not a general purpose Ui object. SelectMenu could have a header and its menu item content could keep changing when users select different columns to display. 

The SelectMenu on the Tellurium issues page is expressed as follows,

{{{
ui.SelectMenu(uid: "selectColumnMenu", clocator:[class: "popup",id: "pop__dot"], title: "Show columns:",
    items: ["ID":"ID", "Type":"Type", "Status":"Status", "Priority":"Priority", "Milestone":"Milestone", "Owner":"Owner", "Summary":"Summary", "Stars":"Stars", "Opened":"Opened", "Closed":"Closed", "Modified":"Modified", "EditColumn":"Edit Column Spec..." ])
}}}

Like SimpleMenu, SelectMenu also has the following methods:

  * click()
  * mouseOve()
  * mouseOut()

=== Option ===

Option is also designed to be adaptive the dynamic web. Option is a pure abstract object and it holds multiple UIs with each representing a possible UI pattern at runtime. For example, the List/Grid selector on the issue page can described as: 

{{{
//The selector to choose the data grid layout as List or Grid
ui.Option(uid: "layoutSelector"){
    Container(uid: "layoutSelector", clocator: [tag: "div"], group: "true") {
        TextBox(uid: "List", clocator: [tag: "b", text: "List", direct: "true"])
        UrlLink(uid: "Grid", clocator: [text: "Grid", direct: "true"])
    }
    Container(uid: "layoutSelector", clocator: [tag: "div"], group: "true") {
        UrlLink(uid: "List", clocator: [text: "List", direct: "true"])
        TextBox(uid: "Grid", clocator: [tag: "b", text: "Grid", direct: "true"])
    }
}
}}}

Note, the option's uid must be the same as the next UI objects it represent and in this way, you do not need to include option's uid in the UiID. For example,  you can just use

{{{
click "layoutSelector.List"
}}}

instead of

{{{
click "layoutSelector.layoutSelector.List"
}}}

The option object will automatically detect which UI pattern you need to use at runtime. 

== Testing Support ==

In the package org.tellurium.test, Tellurium provides three different ways to write Tellurium tests:

  # Java Test Cases including *BaseTelluriumJavaTestCase* and *TelluriumJavaTestCase*. They are both JUnit 4 test cases, i.e., they support @BeforeClass, @AfterClass, @Before, @After, @Test, and @Ignore JUnit 4 annotations. The only difference between the two is that the "TelluriumJavaTestCase" comes with predefined @BeforeClass and @AfterClass methods to setup the connection to the Selenium server and tear down the connection after all tests are done. If users want to include multiple test cases in one test suite, they should use BaseTelluriumJavaTestCase so that all the test cases can share the same Selenium connection and do not need to set up and tear down connection for each class.  
  # Groovy Test Cases, i.e., to write Tellurium tests in groovy. Users can use *TelluriumGroovyTestCase* for a single test and *TelluriumSuiteGroovyTestCase* for a test suite.
  # Data Driven Testing. Tellurium provides the class *TelluriumDataDrivenModule* for users to define data driven testing modules and the class *TelluriumDataDrivenTest* to drive the actual tests. The details can be found on [http://code.google.com/p/aost/wiki/DataDrivenTesting the Data Driven Testing Wiki page].

Apart from the above, Tellurium also provides users the capability to write Tellurium tests and Tellurium data driven tests in pure DSL scripts. The *DslScriptExecutor* is used to run the .dsl files.


== Future Directions ==

Tellurium will continue evolving and more new features will be developed to make it more powerful and easier to use. We are considering the following new features for the next or future releases:

  # Add full Maven 2 support for project building, testing, and artifact publishing.
  # A *Firefox plugin* will be developed to automatically generate UI modules for users. The idea is to provide the "select UI by click" capability in the plugin to select an area of UI. Then the plugin will extract the html source and use a special algorithm to generate Tellurium style UI modules using composite locators and group locating concept.  After that, the plugin will validate the generated UI module to make sure it is unique in the current DOM and output the results. 
  # Tellurium will provide a *Locator Query Language* to get the locators of Ui objects by some search criteria such as their attributes and their relationship to each other, i.e., parent, child, and sibling. That is to say, Tellurium will be interactive with the DOM in runtime so as to be adaptive to dynamic web page. 
  # The *Automated Acceptance Testing* feature will be added to Tellurium. The basic idea is to setup a server and the user can use web browser to browse all available tests defined in the registry at the server side. The user can select any test to run by typing in parameters required by the test and see the actual test result. 